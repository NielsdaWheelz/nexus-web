# PR-06 Spec — Keyword Search (v1)

This PR introduces keyword search across all user-visible content using PostgreSQL full-text search.
It enforces strict visibility guarantees and integrates cleanly with existing media, library, and conversation models.

This PR MUST NOT introduce semantic/vector search, ranking personalization, facets, or public sharing.

---

## 1) Goals

### Primary

- Allow users to keyword-search all content they can see:
  - media titles
  - document fragments
  - annotations
  - messages
- Guarantee **zero visibility leakage**.
- Provide stable pagination with acceptable performance.

### Secondary

- Provide relevance ranking that "feels right" without overfitting.
- Keep implementation simple and auditable.

---

## 2) Non-Goals (Explicit)

- No semantic search or embeddings
- No fuzzy matching (`pg_trgm`, `unaccent`)
- No cross-user discovery
- No conversation titles (messages imply conversations)
- No total-count accuracy guarantees
- No highlighting UI beyond snippets

---

## 3) Search Model

### Indexed Fields (Generated Stored Columns)

| Table | Column | Source |
|-------|--------|--------|
| `media` | `title_tsv` | `media.title` |
| `fragment` | `canonical_text_tsv` | `fragment.canonical_text` |
| `annotation` | `body_tsv` | `annotation.body` |
| `message` | `content_tsv` | `message.content` (conditional) |

- Language: `english`
- Implementation: `GENERATED ALWAYS AS (to_tsvector('english', <source>)) STORED`
- **Message special case:**
  ```sql
  content_tsv GENERATED ALWAYS AS (
    CASE WHEN status = 'pending' THEN NULL
         ELSE to_tsvector('english', content)
    END
  ) STORED
  ```
- Indexes: GIN on all `_tsv` columns
- Message index is partial:
  ```sql
  CREATE INDEX ix_message_content_tsv ON message USING GIN (content_tsv)
  WHERE status <> 'pending';
  ```

**Note:** PR-01 migration already adds generated columns and GIN indexes. PR-06 adds no schema changes.

---

## 4) Visibility Rules (Hard Constraint)

Search results MUST obey the same visibility predicates as read APIs.

### Media-Anchored Content

(media, fragments)

A result is visible iff:
- its `media_id` appears in **any** library where the viewer is a member

### Annotations

(annotations only)

In S3, annotations are **owner-only**:
- `annotation.user_id = viewer_user_id` AND media is visible via library membership

(S4 will expand annotation visibility with sharing rules; until then, search returns only own annotations.)

### Messages

(messages only)

A message is visible iff its conversation is visible:
- `conversation.owner_user_id = viewer_user_id`, OR
- `conversation.sharing = 'public'`, OR
- `conversation.sharing = 'library'` AND exists a `conversation_share` row linking to a library where viewer is a member

(Note: `sharing=library` UI is S4, but search enforces the real rules now.)

### Failed Media

- `media.title` results ARE returned if visible by library membership
- fragments/annotations are returned only if their rows exist (status ≥ `ready_for_reading`)

### Exclusions

- `message.status = pending` → never searchable
- invisible context targets → never leak via snippets

---

## 5) Ranking

### Base Ranking

- PostgreSQL `ts_rank_cd`

### Type Weight Multipliers (Applied Post-Rank)

| Type | Multiplier |
|------|------------|
| media (title) | 1.3 |
| annotation | 1.2 |
| message | 1.0 |
| fragment | 0.9 |

Final score = `ts_rank_cd * multiplier`

### Merge Algorithm

1. Query each type separately with visibility + scope filters
2. Fetch top K candidates per type (K = 200)
3. Compute weighted score per result
4. Normalize scores within each type to [0, 1] range
5. Merge-sort all results by normalized score DESC, then by id ASC
6. Apply offset pagination to merged list

---

## 6) Query Semantics

### Query Parsing

- Use `websearch_to_tsquery('english', q)`
- Supports quoted phrases, `-` exclusions, and implicit AND
- No prefix or fuzzy matching

### Minimum Length

- If `len(trim(q)) < 2`: return empty results (`200 OK`)
- If tsquery is empty (all stopwords): return empty results

No errors for short or stopword-only queries.

---

## 7) Scopes

### Supported Scopes

| Scope | Meaning |
|-------|---------|
| `all` | All visible content |
| `media:<id>` | Content anchored to a single media |
| `library:<id>` | Content anchored to media in that library |
| `conversation:<id>` | Messages within that conversation |

### Authorization

- `media:<id>` requires `can_read_media(viewer_id, media_id)` → 404 if not visible
- `library:<id>` requires viewer is a member of that library → 404 if not member
- `conversation:<id>` requires conversation visibility predicate (owner, public, or library-shared) → 404 if not visible
- Unauthorized scope → `404` (no existence leak)

---

## 8) Result Types

Returned as a mixed, ordered list:

```json
{
  "results": [
    {
      "type": "fragment",
      "id": "...",
      "score": 0.87,
      "snippet": "...matched text...",
      "source_type": "media",
      "source_id": "..."
    }
  ],
  "page": {
    "has_more": true,
    "next_cursor": "..."
  }
}
```

### Navigation Fields by Type

| Type | Required Fields |
|------|-----------------|
| `media` | `id`, `title` (snippet source) |
| `fragment` | `id`, `media_id`, `idx` |
| `annotation` | `id`, `highlight_id`, `media_id` |
| `message` | `id`, `conversation_id`, `seq` |

### Notes

- No conversation result type in v1
- Snippet max length: 300 chars
- Snippets generated after visibility filtering using `ts_headline`

---

## 9) Pagination

- Offset-based cursor encoded as base64url JSON: `{"offset": <int>}`
- Ordering per-type: `(score DESC, id ASC)`
- Merged list ordering is deterministic for a fixed snapshot but **not stable across writes**
- No total count returned
- Page size configurable (default: 20, max: 50)

---

## 10) Backend Architecture

### Visibility CTE

Introduce reusable helper:

```python
visible_media_ids_cte(viewer_user_id)
```

Used by:
- fragment search
- annotation search
- media search

Messages are filtered separately via conversation visibility.

### Execution Strategy

- Visibility filtering occurs inside SQL, not post-filter
- No post-query redaction
- Snippet generation happens only on filtered rows

---

## 11) Logging & Safety

- Do NOT log raw search queries
- Normalize query before hashing: `q_normalized = trim(lower(q))`
- Log:
  - `query_len`: length of raw query
  - `query_hash`: sha256 of `q_normalized`
  - `scope`: requested scope
  - `types_count`: number of types requested
  - `results_count`: number of results returned
  - `latency_ms`: total search latency
- Prevent search from becoming a data exfiltration vector

---

## 12) API

### Endpoint

```
GET /search
```

### Parameters

| Param | Type | Notes |
|-------|------|-------|
| `q` | string | required |
| `scope` | string | optional, default `all` |
| `types` | list[string] | optional, default `[media, fragment, annotation, message]` |
| `cursor` | string | optional, base64url-encoded offset |
| `limit` | int | optional, default 20, max 50 |

### Types Parameter

- Valid types: `media`, `fragment`, `annotation`, `message`
- Unknown types are silently ignored (no 400)
- Empty list after filtering → search all types

---

## 13) Error Codes

| Code | HTTP | Meaning |
|------|------|---------|
| `E_NOT_FOUND` | 404 | Scope object not visible |
| `E_INTERNAL` | 503 | Search failure |

(No errors for short or empty queries.)

---

## 14) Acceptance Criteria

- Keyword search returns correct hits across all indexed types
- Search never leaks invisible content
- Library scope requires membership
- Conversation scope requires visibility
- Media scope requires can_read_media
- Pending messages never appear
- Failed media titles appear when visible
- Snippets generated only post-filter
- Cursor pagination deterministic within snapshot
- No raw queries logged
- Visibility test suite passes

### Performance Verification

- Perf harness script produces EXPLAIN output (manual review, not CI gate)
- Smoke test: queries complete under 500ms with 10k seeded rows per type

---

## 15) Risks & Mitigations

| Risk | Mitigation |
|------|------------|
| Visibility leaks | SQL-level filtering + tests |
| Slow queries | GIN indexes + simple ranking |
| Relevance complaints | Stable type multipliers |
| Stopword confusion | Empty-result behavior |

---

## 16) Out of Scope (Explicit)

- Semantic search
- Query suggestions
- Facets
- Relevance learning
- Cross-user discovery
- Highlighted term UI polish
