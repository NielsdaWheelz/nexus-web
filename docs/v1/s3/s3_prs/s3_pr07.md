# Slice 3 — PR-07 Spec (L3)
## frontend: streaming chat ui + bff routes + quote-to-chat + keys + search

this pr ships the full client surface area for slice 3:
- bff route handlers for all s3 endpoints
- streaming (sse) end-to-end through next.js bff (no buffering)
- chat ui (conversations list + thread + composer + model picker)
- quote-to-chat trigger from existing highlights
- keys ui (byok management)
- search ui (keyword search)

this pr must **not** introduce domain logic in next.js. route handlers are transport-only (see §4.1.7 for the one allowed exception: transport headers for streaming correctness).

---

## 0) prerequisites / assumptions

- backend s3 endpoints exist exactly as documented in the "actual routes + payload shapes".
- `ENABLE_STREAMING=1` available in env and backend supports `/messages/stream` endpoints.
- existing `proxyToFastAPI()` and `proxyToFastAPIWithDeps()` are the only allowed way to reach fastapi from the browser.
- next.js app router route handlers run with `runtime = "nodejs"`.

---

## 1) goals

### primary
1. users can start a new chat, send messages, and receive assistant responses **streaming**.
2. users can open an existing conversation and load message history (paginated).
3. users can attach context via `contexts=[{type:"highlight", id}]` (quote-to-chat).
4. users can select a model from `/models` and send with `key_mode`.
5. users can manage byok keys (`/keys`) and see provider availability update.
6. users can keyword search via `/search` and navigate to results.

### secondary
- deterministic, debuggable error handling with `x-request-id`.
- strict request/response header allowlisting preserved.
- no buffering of sse responses in bff.

---

## 2) non-goals

- no library sharing ui
- no semantic search ui
- no summarization ui
- no message editing
- no multi-context selection ui beyond highlight attach (v1)
- no websockets; sse only
- no persistent conversation-level "default model" stored server-side
- no selection-trigger for quote-to-chat (highlight-row only in v1)
- no settings navigation item; keys page is reachable directly

---

## 3) critical decisions (locked)

1. **streaming default**: when `ENABLE_STREAMING=1`, chat send uses streaming endpoints by default and falls back to non-streaming on failure.
2. **routing**:
   - `/conversations` route exists (list)
   - `/conversations/[id]` route exists (open conversation)
3. **chat is a single pane**:
   - thread + composer + model picker in one pane
   - attached contexts shown as chips above composer
4. **error semantics**:
   - transport errors (non-2xx) append nothing; show inline composer error.
   - assistant errors (200 + `assistant.status=error`) append assistant bubble in error state with retry.
5. **quote-to-chat trigger**: ship from existing highlight rows in linked-items pane only.

---

## 4) code changes

### 4.1 bff streaming passthrough (mandatory)

#### file
`apps/web/src/lib/api/proxy.ts`

#### required behaviors
- support non-streaming requests exactly as today.
- add a streaming passthrough path for `text/event-stream` responses:
  - **never** call `response.text()` / `response.arrayBuffer()` for sse.
  - return a `Response` whose body streams bytes from upstream to the browser.
  - preserve `content-type: text/event-stream` and disable buffering/caching.

#### 4.1.1 signature change

extend `proxyToFastAPI()` to accept an options object:

```typescript
interface ProxyOptions {
  /** hint that the upstream response will be SSE. forces streaming path
      even if upstream content-type is mislabeled. */
  expectStream?: boolean;
}

export async function proxyToFastAPI(
  request: Request,
  path: string,
  options?: ProxyOptions
): Promise<Response>
```

streaming route handlers pass `{ expectStream: true }`. the content-type detection remains as a backstop for the non-hinted path.

#### 4.1.2 request header allowlist
- add `"idempotency-key"` to `ALLOWED_REQUEST_HEADERS` (lowercase).
- forward it exactly once (no duplication).
- continue to strip disallowed headers.
- in `sseClient()` (browser), set `Accept: text/event-stream` on the request. `accept` is already in the allowlist so it forwards cleanly.

#### 4.1.3 response headers — SSE path

for SSE responses, **set these directly on the returned Response** (do not rely on upstream or the general allowlist):
- `content-type: text/event-stream; charset=utf-8` (preserve upstream value)
- `cache-control: no-cache, no-transform`
- `connection: keep-alive`
- `x-accel-buffering: no` (nginx proxy hint)
- `x-request-id` (always)

these are set **only in the SSE code path**, not added to `ALLOWED_RESPONSE_HEADERS`. the general allowlist remains unchanged. this is transport logic, not domain logic (see §4.1.7).

#### 4.1.4 sse detection
treat as streaming if **either**:
- `options.expectStream === true` (route handler hint — primary signal), OR
- upstream `content-type` starts with `text/event-stream` (backstop)

#### 4.1.5 stream bridging
- if upstream body is `ReadableStream`, pipe it directly into the returned `Response`.
- if upstream body is node stream, bridge into a `ReadableStream` (no full buffering).
- **do not transform bytes; do not parse events.**

#### 4.1.6 abort propagation
- pass `signal: request.signal` to the upstream `fetch()` call.
- in the SSE streaming path, when the downstream client disconnects (response stream closes), cancel the upstream `ReadableStream` reader. this ensures the fastapi connection is torn down promptly.

#### 4.1.7 transport header rule (binding)

> route handlers may set transport headers required for streaming correctness (`cache-control`, `x-accel-buffering`, `connection`), but may **not** inspect or transform payloads. this is the only allowed exception to the "transport-only" rule.

#### 4.1.8 tests
- **incremental delivery test** (vitest, node):
  - fake upstream emits chunk1, waits 50ms, then emits chunk2.
  - test starts reading the response body immediately.
  - assert chunk1 is received **before** chunk2 is enqueued (i.e. `reader.read()` resolves with chunk1 while the stream is still open, not done).
  - this fails if the proxy accidentally buffers.
- **SSE headers test**: assert the streaming response has `content-type: text/event-stream`, `cache-control: no-cache, no-transform`, and `x-request-id`.
- **idempotency-key forwarding test**: assert the header reaches upstream.
- **abort propagation test**: abort the client request; assert the upstream fetch was also aborted.
- **no-body-read guard**: assert that a streaming route handler never calls `request.json()` on the incoming request (enforced by code review + written as a test constraint).

---

### 4.2 bff route handlers (thin proxies)

#### required exports for ALL s3 route handlers

```typescript
export const runtime = "nodejs";
export const dynamic = "force-dynamic";
export const revalidate = 0;
```

this prevents next.js from caching GETs or applying static optimizations to any s3 endpoint. this is transport correctness, not optional.

#### new routes
- `/app/api/conversations/route.ts`
  - `GET` → `GET /conversations`
  - `POST` → `POST /conversations`
- `/app/api/conversations/[id]/route.ts`
  - `GET` → `GET /conversations/{id}`
  - `DELETE` → `DELETE /conversations/{id}`
- `/app/api/conversations/[id]/messages/route.ts`
  - `GET` → `GET /conversations/{id}/messages`
  - `POST` → `POST /conversations/{id}/messages` (non-streaming fallback only)
- `/app/api/conversations/[id]/messages/stream/route.ts`
  - `POST` → `POST /conversations/{id}/messages/stream` (sse)
  - calls `proxyToFastAPI(req, path, { expectStream: true })`
- `/app/api/conversations/messages/route.ts`
  - `POST` → `POST /conversations/messages` (new conversation, non-streaming fallback)
- `/app/api/conversations/messages/stream/route.ts`
  - `POST` → `POST /conversations/messages/stream` (new conversation, sse)
  - calls `proxyToFastAPI(req, path, { expectStream: true })`
- `/app/api/messages/[messageId]/route.ts`
  - `DELETE` → `DELETE /messages/{messageId}`
- `/app/api/models/route.ts`
  - `GET` → `GET /models`
- `/app/api/keys/route.ts`
  - `GET` → `GET /keys`
  - `POST` → `POST /keys`
- `/app/api/keys/[keyId]/route.ts`
  - `DELETE` → `DELETE /keys/{keyId}`
- `/app/api/search/route.ts`
  - `GET` → `GET /search`

#### streaming route handler rules
- must return the streaming `Response` from `proxyToFastAPI()` without reading the body.
- must not JSON-parse, must not wrap envelopes.
- must not call `request.json()` on the incoming request (body is forwarded as raw bytes by the proxy).

---

## 5) ui changes

### 5.1 navigation
- add navbar items:
  - "chat" → `/conversations`
  - "search" → `/search`
  - "keys" → `/settings/keys`
- keep existing "libraries" and "sign out".

### 5.2 routes / pages

#### `/conversations`
- left: conversations list (cursor pagination, "load more")
- main: empty state ("select a conversation or start a new chat")
- "new chat" button opens a composer view (no conversation created until send).

#### `/conversations/[id]`
- render chat pane:
  - message thread (paginated; "load older" button at top)
  - composer:
    - textarea
    - model dropdown (from `/models`)
    - key mode dropdown (auto/byok_only/platform_only) (optional to expose; default auto ok)
    - attached contexts chips (initially empty)
    - send button
- on initial load:
  - fetch conversation metadata + first page of messages.
- append new messages locally from send response / stream.

### 5.3 sse client parser (binding)

implement `sseClient()` as a browser-side helper. framing rules:

1. only process `event:` + `data:` lines (standard SSE format).
2. ignore comment lines (`:`) and unknown event types.
3. `data:` payload is JSON, one object per event. no multi-line JSON.
4. enforce max event size: **256 KB**. if a single event exceeds this, treat as stream error and fail the assistant bubble.
5. if JSON parse fails on a `data:` line: treat as stream error, finalize assistant bubble in error state.
6. backend uses `event:` field to distinguish event types (`event: meta`, `event: delta`, `event: done`). do not use `data.type` for routing.
7. `sseClient()` must set `Accept: text/event-stream` request header.

### 5.4 streaming send behavior (default)

#### send flow (when `ENABLE_STREAMING=1`)
- on click send:
  1. generate new `Idempotency-Key` (uuid).
  2. disable send until done or failure.
  3. POST to streaming endpoint:
     - if conversation id exists → `/api/conversations/{id}/messages/stream`
     - else → `/api/conversations/messages/stream`
  4. parse SSE events:
     - `meta`: contains ids + provider/model; set local `conversationId` if newly created. **immediately** do `router.replace(`/conversations/${conversationId}`)` for new conversations (shallow client nav; keeps streaming in the same pane, fixes URL while stream is still open).
     - `delta`: append chunk to in-progress assistant message content in UI only.
     - `done`: finalize assistant message (status + error_code).
  5. after done:
     - if `assistant.status=error`, show inline error state on bubble and offer "retry".

#### fallback
- if streaming request fails before `meta`:
  - fall back to non-streaming endpoint (`/api/.../messages`) once.
- if streaming fails after `meta`:
  - show assistant bubble error ("stream interrupted") with retry.

#### local state: message reconciliation (binding)

the client must never render duplicate messages when optimistic UI meets server-returned data.

**streaming path:**
1. on send click, create optimistic placeholders with **temporary IDs** (e.g. `temp-user-{uuid}`, `temp-assistant-{uuid}`).
2. user placeholder: role=user, content=input text, status=complete.
3. assistant placeholder: role=assistant, content="", status=pending.
4. on `meta` event: replace temporary IDs with server-assigned IDs (`user_message_id`, `assistant_message_id`). keep the same objects in state; just patch the IDs.
5. on `delta` events: append to the assistant placeholder content.
6. on `done`: set final status.
7. if the user later calls `GET /messages` (e.g. "load older"), deduplicate by ID — messages already in local state are not re-inserted.

**non-streaming path:**
1. do **not** create optimistic placeholders.
2. on response, append `user_message` + `assistant_message` directly from server payload.
3. no reconciliation needed because no optimistic state exists.

### 5.5 non-streaming send behavior (fallback path)
- call existing non-stream endpoints.
- append returned `user_message` + `assistant_message`.
- if assistant is error, render bubble as error.

---

## 6) quote-to-chat (highlight → chat)

### 6.1 ui trigger in linked items
- add action on `LinkedItemRow` (for highlights only):
  - button: "send to chat"

### 6.2 navigation rule (binding)

deterministic rule for where the highlight attaches:
- if current route is `/conversations/:id` → attach highlight to **that** conversation's composer.
- else → navigate to `/conversations` and open "new chat" draft state with highlight pre-attached.

do **not** maintain cross-page global "focused conversation" state. the route determines the target. no spooky action at a distance.

### 6.3 attached contexts representation (client)
- composer maintains `attachedContexts: ContextItem[]` where `ContextItem = { type: "highlight"|"annotation"|"media"; id: string }`.
- v1 supports attaching highlights only via ui.
- limit to max 10; show count and hard cap.

### 6.4 send payload
- include `contexts: attachedContexts` in `SendMessageRequest`.
- after successful send, clear attached contexts.

---

## 7) settings: byok key management

### 7.1 route
`/settings/keys`

### 7.2 ui
- list keys from `/api/keys`:
  - provider
  - fingerprint
  - status
  - last_tested_at
  - revoke button
- add/update form:
  - provider dropdown
  - api_key input (password field, `autoComplete="off"`)
  - submit calls `POST /api/keys`
- no key plaintext ever displayed after submit.

### 7.3 security constraints (binding)
- never `console.log` form state containing the api key.
- on submit success **or** failure, explicitly `setApiKey("")` to clear the input state.
- mark input `autoComplete="off"`.
- never store api keys in `localStorage`.
- key input value exists only in component state during the form lifecycle; cleared immediately after submit completes.

### 7.4 behavior
- after add/update/revoke, refetch list.

---

## 8) search ui

### 8.1 route
`/search`

### 8.2 ui
- query input
- filters:
  - types (checkboxes): media/fragment/annotation/message
  - scope default `all` (optional advanced scope entry later)
- results list showing:
  - type badge
  - snippet
  - for fragment: show media title + fragment idx
  - for message: show conversation id + seq
- click behavior:
  - media/fragment/annotation → navigate to `/media/:id` (v1: just open media; no scroll-to-fragment)
  - message → navigate to `/conversations/:conversationId` (v1: just open conversation; no scroll-to-message)

---

## 9) acceptance criteria (pr-07)

### streaming proxy
- [ ] `proxyToFastAPI()` accepts `{ expectStream: true }` and streams `text/event-stream` without buffering.
- [ ] SSE responses include `content-type: text/event-stream`, `cache-control: no-cache, no-transform`, `x-request-id`.
- [ ] `idempotency-key` forwarded from browser to fastapi.
- [ ] abort cancels upstream fetch on client disconnect.
- [ ] incremental delivery test passes (chunk1 received before chunk2 enqueued).

### chat ux
- [ ] `/conversations` lists conversations (cursor).
- [ ] `/conversations/:id` loads messages (cursor) and can send.
- [ ] streaming send shows tokens incrementally.
- [ ] fallback to non-streaming works when streaming disabled/fails early.
- [ ] assistant error messages render as error bubbles with retry.
- [ ] new conversation: URL updates to `/conversations/:id` on `meta` event (not after stream completes).
- [ ] no duplicate messages after optimistic insert + later `GET /messages`.

### quote-to-chat
- [ ] from an existing highlight row: attach highlight context and send.
- [ ] attached contexts chips visible and removable.
- [ ] context cap of 10 enforced client-side.
- [ ] route determines target: `/conversations/:id` → that composer; else → new chat draft.

### keys
- [ ] user can add/update/revoke byok keys.
- [ ] api key never re-rendered after submit; only fingerprint shown.
- [ ] api key input cleared on submit (success and failure).

### search
- [ ] keyword search returns results and never crashes ui.
- [ ] clicking result navigates to correct target (media page or conversation page).

### invariants
- [ ] bff remains transport-only: no domain rules in route handlers (transport headers for SSE are the sole exception per §4.1.7).
- [ ] all s3 route handlers export `runtime = "nodejs"`, `dynamic = "force-dynamic"`, `revalidate = 0`.
- [ ] request id preserved and shown for failures (at least in console + inline error details).

---

## 10) risks + mitigations

1. **sse buffering in bff**
   - mitigation: `expectStream` hint + content-type backstop + `x-accel-buffering: no` + `no-transform` in cache-control + vitest that asserts incremental chunk delivery with timing.
2. **next.js runtime differences**
   - mitigation: force `runtime="nodejs"`, `dynamic="force-dynamic"`, `revalidate=0` on all s3 routes.
3. **state sync bugs (conversation id assigned during stream)**
   - mitigation: `router.replace()` to `/conversations/:id` immediately on `meta` event. URL matches state within one event cycle, not after 45s.
4. **double-send**
   - mitigation: disable send while in-flight; generate new idempotency key per click; retry uses new key.
5. **duplicate messages from optimistic UI**
   - mitigation: streaming path uses temp IDs, patches to real IDs on `meta`. non-streaming path has no optimistic state. `GET /messages` deduplicates by ID.
6. **accidental body buffering in streaming route handler**
   - mitigation: streaming route handlers must never call `request.json()` or `await response.text()`. enforce via code review and written test constraint.
7. **key leakage via devtools/logs**
   - mitigation: `setApiKey("")` on submit, `autoComplete="off"`, never `console.log` form state.

---

## 11) implementation notes (binding)

- no react-query/swr introduced in this pr.
- keep fetch wrappers (`apiFetch`) for non-streaming.
- implement a small `sseClient()` helper for parsing events from `fetch()` response body.
- `sseClient()` sets `Accept: text/event-stream` on the request.
- `sseClient()` enforces framing rules from §5.3: `event:` field routing, 256KB max event size, JSON-only data, fail on parse error.
- all streaming parsing happens in the browser; bff only forwards bytes.
- never store api keys in localStorage; only in-flight in component state; cleared after submit.
