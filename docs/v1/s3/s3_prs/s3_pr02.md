# PR-02 Spec — Conversations + Messages CRUD (Slice 3)

This PR introduces **conversation and message CRUD** and enforces all ownership, visibility, and invariant rules required by Slice 3, without yet introducing LLM execution, send-message semantics, or sharing UI.

This PR is intentionally **boring and strict**: it defines the ground truth for conversations and messages so later PRs (LLM send, sharing, search) can build on stable invariants.

---

## Scope

### Included

- Conversation CRUD (owner-only)
- Message listing and deletion
- Service-layer enforcement of sharing invariants (tested via service calls, no routes)
- Context insertion helpers (no message creation routes yet)
- Cursor-based pagination with explicit encoding
- Hard-delete semantics + cascade behavior
- Integration tests for all invariants

### Explicitly Excluded

- `POST /conversations/:id/messages` (send-message) — PR-05
- LLM execution
- Streaming
- Library sharing UI
- Semantic/vector search
- Message editing or branching
- Public conversation UI
- Context deletion API (contexts not yet created through routes)

---

## API Endpoints

### Response Format

All timestamps are ISO 8601 strings (e.g., `"2026-01-23T12:00:00Z"`), consistent with existing API.

---

### `GET /conversations`

List conversations owned by the viewer.

**Auth:** Authenticated user only sees their own conversations.

**Query Params:**

| Param | Type | Default | Min | Max | Notes |
|-------|------|---------|-----|-----|-------|
| `limit` | int | 50 | 1 | 100 | Clamped in service: `limit = min(max(limit, 1), 100)` |
| `cursor` | string | (none) | — | — | Opaque cursor from previous response |

**Ordering:** `(updated_at DESC, id DESC)` — most recently active first.

**Cursor Encoding:**
- Base64url-encoded JSON: `{"updated_at":"<iso>","id":"<uuid>"}`
- Query uses tuple comparison: `(updated_at, id) < (cursor.updated_at, cursor.id)` with DESC order
- Cursor omitted → first page
- Direction: forward-only
- Inclusivity: exclusive ("after cursor")

**Response (200):**

```json
{
  "data": [
    {
      "id": "550e8400-e29b-41d4-a716-446655440000",
      "sharing": "private",
      "message_count": 5,
      "created_at": "2026-01-20T10:00:00Z",
      "updated_at": "2026-01-23T12:00:00Z"
    }
  ],
  "page": {
    "next_cursor": "eyJ1cGRhdGVkX2F0IjoiMjAyNi0wMS0yM1QxMjowMDowMFoiLCJpZCI6IjU1MGU4NDAwLWUyOWItNDFkNC1hNzE2LTQ0NjY1NTQ0MDAwMCJ9"
  }
}
```

**Notes:**
- `page.next_cursor` is `null` when no more results
- `message_count` is derived (count of messages in conversation)

**Errors:**

| Code | Status | When |
|------|--------|------|
| `E_INVALID_CURSOR` | 400 | Cursor malformed or unparseable |

---

### `POST /conversations`

Create an empty conversation.

**Auth:** Authenticated user becomes owner.

**Request Body:** (none required)

**Behavior:**
- `owner_user_id` = authenticated user
- `sharing` = `'private'` (fixed in PR-02, not mutable via any route)
- `next_seq` = 1

**Response (201):**

```json
{
  "data": {
    "id": "550e8400-e29b-41d4-a716-446655440000",
    "sharing": "private",
    "message_count": 0,
    "created_at": "2026-01-23T12:00:00Z",
    "updated_at": "2026-01-23T12:00:00Z"
  }
}
```

---

### `GET /conversations/:id`

Fetch conversation metadata.

**Auth:**
- Owner → allowed
- Anyone else → `404 E_CONVERSATION_NOT_FOUND` (masked)

**Response (200):**

```json
{
  "data": {
    "id": "550e8400-e29b-41d4-a716-446655440000",
    "sharing": "private",
    "message_count": 5,
    "created_at": "2026-01-20T10:00:00Z",
    "updated_at": "2026-01-23T12:00:00Z"
  }
}
```

**Errors:**

| Code | Status | When |
|------|--------|------|
| `E_CONVERSATION_NOT_FOUND` | 404 | Conversation doesn't exist OR viewer is not owner |

---

### `DELETE /conversations/:id`

Delete a conversation.

**Auth:**
- Owner → allowed
- Anyone else → `404 E_CONVERSATION_NOT_FOUND` (masked)

**Behavior:**
- Hard delete
- Cascades (via DB foreign keys) to:
  - `message` (and transitively `message_context`, `message_llm`)
  - `conversation_media`
  - `conversation_share`

**Response:** `204 No Content`

**Errors:**

| Code | Status | When |
|------|--------|------|
| `E_CONVERSATION_NOT_FOUND` | 404 | Conversation doesn't exist OR viewer is not owner |

---

### `GET /conversations/:id/messages`

List messages in a conversation.

**Auth:**
- Owner → allowed
- Anyone else → `404 E_CONVERSATION_NOT_FOUND` (masked)

**Query Params:**

| Param | Type | Default | Min | Max | Notes |
|-------|------|---------|-----|-----|-------|
| `limit` | int | 50 | 1 | 100 | Clamped in service: `limit = min(max(limit, 1), 100)` |
| `cursor` | string | (none) | — | — | Opaque cursor from previous response |

**Ordering:** `(seq ASC, id ASC)` — oldest first (chat order).

**Cursor Encoding:**
- Base64url-encoded JSON: `{"seq":123,"id":"<uuid>"}`
- Query uses tuple comparison: `(seq, id) > (cursor.seq, cursor.id)` with ASC order
- Cursor omitted → first page
- Direction: forward-only
- Inclusivity: exclusive ("after cursor")

**Response (200):**

```json
{
  "data": [
    {
      "id": "660e8400-e29b-41d4-a716-446655440001",
      "seq": 1,
      "role": "user",
      "content": "Hello, can you help me understand this passage?",
      "status": "complete",
      "error_code": null,
      "created_at": "2026-01-23T12:00:00Z",
      "updated_at": "2026-01-23T12:00:00Z"
    },
    {
      "id": "660e8400-e29b-41d4-a716-446655440002",
      "seq": 2,
      "role": "assistant",
      "content": "Of course! I'd be happy to help...",
      "status": "complete",
      "error_code": null,
      "created_at": "2026-01-23T12:00:05Z",
      "updated_at": "2026-01-23T12:00:10Z"
    }
  ],
  "page": {
    "next_cursor": "eyJzZXEiOjIsImlkIjoiNjYwZTg0MDAtZTI5Yi00MWQ0LWE3MTYtNDQ2NjU1NDQwMDAyIn0"
  }
}
```

**Errors:**

| Code | Status | When |
|------|--------|------|
| `E_CONVERSATION_NOT_FOUND` | 404 | Conversation doesn't exist OR viewer is not owner |
| `E_INVALID_CURSOR` | 400 | Cursor malformed or unparseable |

---

### `DELETE /messages/:id`

Delete a single message.

**Auth:**
- Owner of conversation → allowed
- Anyone else → `404 E_MESSAGE_NOT_FOUND` (masked)

**Behavior:**
- Hard delete the message
- Cascades (via DB) to `message_context`
- **Auto-delete conversation:** `delete_message()` checks remaining message count in same transaction; if 0, deletes the conversation
- Non-last message deletion: conversation persists

**Response:** `204 No Content`

**Errors:**

| Code | Status | When |
|------|--------|------|
| `E_MESSAGE_NOT_FOUND` | 404 | Message doesn't exist OR viewer is not conversation owner |

---

## Error Codes (New in PR-02)

| Code | Status | Description |
|------|--------|-------------|
| `E_CONVERSATION_NOT_FOUND` | 404 | Conversation doesn't exist or viewer cannot access |
| `E_MESSAGE_NOT_FOUND` | 404 | Message doesn't exist or viewer cannot access |
| `E_INVALID_CURSOR` | 400 | Pagination cursor is malformed or unparseable |

---

## Service-Layer Responsibilities

### Ownership & Visibility

- Conversations and messages are **owner-only** in PR-02
- `conversation.sharing` is always `'private'` and **not mutable** via any route in PR-02
- Unauthorized access is always masked as 404
- `can_read_media()` is not consulted here (no media anchoring in CRUD routes)

---

### Sharing Invariants (Service Only, No Routes)

Implemented in `services/shares.py`. **No public routes expose these in PR-02.**

Share invariants are exercised via **service-layer unit/integration tests only**.

**Rules enforced:**

| State | Rule |
|-------|------|
| `sharing = 'private'` | Forbids any `conversation_share` rows |
| `sharing = 'library'` | Requires ≥1 `conversation_share` row |
| Add share | Owner must be member of library |
| Delete last share | Auto-transitions `sharing: 'library' → 'private'` |

**How does `sharing = 'library'` get set?**
- Not reachable in PR-02 (no route mutates `sharing`)
- Tests call service functions directly to verify invariants
- Routes for sharing deferred to later PR

---

### Context Service (Scaffold)

`services/contexts.py` provides helpers used later by send-message (PR-05).

**PR-02 scope:**
- Validate `target_type` ↔ FK consistency
- Insert `message_context` rows with ordinal ordering
- Resolve `media_id` for context targets:
  - `media` → direct
  - `highlight` / `annotation` → via `fragment.media_id`
- Transactionally upsert `conversation_media`
- `recompute_conversation_media(conversation_id)` helper

**Deferred to PR-05:**
- Context deletion API semantics (contexts not yet created through routes)
- Any route that creates contexts

No public routes use context service in PR-02; tested via unit/integration tests only.

---

### `conversation_media` Management

**Update triggers:**
- Context insertion → upsert `conversation_media` (transactional)
- Context deletion via service → recompute (when added in PR-05)

**Staleness model:**
- DB-level cascades (highlight/annotation deletion) may leave `conversation_media` stale
- Acceptable in v1

**Repair helper:**

```python
def recompute_conversation_media(conversation_id: UUID) -> None:
    """
    Idempotent recomputation of conversation_media from message_context.
    Safe to call anytime. Not exposed publicly in PR-02.
    """
```

Used for:
- Tests
- Admin / internal repair
- Future background jobs if needed

---

### Message Deletion Logic

`delete_message(db, viewer_id, message_id)` implementation:

```python
def delete_message(db: Session, viewer_id: UUID, message_id: UUID) -> None:
    # 1. Load message with conversation
    message = db.get(Message, message_id)
    if message is None:
        raise NotFoundError(E_MESSAGE_NOT_FOUND, "Message not found")

    conversation = message.conversation
    if conversation.owner_user_id != viewer_id:
        raise NotFoundError(E_MESSAGE_NOT_FOUND, "Message not found")  # masked

    # 2. Delete the message (cascades to message_context)
    db.delete(message)
    db.flush()  # ensure delete is applied

    # 3. Check remaining message count in same transaction
    remaining = db.scalar(
        select(func.count()).select_from(Message)
        .where(Message.conversation_id == conversation.id)
    )

    # 4. If no messages remain, delete conversation
    if remaining == 0:
        db.delete(conversation)

    db.commit()
```

---

## Pagination Standard

PR-02 establishes cursor pagination for all Slice 3+ list APIs.

### Cursor Specification

| Endpoint | Sort Order | Cursor Payload | Comparison |
|----------|------------|----------------|------------|
| `GET /conversations` | `(updated_at DESC, id DESC)` | `{"updated_at":"<iso>","id":"<uuid>"}` | `(updated_at, id) < cursor` |
| `GET /conversations/:id/messages` | `(seq ASC, id ASC)` | `{"seq":<int>,"id":"<uuid>"}` | `(seq, id) > cursor` |

### Rules

- Cursor is base64url-encoded JSON (no padding)
- Direction: forward-only (no backward pagination)
- Inclusivity: exclusive ("after cursor", not "at or after")
- Tie-breaking: secondary sort on `id` ensures determinism
- Cursor omitted → first page
- `page.next_cursor` is `null` when no more results

### Limit Handling

| Param | Default | Min | Max | Clamping |
|-------|---------|-----|-----|----------|
| `limit` | 50 | 1 | 100 | `limit = min(max(limit, 1), 100)` |

Clamping is done in service layer, matching existing pattern.

---

## Tests (Required)

### Integration Tests (HTTP Client)

**Conversation CRUD:**
- `POST /conversations` → 201, returns conversation with `sharing='private'`
- `GET /conversations` → 200, returns list with pagination
- `GET /conversations/:id` → 200 for owner, 404 for non-owner
- `DELETE /conversations/:id` → 204 for owner, 404 for non-owner

**Message listing:**
- `GET /conversations/:id/messages` → 200 for owner, 404 for non-owner
- Messages returned in `seq ASC` order

**Message deletion:**
- `DELETE /messages/:id` → 204 for owner, 404 for non-owner
- Deleting non-last message: conversation persists
- Deleting last message: conversation auto-deleted

**Cursor pagination (conversations):**
1. Create 3 conversations with controlled `updated_at` ordering (A oldest, C newest)
2. `GET /conversations?limit=2` → returns [C, B], cursor points to B
3. `GET /conversations?limit=2&cursor=<cursor>` → returns [A], `next_cursor=null`

**Cursor pagination (messages):**
1. Create conversation + insert 5 messages (seq 1..5) via direct DB insert (no send endpoint yet)
2. `GET /conversations/:id/messages?limit=2` → returns [seq=1, seq=2], cursor
3. `GET /conversations/:id/messages?limit=2&cursor=<cursor>` → returns [seq=3, seq=4], cursor
4. `GET /conversations/:id/messages?limit=2&cursor=<cursor>` → returns [seq=5], `next_cursor=null`

**Masked access:**
- User B fetches user A's conversation → 404 `E_CONVERSATION_NOT_FOUND`
- User B fetches user A's conversation messages → 404 `E_CONVERSATION_NOT_FOUND`
- User B deletes user A's message → 404 `E_MESSAGE_NOT_FOUND`

**Invalid cursor:**
- `GET /conversations?cursor=not-base64` → 400 `E_INVALID_CURSOR`
- `GET /conversations?cursor=<valid-base64-but-wrong-json>` → 400 `E_INVALID_CURSOR`

### Service Tests (Direct Calls)

**Sharing invariants:**
- `set_shares(conv, [lib1])` when `sharing='private'` → raises (or auto-transitions, define behavior)
- Create conversation with `sharing='library'` + 1 share → valid
- `delete_share(conv, lib1)` when it's the last share → `sharing` flips to `'private'`
- `set_shares(conv, [lib_user_not_member])` → raises

**Context insertion:**
- Insert context with `target_type='highlight'` + `highlight_id` → valid
- Insert context with mismatched `target_type` ↔ FK → raises
- Insert context → `conversation_media` upserted
- Insert second context for same media → no duplicate `conversation_media`

**Recompute helper:**
- `recompute_conversation_media(conv)` is idempotent
- After manual cascade (delete highlight), recompute removes stale `conversation_media`

### Non-Regression

- No change to Slice 0–2 endpoints
- Existing visibility tests continue to pass

---

## Non-Goals (Restated)

This PR does **not**:
- Send messages (no `POST /conversations/:id/messages`)
- Call LLMs
- Stream responses
- Expose sharing UI or routes
- Allow message edits
- Add search
- Mutate `conversation.sharing` via any route

Those are deliberately deferred.

---

## Exit Criteria

PR-02 is complete when:
- Conversations/messages are stable, owner-only, and boring
- All invariants are enforced in service layer
- Cursor pagination works with explicit encoding
- Deletion semantics are deterministic (last message → delete conversation)
- Error codes are specific (`E_CONVERSATION_NOT_FOUND`, `E_MESSAGE_NOT_FOUND`, `E_INVALID_CURSOR`)
- Later PRs can assume this layer is correct and immutable
