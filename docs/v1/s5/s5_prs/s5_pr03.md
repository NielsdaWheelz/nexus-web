# pr-03: s5 epub ingest + retry lifecycle

## goal
Align EPUB upload-confirm and retry orchestration to the S5 lifecycle contract with deterministic preflight validation, state transitions, and retry cleanup semantics.

## context
- PR-02 extraction executor is merged and intentionally does not mutate lifecycle fields (`python/nexus/tasks/ingest_epub.py:1`).
- Current EPUB upload-confirm route still returns S1 shape only (`python/nexus/api/routes/media.py:190`, `python/nexus/services/upload.py:230`, `python/nexus/schemas/media.py:89`).
- Current `ingest_epub` task executes extraction and returns structured payload but does not commit lifecycle completion transitions (`python/nexus/tasks/ingest_epub.py:27`).
- S5 L2 requires `/media/{id}/ingest` dispatch/status semantics and a dedicated `/media/{id}/retry` contract (`docs/v1/s5/s5_spec.md:373`, `docs/v1/s5/s5_spec.md:413`).
- S5 lifecycle guards and terminal retry policy are normative (`docs/v1/s5/s5_spec.md:295`, `docs/v1/s5/s5_spec.md:431`, `docs/v1/s5/s5_spec.md:646`).
- Route layer must remain transport-only and service-owned (`python/tests/test_route_structure.py:1`).

## dependencies
- PR-01 merged (S5 error primitives and schema constraints).
- PR-02 merged (EPUB extraction executor + asset contract).

---

## deliverables

### `python/nexus/services/epub_lifecycle.py`
- Add a dedicated EPUB lifecycle orchestration service module (PR-03 ownership C4).
- Define typed response contracts:
  - `EpubIngestConfirmOut`: `{media_id, duplicate, processing_status, ingest_enqueued}`
  - `EpubRetryOut`: `{media_id, processing_status, retry_enqueued}`
- Expose orchestration entrypoints:
  - `confirm_epub_ingest_for_viewer(db: Session, viewer_id: UUID, media_id: UUID, *, request_id: str | None = None) -> EpubIngestConfirmOut`
  - `retry_epub_ingest_for_viewer(db: Session, viewer_id: UUID, media_id: UUID, *, request_id: str | None = None) -> EpubRetryOut`

Required behavior for `confirm_epub_ingest_for_viewer`:
- Ownership/visibility:
  - media existence failures return `404 E_MEDIA_NOT_FOUND`.
  - only creator can confirm ingest; non-creator returns `403 E_FORBIDDEN`.
- Reuse existing upload-confirm primitives for file existence, streamed magic-byte/size validation, and dedupe winner/loser semantics.
- Preserve backward compatibility for duplicate clients:
  - always include `media_id` and `duplicate`.
  - `duplicate=true` must return winner id and `ingest_enqueued=false`.
  - `processing_status` in duplicate response is winner status snapshot.
- Ingest idempotency and re-entry control:
  - dispatch is allowed only when current row state is `pending`.
  - for non-duplicate rows already in `extracting|ready_for_reading|embedding|ready|failed`, do not dispatch.
  - return current `processing_status` snapshot with `ingest_enqueued=false` and no lifecycle mutation.
  - repeated `/ingest` calls must not increment `processing_attempts` once dispatch has already occurred.
- For non-duplicate EPUB media, perform synchronous preflight gate before dispatch:
  - ensure file/object present and byte-level validation already passed.
  - run shared EPUB archive-safety validator seam from `epub_ingest` (no duplicated policy logic).
  - on preflight safety failure, mark failed deterministically and return mapped error (`E_ARCHIVE_UNSAFE`); do not dispatch extraction.
- State transition and dispatch semantics (non-duplicate success path):
  - increment `processing_attempts`.
  - clear `failure_stage`, `last_error_code`, `last_error_message`, `failed_at`.
  - set `processing_status='extracting'` and `processing_started_at=now`.
  - dispatch `ingest_epub` task (queue `ingest`) for async execution mode.
  - if async dispatch fails, rollback lifecycle transition (do not leave media in `extracting`) and return deterministic server error.
  - return `processing_status` snapshot and `ingest_enqueued` (`true` for successful async dispatch; `false` for idempotent non-dispatch snapshots or explicit synchronous/internal execution mode).
- Kind handling:
  - non-EPUB kinds continue existing upload-confirm behavior without PR-03 EPUB-specific orchestration.

Required behavior for `retry_epub_ingest_for_viewer`:
- Visibility and auth:
  - canonical visibility masking for non-readable/missing media -> `404 E_MEDIA_NOT_FOUND`.
  - non-creator mutation attempts -> `403 E_FORBIDDEN`.
- Guard rails:
  - kind must be EPUB else `400 E_INVALID_KIND`.
  - media must be in `failed` else `409 E_RETRY_INVALID_STATE`.
  - `last_error_code='E_ARCHIVE_UNSAFE'` is terminal and returns `409 E_RETRY_NOT_ALLOWED`.
- Source integrity precondition (before cleanup/reset):
  - `media_file` row must exist and object must exist in storage.
  - source bytes must pass EPUB byte-level invariants used at confirm-ingest (magic/size validation).
  - when `media.file_sha256` is present, retry validation must preserve source identity expectations (no silent source swap); source hash mismatch is treated as retry source-missing/corrupt failure (`E_STORAGE_MISSING`).
  - precondition failure returns deterministic storage/type error (`E_STORAGE_MISSING|E_INVALID_FILE_TYPE|E_FILE_TOO_LARGE|E_STORAGE_ERROR`) and performs no cleanup, no lifecycle mutation, no dispatch.
- Retry reset semantics (single transaction):
  - delete extraction artifacts: `fragments`, `fragment_blocks`, `epub_toc_nodes`.
  - delete any existing chunk/embedding artifacts for this media when those stores exist; missing stores are tolerated as no-op.
  - increment `processing_attempts`.
  - clear failure fields (`failure_stage`, `last_error_code`, `last_error_message`, `failed_at`).
  - set `processing_status='extracting'`, `processing_started_at=now`.
  - do not mutate `media_file.storage_path` or `media.file_sha256` during retry flow.
- Dispatch semantics:
  - enqueue `ingest_epub` for async execution mode.
  - if async dispatch fails, rollback lifecycle transition and reset changes from retry pre-dispatch mutation.
  - return `{media_id, processing_status='extracting', retry_enqueued=true}` on success.

### `python/nexus/services/epub_ingest.py`
- Expose a shared archive-safety preflight seam consumed by both extraction executor and PR-03 ingest preflight path.
- Requirements:
  - no policy duplication between lifecycle preflight and extractor execution.
  - preserve existing S5 archive-safety thresholds and deterministic `E_ARCHIVE_UNSAFE` classification.
  - seam output must remain orchestration-friendly (typed failure with error code/message/terminal).

### `python/nexus/services/upload.py`
- Refactor upload-confirm function boundary so PR-03 lifecycle service can reuse stable file-validation/dedupe primitives without duplicating logic.
- Required outcomes:
  - expose reusable source-validation primitives for confirm-ingest and retry source-integrity preconditions.
  - maintain existing dedupe winner/loser behavior and storage cleanup semantics.
  - keep non-EPUB ingest behavior backward compatible.
  - keep MIME+magic-byte validation authoritative; do not add extension-based fallback classification.
  - remove direct lifecycle ownership for EPUB transitions from this module.

### `python/nexus/api/routes/media.py`
- Keep route layer transport-only.
- Update `POST /media/{media_id}/ingest` route to call exactly one PR-03 lifecycle service function.
- Add `POST /media/{media_id}/retry` route:
  - auth extraction via existing viewer dependency.
  - exactly one lifecycle service call.
  - returns `202` with JSON success envelope.
- Route must not perform raw SQL or lifecycle policy logic.

### `python/nexus/schemas/media.py`
- Extend ingest/retry response schemas:
  - `IngestResponse` must include:
    - `media_id: str`
    - `duplicate: bool`
    - `processing_status: str`
    - `ingest_enqueued: bool`
  - add `RetryResponse` with:
    - `media_id: str`
    - `processing_status: str`
    - `retry_enqueued: bool`
- Preserve compatibility contract: existing clients reading only `media_id` and `duplicate` remain valid.

### `python/nexus/celery.py`
- Ensure queue routing includes EPUB ingest task for deterministic worker dispatch:
  - add `ingest_epub` task route to `ingest` queue.

### `apps/worker/main.py`
- Ensure explicit task registration includes `ingest_epub` import so worker executes dispatched EPUB jobs.

### `python/nexus/tasks/ingest_epub.py`
- Make task-level completion transition handling explicit and authoritative for async extraction runs.
- Required behavior:
  - accept dispatch only for EPUB media rows currently in `extracting`; non-existent/deleted rows must no-op safely.
  - on successful extraction:
    - set `processing_status='ready_for_reading'`
    - set `processing_completed_at=now`
    - clear `failure_stage`, `last_error_code`, `last_error_message`, `failed_at`
  - on extraction error result:
    - set `processing_status='failed'`
    - set `failure_stage='extract'`
    - persist `last_error_code`, truncated/sanitized `last_error_message`, `failed_at=now`
  - preserve idempotent safety for async races:
    - if media was deleted or moved out of `extracting` before task finalization, do not force invalid transitions.
  - keep structured return payload for observability, but lifecycle state mutation is normative contract output.

### `python/tests/test_upload.py`
- Update ingest-confirm tests for S5 PR-03 response contract.
- Required tests:

**test: `test_ingest_epub_response_includes_dispatch_status_compat_fields`**
- input:
  - creator uploads valid EPUB bytes and calls `/media/{id}/ingest`.
- output:
  - response keys include `media_id`, `duplicate`, `processing_status`, `ingest_enqueued`.
  - `media_id` and `duplicate` semantics remain unchanged.

**test: `test_ingest_epub_duplicate_preserves_compat_and_sets_ingest_enqueued_false`**
- input:
  - second EPUB upload with duplicate bytes for same creator.
- output:
  - returns winner `media_id`, `duplicate=true`, `ingest_enqueued=false`, winner status snapshot.

**test: `test_ingest_epub_archive_unsafe_fails_preflight_without_dispatch`**
- input:
  - EPUB bytes that pass ZIP magic but fail archive safety limits.
- output:
  - API returns `400 E_ARCHIVE_UNSAFE`.
  - media row set to `failed` with `last_error_code='E_ARCHIVE_UNSAFE'`.
  - `ingest_epub.apply_async` not called.

**test: `test_ingest_epub_non_creator_forbidden`**
- input:
  - non-creator calls `/media/{id}/ingest`.
- output:
  - `403 E_FORBIDDEN`.

**test: `test_ingest_epub_repeat_call_is_idempotent_without_redispatch`**
- input:
  - creator calls `/media/{id}/ingest` twice for the same non-duplicate EPUB.
- output:
  - second call returns current snapshot with `ingest_enqueued=false`.
  - no second dispatch occurs and `processing_attempts` is not incremented by the second call.

**test: `test_ingest_epub_rejects_extension_only_spoofed_payload`**
- input:
  - upload initialized as EPUB (`.epub` filename/content type) but stored bytes fail EPUB magic-byte validation.
- output:
  - `400 E_INVALID_FILE_TYPE`.

**test: `test_ingest_epub_dispatch_failure_rolls_back_state`**
- input:
  - valid EPUB ingest path where task enqueue raises dispatch exception.
- output:
  - API returns deterministic server error.
  - media is not left in `extracting` due solely to dispatch failure.
  - no false-positive `ingest_enqueued=true` response.

### `python/tests/test_media.py`
- Add retry endpoint tests.

**test: `test_retry_epub_failed_resets_and_dispatches`**
- input:
  - creator-owned EPUB in `failed` with extraction artifacts present.
- output:
  - `202` with `processing_status='extracting'` and `retry_enqueued=true`.
  - artifacts cleared before re-extraction dispatch.
  - `processing_attempts` incremented and failure fields cleared.

**test: `test_retry_invalid_state_returns_409`**
- input:
  - EPUB not in `failed`.
- output:
  - `409 E_RETRY_INVALID_STATE`.

**test: `test_retry_terminal_archive_failure_blocked`**
- input:
  - EPUB in `failed` with `last_error_code='E_ARCHIVE_UNSAFE'`.
- output:
  - `409 E_RETRY_NOT_ALLOWED`.
  - no state mutation; no dispatch.

**test: `test_retry_kind_guard_and_auth`**
- input:
  - non-EPUB media and non-creator caller.
- output:
  - non-EPUB -> `400 E_INVALID_KIND`.
  - non-creator -> `403 E_FORBIDDEN`.

**test: `test_retry_visibility_masking`**
- input:
  - non-member caller requests retry.
- output:
  - `404 E_MEDIA_NOT_FOUND`.

**test: `test_retry_source_integrity_precondition_failure_no_mutation`**
- input:
  - failed EPUB retry where source object/file validation precondition fails.
- output:
  - deterministic storage/type error (`E_STORAGE_MISSING` baseline; equivalent typed validation/storage failures permitted).
  - no artifact cleanup, no lifecycle mutation, no dispatch.

**test: `test_retry_preserves_source_identity_fields`**
- input:
  - successful retry on failed EPUB with existing `media_file.storage_path` and `media.file_sha256`.
- output:
  - retry success semantics hold and both source identity fields remain unchanged.

**test: `test_retry_dispatch_failure_rolls_back_state`**
- input:
  - valid retry-eligible EPUB where task enqueue raises dispatch exception.
- output:
  - API returns deterministic server error.
  - retry pre-dispatch state mutations are rolled back (no stuck `extracting` transition from failed enqueue).

### `python/tests/test_route_structure.py`
- Keep green with new `/retry` route and ingest route changes; no test contract relaxation.

---

## decision ledger

| question | decision | rationale | fallback/default |
|---|---|---|---|
| Should `/media/{id}/ingest` run full EPUB extraction synchronously or dispatch asynchronously? | Keep extraction async via `ingest_epub`; use synchronous preflight gate only for deterministic validation failures. | Balances scalable request latency with strict API error determinism (`E_ARCHIVE_UNSAFE`, type/size/storage errors). | In test/internal sync mode, allow non-enqueued path but preserve identical response/error contracts. |
| Where should PR-03 lifecycle orchestration live? | Introduce dedicated `epub_lifecycle` service module; routes call it directly. | Separates C4 lifecycle policy from S1 upload primitives and C3 extraction internals; improves long-term maintainability. | If temporary wiring requires reuse inside `upload.py`, keep lifecycle functions isolated and migrate in the same PR before closure. |
| How should archive-safety preflight avoid drift from extractor behavior? | Use one shared validator seam in `epub_ingest`; both preflight and extractor consume it. | Eliminates policy drift and conflicting `E_ARCHIVE_UNSAFE` behavior across paths. | If seam extraction is blocked, PR-03 must not duplicate thresholds; update PR-02 seam first. |
| Who owns async completion transitions after `processing_status='extracting'` is set and `ingest_epub` is dispatched? | `ingest_epub` task is the authoritative completion-state owner for async EPUB runs (`extracting -> ready_for_reading|failed`) while service routes own entry transitions and dispatch. | Prevents split-brain lifecycle mutation across API and worker paths; keeps async state machine deterministic and auditable. | If sync/internal execution path is used, it must invoke the same completion-state mapping helper used by task code. |
| How should enqueue failures be handled after pre-dispatch lifecycle mutation? | Treat enqueue failure as transactional failure: rollback/undo pre-dispatch lifecycle mutation and return deterministic server error; never report successful enqueue when dispatch failed. | Prevents stuck `extracting` rows and false-positive accepted jobs, preserving operational correctness and observability integrity. | `ingest_enqueued=false` is valid for idempotent non-dispatch snapshots or explicit sync/internal execution mode, not queue outage/error paths. |
| How should retry handle terminal archive failures? | `last_error_code='E_ARCHIVE_UNSAFE'` is terminal and returns `409 E_RETRY_NOT_ALLOWED`. | Aligns with S5 terminal failure model and prevents unimplementable in-row remediation semantics. | Remediation remains fresh upload to new media row. |
| How should retry cleanup handle optional chunk/embedding stores across deployments? | Cleanup is strict-by-contract and idempotent-by-implementation: clear known extraction artifacts and attempt chunk/embedding cleanup with no-op tolerance when stores are absent. | Preserves invariant 6.10 while keeping implementations deploy-safe across environments lacking embedding tables. | If chunk stores are introduced later, retry cleanup helper must be extended without changing endpoint contract. |
| Should ingest compatibility tests keep strict key-equality `{media_id, duplicate}` in PR-03? | No. Replace with compatibility assertions that `media_id` and `duplicate` semantics remain stable while allowing new fields. | PR-03 contract legitimately extends response shape; strict-key assertion would become invalid and block required behavior. | Keep one explicit backward-compat test that parses only legacy keys and succeeds. |
| How should retry behave if the original EPUB source is missing/corrupt before reset? | Enforce source-integrity precondition before cleanup: missing/invalid source fails fast with deterministic error and zero mutation. | Prevents destructive cleanup followed by guaranteed re-extraction failure; preserves recoverability and operational correctness. | Retry precondition failures require caller remediation (restore source or fresh upload) before retry can proceed. |
| How should repeated `/media/{id}/ingest` calls behave after initial dispatch/state advance? | Treat as idempotent lifecycle snapshot reads: no redispatch, no attempt increment, `ingest_enqueued=false` unless dispatch is actually executed. | Prevents duplicate work and illegal state transitions under client retries/races. | For failed media, remediation path remains `/media/{id}/retry` (subject to terminal guards). |
| Should EPUB kind detection ever rely on filename extension fallback? | No. MIME+magic-byte validation remains authoritative; extension is non-authoritative metadata only. | Reduces spoofing risk and keeps file-type trust rooted in bytes, not names. | Any extension-only mismatch continues to fail as `E_INVALID_FILE_TYPE`. |

---

## traceability matrix

| l3 acceptance item | deliverable(s) | test(s) |
|---|---|---|
| Upload-init/ingest EPUB behavior conforms to S5 request/response/error contracts without breaking existing duplicate-client compatibility. | `python/nexus/services/epub_lifecycle.py`, `python/nexus/services/upload.py`, `python/nexus/api/routes/media.py`, `python/nexus/schemas/media.py` | `test_ingest_epub_response_includes_dispatch_status_compat_fields`, `test_ingest_epub_duplicate_preserves_compat_and_sets_ingest_enqueued_false`, `test_ingest_epub_rejects_extension_only_spoofed_payload`, `test_ingest_epub_dispatch_failure_rolls_back_state` |
| `POST /media/{media_id}/ingest` exposes EPUB-ready dispatch/status semantics while preserving existing duplicate behavior compatibility. | `python/nexus/services/epub_lifecycle.py`, `python/nexus/api/routes/media.py`, `python/nexus/schemas/media.py`, `python/nexus/celery.py`, `apps/worker/main.py` | `test_ingest_epub_response_includes_dispatch_status_compat_fields`, `test_ingest_epub_duplicate_preserves_compat_and_sets_ingest_enqueued_false`, `test_ingest_epub_archive_unsafe_fails_preflight_without_dispatch`, `test_ingest_epub_repeat_call_is_idempotent_without_redispatch`, `test_ingest_epub_dispatch_failure_rolls_back_state` |
| Repeat `POST /media/{media_id}/ingest` on non-duplicate media is idempotent after dispatch/state advance (no redispatch, no attempt inflation). | `python/nexus/services/epub_lifecycle.py`, `python/nexus/api/routes/media.py`, `python/nexus/schemas/media.py` | `test_ingest_epub_repeat_call_is_idempotent_without_redispatch` |
| Processing transitions (`pending -> extracting -> ready_for_reading`, embedding paths, and failure transitions) follow S5 contract. | `python/nexus/services/epub_lifecycle.py`, `python/nexus/tasks/ingest_epub.py` | `test_ingest_epub_archive_unsafe_fails_preflight_without_dispatch`, `test_ingest_epub_repeat_call_is_idempotent_without_redispatch`, `test_ingest_epub_task_marks_ready_for_reading_on_success`, `test_ingest_epub_task_marks_failed_on_extraction_error`, `test_ingest_epub_task_idempotent_on_missing_or_nonextracting_media`, `test_retry_epub_failed_resets_and_dispatches` |
| `POST /media/{media_id}/retry` enforces legal-state preconditions and full artifact cleanup before re-extraction. | `python/nexus/services/epub_lifecycle.py`, `python/nexus/api/routes/media.py`, `python/nexus/schemas/media.py` | `test_retry_epub_failed_resets_and_dispatches`, `test_retry_invalid_state_returns_409`, `test_retry_kind_guard_and_auth`, `test_retry_visibility_masking`, `test_retry_source_integrity_precondition_failure_no_mutation`, `test_retry_preserves_source_identity_fields`, `test_retry_dispatch_failure_rolls_back_state` |
| Retry enforces source-integrity preconditions before cleanup/reset; precondition failures are deterministic and non-mutating. | `python/nexus/services/epub_lifecycle.py`, `python/nexus/services/upload.py`, `python/nexus/api/routes/media.py` | `test_retry_source_integrity_precondition_failure_no_mutation`, `test_retry_preserves_source_identity_fields` |
| Retry for terminal archive failures is rejected with `409 E_RETRY_NOT_ALLOWED`. | `python/nexus/services/epub_lifecycle.py`, `python/nexus/api/routes/media.py` | `test_retry_terminal_archive_failure_blocked` |

---

## acceptance tests

### file: `python/tests/test_upload.py`

**test: `test_ingest_epub_response_includes_dispatch_status_compat_fields`**
- input: creator uploads valid EPUB and calls `POST /media/{id}/ingest`.
- output: response includes `media_id`, `duplicate`, `processing_status`, `ingest_enqueued`; legacy fields remain semantically correct.

**test: `test_ingest_epub_duplicate_preserves_compat_and_sets_ingest_enqueued_false`**
- input: duplicate EPUB upload by same creator.
- output: winner `media_id`, `duplicate=true`, `ingest_enqueued=false`, and winner status snapshot.

**test: `test_ingest_epub_archive_unsafe_fails_preflight_without_dispatch`**
- input: archive-unsafe EPUB bytes.
- output: `400 E_ARCHIVE_UNSAFE`, media marked failed, no task dispatch.

**test: `test_ingest_epub_non_creator_forbidden`**
- input: non-creator calls ingest.
- output: `403 E_FORBIDDEN`.

**test: `test_ingest_epub_repeat_call_is_idempotent_without_redispatch`**
- input: creator calls `POST /media/{id}/ingest` twice for the same non-duplicate EPUB.
- output: second call returns current status with `ingest_enqueued=false`; no second dispatch and no additional `processing_attempts` increment.

**test: `test_ingest_epub_rejects_extension_only_spoofed_payload`**
- input: request uses `.epub` filename/content type but uploaded bytes fail EPUB magic-byte validation.
- output: `400 E_INVALID_FILE_TYPE`.

**test: `test_ingest_epub_dispatch_failure_rolls_back_state`**
- input: valid EPUB ingest path where task enqueue raises dispatch exception.
- output: deterministic server error, and media is not left in `extracting`.

### file: `python/tests/test_ingest_epub.py`

**test: `test_ingest_epub_task_marks_ready_for_reading_on_success`**
- input: media in `extracting` with valid extracted artifact path and successful extractor outcome.
- output: media transitions to `ready_for_reading`, `processing_completed_at` set, and failure fields cleared.

**test: `test_ingest_epub_task_marks_failed_on_extraction_error`**
- input: media in `extracting` and extractor returns structured failure.
- output: media transitions to `failed`, `failure_stage='extract'`, `last_error_code/message` persisted, `failed_at` set.

**test: `test_ingest_epub_task_idempotent_on_missing_or_nonextracting_media`**
- input: task invoked for deleted media or media no longer in `extracting`.
- output: task exits without forcing invalid lifecycle transitions.

### file: `python/tests/test_media.py`

**test: `test_retry_epub_failed_resets_and_dispatches`**
- input: failed EPUB with extraction artifacts.
- output: `202` with retry envelope; artifacts removed; attempts incremented; failure fields cleared; dispatch attempted.

**test: `test_retry_invalid_state_returns_409`**
- input: retry call when media not in failed.
- output: `409 E_RETRY_INVALID_STATE`.

**test: `test_retry_terminal_archive_failure_blocked`**
- input: failed EPUB with `last_error_code='E_ARCHIVE_UNSAFE'`.
- output: `409 E_RETRY_NOT_ALLOWED`; no state mutation.

**test: `test_retry_kind_guard_and_auth`**
- input: non-EPUB retry and non-creator retry.
- output: `400 E_INVALID_KIND` and `403 E_FORBIDDEN` respectively.

**test: `test_retry_visibility_masking`**
- input: unreadable media retry request.
- output: `404 E_MEDIA_NOT_FOUND`.

**test: `test_retry_source_integrity_precondition_failure_no_mutation`**
- input: failed EPUB retry with missing/corrupt source object before reset.
- output: deterministic storage/type error (`E_STORAGE_MISSING` baseline) and no cleanup/state mutation/dispatch.

**test: `test_retry_preserves_source_identity_fields`**
- input: successful retry for failed EPUB with pre-existing `media_file.storage_path` and `media.file_sha256`.
- output: retry success envelope with source identity fields unchanged.

**test: `test_retry_dispatch_failure_rolls_back_state`**
- input: valid retry-eligible EPUB where task enqueue raises dispatch exception.
- output: deterministic server error, and retry pre-dispatch lifecycle mutations are rolled back.

---

## non-goals
- Does not redefine EPUB extraction artifact semantics or parser/resource/title contracts (owned by PR-02).
- Does not add chapter/TOC read APIs or BFF parity work (owned by PR-04).
- Does not modify reader UX adoption, highlight behavior, or quote-to-chat behavior (owned by PR-05/PR-06).

---

## constraints
- Only touch files listed in deliverables unless this spec is revised.
- Keep route handlers transport-only and compliant with `python/tests/test_route_structure.py`.
- No contract changes outside PR-03 ownership cluster C4.
- Reuse shared archive-safety validator seam; no duplicated safety threshold logic.
- Keep file-kind trust byte-driven (MIME+magic), not extension-driven.
- Preserve duplicate compatibility semantics for clients using only `media_id` and `duplicate`.

---

## boundaries (for ai implementers)

**do**:
- implement lifecycle orchestration in service layer with explicit state and error contracts.
- keep preflight deterministic and extraction dispatch asynchronous by default.
- enforce retry guards and cleanup semantics exactly as specified.
- add/adjust tests for every behavior-changing decision.

**do not**:
- re-implement or change PR-02 extraction output contracts.
- add chapter/toc routes or frontend reader behavior.
- move domain logic into routes or bypass service boundaries.
- introduce v2 URL-ingest behavior.

---

## open questions + temporary defaults

| question | temporary default behavior | owner | due |
|---|---|---|---|
| none | n/a | n/a | n/a |

---

## checklist
- [ ] every l3 acceptance bullet is in traceability matrix
- [ ] every traceability row has at least one test
- [ ] every behavior-changing decision has assertions
- [ ] only scoped files are touched
- [ ] non-goals are explicit and enforced
