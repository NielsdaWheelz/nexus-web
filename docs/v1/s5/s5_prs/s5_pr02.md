# pr-02: s5 epub extraction artifacts

## goal
Implement deterministic EPUB extraction artifact materialization (chapters, fragment blocks, TOC snapshot, title/resource rules, archive safety) as a reusable domain executor with no endpoint orchestration changes.

## context
- PR-01 foundations are merged: `epub_toc_nodes` schema and S5 error primitives (`python/nexus/db/models.py`, `python/nexus/errors.py`).
- Current upload-confirm path validates hash/dedupe only and does not run EPUB extraction (`python/nexus/services/upload.py:230`).
- Existing ingestion task pattern for web articles provides the architectural baseline for sync + async execution seams (`python/nexus/tasks/ingest_web_article.py:38`, `python/nexus/tasks/ingest_web_article.py:360`).
- Existing reusable text pipeline primitives already exist for sanitization, canonicalization, and fragment-block generation (`python/nexus/services/sanitize_html.py:86`, `python/nexus/services/canonicalize.py:69`, `python/nexus/services/fragment_blocks.py:45`).
- PR-02 ownership is C3 only (`docs/v1/s5/s5_roadmap_ownership.md`): extraction artifact materialization; PR-03 owns lifecycle orchestration and retry endpoint behavior.

## dependencies
- PR-01 merged.

---

## deliverables

### `python/nexus/services/epub_ingest.py`
- Add a new EPUB extraction domain service module with no route bindings.
- Define typed contracts:
  - `EpubExtractionResult` (`status='success'`, artifact counts/metadata snapshot)
  - `EpubExtractionError` (`status='failed'`, `error_code`, `error_message`, terminal flag)
  - internal `EpubChapterSpec`, `EpubTocNodeSpec`, `EpubArchiveSafetyConfig` dataclasses.
- Expose one orchestrator-safe entrypoint:
  - `extract_epub_artifacts(db: Session, media_id: UUID, storage_client: StorageClientBase, *, now: datetime | None = None) -> EpubExtractionResult | EpubExtractionError`
- Implement deterministic extraction behavior:
  - read EPUB bytes from `media_file.storage_path` via storage client stream
  - enforce archive safety contract before parsing content
  - parse OPF/package + spine + nav/NCX using internal Python parser (`zipfile` + `lxml`) with no external EPUB framework dependency
  - materialize fragments in spine order from readable items only
  - generate fragment blocks from immutable `canonical_text` for each fragment
  - materialize deterministic TOC snapshot into `epub_toc_nodes`
  - compute/persist resolved title via deterministic fallback order
- Enforce PR-02 persistence invariants:
  - single transaction for the full artifact write set (`fragments`, `fragment_blocks`, `epub_toc_nodes`, title update)
  - no partial artifact commits on failed extraction
  - no media lifecycle transition ownership in this module (status choreography remains PR-03)
- Deterministic chapter extraction rules:
  - chapter ordering source is spine order only
  - one fragment per readable spine item where sanitized output yields non-empty `canonical_text.trim()`
  - persisted `fragments.idx` must be contiguous `0..N-1`
  - chapter extraction failure when resulting readable chapter count is zero
- Deterministic TOC materialization rules:
  - persist zero rows when TOC source is absent/unusable (non-fatal)
  - deterministic `order_key` generation and ASCII lexicographic ordering semantics per L2
  - deterministic `node_id` generation:
    - token source priority: normalized source nav id -> normalized href (path+fragment) -> normalized label slug
    - enforce sibling uniqueness with deterministic `~{ordinal}` suffix
    - compose hierarchical ids as path (`parent/child`)
    - enforce 255-char bound with deterministic hash-tail shortening when needed
  - map TOC anchors to chapter `fragment_idx` when resolvable; otherwise `fragment_idx=null`
- Resource rewrite + degradation behavior:
  - persist resolvable EPUB-internal assets to deterministic storage keys under media-owned namespace
  - derive `asset_key` from normalized EPUB-internal path with fragment stripped; identical normalized paths must map to the same rewritten asset URL
  - if normalization produces key collisions, apply deterministic disambiguation (stable suffix/hash strategy) and persist the resolved mapping
  - rewrite EPUB-internal `href/src` to canonical safe fetch paths: `/media/{media_id}/assets/{asset_key}` (no direct private storage URLs)
  - rewrite external image sources to existing image-proxy route
  - unresolved EPUB-internal assets degrade non-fatally (links inert/non-resolving, media omitted/placeholder)
  - sanitization removes active content and unsafe protocols/attributes
- Archive safety behavior:
  - path normalization rejection: absolute paths, traversal segments, drive-qualified paths
  - limits:
    - `max_entries = 10000`
    - `max_total_uncompressed_bytes = 536870912`
    - `max_single_entry_uncompressed_bytes = 67108864`
    - `max_compression_ratio = 100`
    - `max_parse_time_ms = 30000`
  - violations return `E_ARCHIVE_UNSAFE` classification
  - read safety limits from `get_settings()` archive config keys; do not hardcode limits in extractor
- Title fallback behavior:
  - first valid: `dc:title` -> `title` -> filename sans extension -> literal `Untitled EPUB`
  - normalization: trim, collapse whitespace, reject empty, truncate to 255 chars

Error classification contract (executor output):

| failure class | error code |
|---|---|
| Archive safety violation (path/size/ratio/time limits) | `E_ARCHIVE_UNSAFE` |
| Sanitization/canonicalization failure | `E_SANITIZATION_FAILED` |
| Structural parse/extraction failure (opf/spine/nav mapping, zero-readable-chapter, parser runtime errors) | `E_INGEST_FAILED` |

### `python/nexus/config.py`
- Add explicit EPUB archive-safety configuration keys with L2 defaults:
  - `MAX_EPUB_ARCHIVE_ENTRIES=10000`
  - `MAX_EPUB_ARCHIVE_TOTAL_UNCOMPRESSED_BYTES=536870912`
  - `MAX_EPUB_ARCHIVE_SINGLE_ENTRY_UNCOMPRESSED_BYTES=67108864`
  - `MAX_EPUB_ARCHIVE_COMPRESSION_RATIO=100`
  - `MAX_EPUB_ARCHIVE_PARSE_TIME_MS=30000`
- Enforce minimum-floor validation: runtime values may be stricter but may not be weaker than L2 baseline.
- Surface typed accessors used by `python/nexus/services/epub_ingest.py` so safety policy is centralized and testable.

### `python/nexus/services/media.py`
- Add media-domain asset fetch service:
  - `get_epub_asset_for_viewer(db: Session, viewer_id: UUID, media_id: UUID, asset_key: str) -> EpubAssetOut`
- Required behavior:
  - enforce canonical visibility predicate (`404 E_MEDIA_NOT_FOUND` masking)
  - enforce `kind='epub'` guard (`400 E_INVALID_KIND`)
  - enforce ready-state guard (`409 E_MEDIA_NOT_READY`)
  - validate `asset_key` canonical format (`400 E_INVALID_REQUEST`)
  - resolve deterministic media-owned asset storage key and stream bytes without exposing raw private storage URLs
  - return `404 E_MEDIA_NOT_FOUND` for missing/unmapped asset keys (masked behavior)

### `python/nexus/api/routes/media.py`
- Add binary route: `GET /media/{media_id}/assets/{asset_key:path}`.
- Route remains transport-only:
  - extract viewer
  - call exactly one service function (`get_epub_asset_for_viewer`)
  - return binary `Response` with resolved content type and cache headers
  - no raw SQL/domain logic in route

### `python/nexus/tasks/ingest_epub.py`
- Add task/execution wrapper for EPUB extraction domain executor (parallel to web-article task structure).
- Required surfaces:
  - celery task `ingest_epub` with `max_retries=0`
  - sync helper `run_epub_ingest_sync` for deterministic tests
- PR-02 task scope is extraction execution only:
  - call `extract_epub_artifacts(...)`
  - return structured extraction outcome payload for PR-03 orchestration consumption
  - do not own request/response envelope semantics for `/media/{id}/ingest` or `/retry`
- do not mutate `processing_status`, retry policy fields, or endpoint-facing lifecycle semantics (owned by PR-03)

### `python/nexus/tasks/__init__.py`
- Register `ingest_epub` task import/export for worker discovery.

### `python/tests/test_epub_ingest.py`
- Add deterministic extraction integration tests for PR-02 artifact contracts.
- Build fixture EPUBs in-memory within tests (zip payload builders) to avoid external network/process dependencies.
- Required fixture coverage includes both EPUB2 NCX and EPUB3 nav TOC variants.
- Required tests:

**test: `test_epub_extract_materializes_contiguous_spine_fragments_and_blocks`**
- input:
  - valid EPUB fixture with multiple spine documents, one non-readable item
  - invoke `run_epub_ingest_sync`
- output:
  - fragments persisted with contiguous `idx` starting at 0 in spine order
  - each persisted fragment has non-empty `html_sanitized` and `canonical_text`
  - `fragment_blocks` exist for each fragment and cover canonical text per existing block invariants

**test: `test_epub_extract_persists_deterministic_toc_snapshot`**
- input:
  - EPUB2 NCX fixture and EPUB3 nav fixture with nested TOC and multiple nodes targeting same chapter
  - invoke extraction twice on equivalent bytes/media rows
- output:
  - persisted `epub_toc_nodes` tree ordering deterministic by `order_key`
  - `node_id` generation deterministic and stable per-media parse path rules
  - mapped `fragment_idx` values deterministic

**test: `test_epub_extract_missing_toc_is_non_fatal`**
- input:
  - EPUB fixture with readable spine content and no usable TOC nav/NCX
- output:
  - extraction succeeds
  - zero `epub_toc_nodes` rows persisted
  - fragments and fragment blocks still materialize correctly

**test: `test_epub_extract_title_fallback_filename_then_literal`**
- input:
  - case A: missing/empty OPF title with valid filename
  - case B: missing/empty OPF title and unusable filename
- output:
  - case A persisted title = filename without extension (normalized)
  - case B persisted title = `Untitled EPUB`
  - both truncated/normalized per contract

**test: `test_epub_extract_rewrites_resources_and_degrades_unresolved_assets`**
- input:
  - EPUB fixture with relative internal image/link refs, unresolved internal refs, external image ref
- output:
  - resolved internal refs rewritten to safe server-controlled paths
  - internal refs differing only by URL fragment rewrite to the same canonical asset URL
  - normalization collision cases disambiguate deterministically with stable rewritten URLs
  - unresolved refs degrade safely without extraction failure
  - external image rewritten through image proxy
  - active content removed from persisted `html_sanitized`

**test: `test_epub_extract_rejects_unsafe_archive_with_terminal_code`**
- input:
  - archive fixtures for traversal path and ratio/size threshold breach
- output:
  - extraction fails deterministically with `E_ARCHIVE_UNSAFE`
  - no fragments, fragment_blocks, or toc rows persisted for failed media

**test: `test_epub_extract_failure_classification_matrix`**
- input:
  - fixture A: sanitization/canonicalization failure seam
  - fixture B: structural parse/extraction failure seam
- output:
  - fixture A classified as `E_SANITIZATION_FAILED`
  - fixture B classified as `E_INGEST_FAILED`

**test: `test_epub_extract_commits_artifacts_atomically`**
- input:
  - force deterministic failure after partial in-memory chapter processing but before commit (test seam)
- output:
  - database shows no partial writes to `fragments`, `fragment_blocks`, `epub_toc_nodes`

### `python/tests/test_upload.py`
- Add one explicit regression assertion in existing ingest-confirm tests that response keys remain exactly `{media_id, duplicate}` for upload-confirm path in PR-02.
- Do not add assertions for PR-03 fields (`processing_status`, `ingest_enqueued`) in this PR.

### `python/tests/test_media.py`
- Add endpoint tests for `GET /media/{media_id}/assets/{asset_key}`:
  - success path returns binary payload + content type for readable EPUB media
  - unauthorized and missing/unmapped assets are masked as `404 E_MEDIA_NOT_FOUND`
  - non-EPUB media returns `400 E_INVALID_KIND`
  - non-ready EPUB media returns `409 E_MEDIA_NOT_READY`

### `python/tests/test_config.py`
- Add config tests for archive-safety settings:
  - default values match L2 baseline
  - stricter overrides are accepted
  - weaker-than-baseline overrides fail settings validation with deterministic error messages

---

## decision ledger

| question | decision | rationale | fallback/default |
|---|---|---|---|
| Should PR-02 implement EPUB extraction in Python service code or introduce a Node EPUB subprocess pipeline? | Implement a Python-native extraction domain service in `python/nexus/services/epub_ingest.py`; do not introduce Node subprocess extraction for EPUB. | Single-runtime backend control improves operational reliability, deterministic parsing/security behavior, and testability under existing Python CI/tooling. | If a parser limitation blocks one metadata field, keep pipeline Python-native and add scoped fallback parser adapter within Python service boundaries only. |
| Where is the boundary between PR-02 extraction and PR-03 lifecycle orchestration? | PR-02 owns artifact executor + extraction-local failure classification; PR-03 owns `/ingest`/`/retry` endpoint semantics and state-machine orchestration policy. | Preserves roadmap ownership (C3 vs C4), prevents scope smuggling, and keeps lifecycle policy changes reviewable in the correct PR. | If an orchestration hook is required for compile/runtime wiring, expose neutral executor return types and defer policy mapping to PR-03. |
| How should TOC `node_id` be generated to remain deterministic across parser variance? | Use deterministic parse-path identity (`nav-id -> href -> label slug`, sibling disambiguation suffix, hierarchical path composition, deterministic hash-tail for length cap). | Prevents parser/source-id instability from breaking identity determinism while preserving stable per-media node references. | If a source id is always stable in a fixture, still run full canonicalization pipeline to avoid dual behavior modes. |
| Should PR-02 commit partial extraction artifacts on progressive success or enforce all-or-nothing artifact writes? | Enforce atomic artifact persistence in one transaction; failures leave no partial artifact generation. | Eliminates mixed-generation states and simplifies downstream retry/read guarantees. | If future scaling needs staged writes, keep external contract atomic via generation versioning; not allowed in S5 PR-02. |
| Are TOC absence/unresolved resource references extraction-fatal? | No. Missing TOC and unresolved internal assets are non-fatal when readable chapter text extraction succeeds. | Matches L2 resilience rules; preserves core reading/highlighting while avoiding unnecessary ingestion failures on real-world EPUB defects. | Persist empty TOC and degraded sanitized chapter HTML with deterministic behavior; never bypass sanitization. |
| Should archive safety checks be best-effort or hard gate before extraction materialization? | Hard gate with deterministic `E_ARCHIVE_UNSAFE` classification prior to artifact commit. | Security baseline requires strict zip-safety enforcement and explicit terminal failure signaling. | Operators may tighten limits via config; they may not relax below L2 baseline defaults. |
| Where should archive safety defaults live and how are policy overrides constrained? | Define archive safety limits in `Settings` with L2 defaults and enforce minimum floors at config validation time. | Centralized policy prevents magic numbers, keeps operations tunable, and guarantees security floors are never weakened by environment drift. | If a new deploy requires temporary override, allow only stricter values until L2 contract is revised. |
| Should PR-02 depend on an external EPUB parsing framework or implement a controlled internal parser? | Use an internal parser built on `zipfile` + `lxml` for OPF/spine/nav/NCX extraction; do not add external EPUB parser dependencies in PR-02. | Minimizes dependency drift/supply-chain risk, keeps parsing semantics explicit, and improves deterministic debugging under CI and production incident response. | If a critical EPUB variant cannot be supported by internal parser in PR-02, add a narrowly-scoped adapter behind the same deterministic contract with explicit fixture coverage. |
| Should PR-02 define and implement the canonical EPUB-internal asset fetch endpoint contract? | Yes. Implement `/media/{media_id}/assets/{asset_key}` with visibility masking and no private-storage URL exposure; derive `asset_key` from normalized internal path (fragment stripped) with deterministic collision handling. | Resource rewrite contract is incomplete without deterministic retrieval path semantics; this closes a cross-PR ownership gap and prevents incompatible fetch implementations. | If endpoint wiring must be deferred for blocker reasons, extraction must still rewrite to the same canonical path contract and PR-02 cannot ship as complete. |
| How should non-archive extraction failures be classified for deterministic downstream orchestration? | Use explicit matrix: sanitization/canonicalization failures -> `E_SANITIZATION_FAILED`; structural parse/extraction failures -> `E_INGEST_FAILED`. | Keeps executor outputs deterministic and prevents PR-03 from inventing ad-hoc mappings while consuming PR-02 results. | Unexpected failures default to `E_INGEST_FAILED` after safe message truncation/redaction. |

---

## traceability matrix

| l3 acceptance item | deliverable(s) | test(s) |
|---|---|---|
| EPUB extraction materializes contiguous chapter fragments in spine order and generates fragment blocks from immutable canonical text. | `python/nexus/services/epub_ingest.py`, `python/nexus/tasks/ingest_epub.py` | `test_epub_extract_materializes_contiguous_spine_fragments_and_blocks` |
| TOC snapshot persistence is deterministic and supports stable chapter linkage semantics. | `python/nexus/services/epub_ingest.py` | `test_epub_extract_persists_deterministic_toc_snapshot`, `test_epub_extract_missing_toc_is_non_fatal` |
| Title resolution follows deterministic fallback order. | `python/nexus/services/epub_ingest.py` | `test_epub_extract_title_fallback_filename_then_literal` |
| Resource rewriting follows safe resolution rules; resolved internal assets are served through canonical safe fetch path; unresolved assets degrade without blocking readable output. | `python/nexus/services/epub_ingest.py`, `python/nexus/services/media.py`, `python/nexus/api/routes/media.py` | `test_epub_extract_rewrites_resources_and_degrades_unresolved_assets`, `test_get_epub_asset_success_and_masking` |
| Archive safety controls are enforced and unsafe archives fail deterministically with `E_ARCHIVE_UNSAFE`. | `python/nexus/services/epub_ingest.py`, `python/nexus/tasks/ingest_epub.py`, `python/nexus/config.py` | `test_epub_extract_rejects_unsafe_archive_with_terminal_code`, `test_epub_extract_failure_classification_matrix`, `test_epub_extract_commits_artifacts_atomically`, `test_epub_archive_safety_config_defaults_and_floor_validation` |

---

## acceptance tests

### file: `python/tests/test_epub_ingest.py`

**test: `test_epub_extract_materializes_contiguous_spine_fragments_and_blocks`**
- input: invoke sync EPUB extraction on fixture with mixed readable/non-readable spine items.
- output: persisted fragments are contiguous `idx ASC`, non-empty canonical/sanitized content, and fragment blocks exist per fragment.

**test: `test_epub_extract_persists_deterministic_toc_snapshot`**
- input: extract equivalent EPUB bytes into separate media rows.
- output: `epub_toc_nodes` ordering and identity mapping (`order_key`, `node_id`, `fragment_idx`) are deterministic across runs.

**test: `test_epub_extract_missing_toc_is_non_fatal`**
- input: EPUB fixture with valid readable spine and no parsable TOC.
- output: extraction succeeds with zero `epub_toc_nodes` rows.

**test: `test_epub_extract_title_fallback_filename_then_literal`**
- input: fixtures covering missing OPF title with usable and unusable filenames.
- output: persisted title follows deterministic fallback and normalization/truncation rules.

**test: `test_epub_extract_rewrites_resources_and_degrades_unresolved_assets`**
- input: fixture chapter HTML containing resolvable and unresolvable internal refs plus external image refs.
- output: refs rewritten per safety rules, unresolved refs degrade safely, sanitization strips active content.

**test: `test_epub_extract_rejects_unsafe_archive_with_terminal_code`**
- input: unsafe archive fixtures violating traversal/size/compression limits.
- output: extraction returns `E_ARCHIVE_UNSAFE` and writes no artifacts.

**test: `test_epub_extract_failure_classification_matrix`**
- input: deterministic sanitizer failure seam and deterministic structural-parse failure seam.
- output: failures are classified as `E_SANITIZATION_FAILED` and `E_INGEST_FAILED` respectively.

**test: `test_epub_extract_commits_artifacts_atomically`**
- input: inject deterministic pre-commit failure seam during extraction.
- output: no partial artifacts persisted in extraction tables.

### file: `python/tests/test_upload.py`

**test: `test_ingest_response_shape_remains_duplicate_compat_only`**
- input: existing upload/confirm path for EPUB fixture.
- output: response data keys are exactly `media_id` and `duplicate`; no PR-03 response fields are present.

### file: `python/tests/test_media.py`

**test: `test_get_epub_asset_success_and_masking`**
- input: readable EPUB media with one resolved asset and one missing/unmapped asset; calls from authorized and unauthorized viewers.
- output: resolved asset returns binary payload with correct content type; unauthorized and missing/unmapped asset requests return `404 E_MEDIA_NOT_FOUND`.

**test: `test_get_epub_asset_kind_and_ready_guards`**
- input: non-EPUB media and non-ready EPUB media requests.
- output: non-EPUB returns `400 E_INVALID_KIND`; non-ready EPUB returns `409 E_MEDIA_NOT_READY`.

### file: `python/tests/test_config.py`

**test: `test_epub_archive_safety_config_defaults_and_floor_validation`**
- input: load settings with defaults, strict overrides, and weaker-than-baseline overrides.
- output: defaults/strict overrides accepted; weaker overrides rejected by settings validator.

---

## non-goals
- Does not change `/media/{media_id}/ingest` response contract semantics (PR-03).
- Does not implement `POST /media/{media_id}/retry` endpoint behavior (PR-03).
- Does not add chapter/TOC read routes or BFF transport (`/chapters`, `/toc`) (PR-04).
- Does not change reader UI adoption behavior (PR-05).
- Does not alter highlight/chat contracts (PR-06).

---

## constraints
- Only touch files listed in deliverables unless this spec is revised.
- Reuse existing sanitizer/canonicalization/fragment-block primitives; do not duplicate their logic.
- No contract changes outside PR-02 ownership cluster C3.
- No network-dependent test fixtures; tests must run deterministically in local CI.
- Media route additions must keep transport-only architecture (`python/tests/test_route_structure.py` remains green).

---

## boundaries (for ai implementers)

**do**:
- Implement extraction as a reusable service executor with deterministic outputs.
- Keep artifact writes atomic and deterministic.
- Classify extraction failures with explicit S5 error codes.
- Add tests for each behavior-changing decision.

**do not**:
- Modify endpoint envelopes or orchestration policy owned by PR-03.
- Add chapter/toc API routes or response schemas owned by PR-04.
- Introduce Node subprocess EPUB extraction.
- Implement v2 URL-ingest behavior.

---

## open questions + temporary defaults

| question | temporary default behavior | owner | due |
|---|---|---|---|
| none | n/a | n/a | n/a |

---

## checklist
- [ ] every l3 acceptance bullet is in traceability matrix
- [ ] every traceability row has at least one test
- [ ] every behavior-changing decision has assertions
- [ ] only scoped files are touched
- [ ] non-goals are explicit and enforced
