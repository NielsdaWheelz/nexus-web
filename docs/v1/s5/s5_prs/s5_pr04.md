# pr-04: s5 epub chapter + toc read apis

## goal
Expose deterministic EPUB chapter and TOC read APIs (plus browser-path BFF parity) without expanding lifecycle, extraction, or reader-UX scope.

## context
- PR-04 scope in L3 is limited to C5 read contracts and BFF parity (`docs/v1/s5/s5_roadmap.md:115`, `docs/v1/s5/s5_roadmap.md:123`).
- C5 ownership is explicit: chapter/toc endpoint behavior, guards, pagination, and BFF parity (`docs/v1/s5/s5_roadmap_ownership.md:20`).
- L2 read contracts are already normative for `/chapters`, `/chapters/{idx}`, `/toc` (`docs/v1/s5/s5_spec.md:462`, `docs/v1/s5/s5_spec.md:504`, `docs/v1/s5/s5_spec.md:542`).
- Determinism and visibility invariants are already locked (`docs/v1/s5/s5_spec.md:665`, `docs/v1/s5/s5_spec.md:669`, `docs/v1/s5/s5_spec.md:673`, `docs/v1/s5/s5_spec.md:674`).
- Backend currently exposes fragments/ingest/retry/assets routes but no chapter/toc read routes (`python/nexus/api/routes/media.py:141`, `python/nexus/api/routes/media.py:190`, `python/nexus/api/routes/media.py:219`, `python/nexus/api/routes/media.py:246`).
- Browser BFF currently mirrors only existing media routes (`apps/web/src/app/api/media/[id]/route.ts:1`, `apps/web/src/app/api/media/[id]/fragments/route.ts:1`, `apps/web/src/app/api/media/[id]/file/route.ts:1`, `apps/web/src/app/api/media/[id]/ingest/route.ts:1`).
- Constitution requires non-streaming browser traffic to go through Next.js BFF (`docs/v1/constitution.md:111`).

## dependencies
- PR-03 merged (lifecycle + retry already authoritative).
- PR-02 merged (chapter fragments + TOC snapshot persistence already available).

---

## deliverables

### `python/nexus/services/epub_read.py`
- Add a dedicated EPUB read-domain service module (C5 owner) rather than extending lifecycle or extraction modules.
- Define typed outputs:
  - `EpubChapterSummaryOut`
  - `EpubChapterOut`
  - `EpubTocNodeOut`
  - `EpubChapterPageOut`
- Expose entrypoints:
  - `list_epub_chapters_for_viewer(db: Session, viewer_id: UUID, media_id: UUID, *, limit: int = 100, cursor: int | None = None) -> EpubChapterPageOut`
  - `get_epub_chapter_for_viewer(db: Session, viewer_id: UUID, media_id: UUID, idx: int) -> EpubChapterOut`
  - `get_epub_toc_for_viewer(db: Session, viewer_id: UUID, media_id: UUID) -> list[EpubTocNodeOut]`

Required guard behavior for all three functions:
- Visibility masking first: unreadable/missing media returns `404 E_MEDIA_NOT_FOUND`.
- Kind guard second: non-EPUB returns `400 E_INVALID_KIND`.
- Readiness guard third: status outside `ready_for_reading|embedding|ready` returns `409 E_MEDIA_NOT_READY`.

Required `/chapters` behavior:
- Query domain:
  - `limit` default `100`, min `1`, max `200`.
  - `cursor` optional integer chapter idx; returns rows with `idx > cursor`.
  - invalid range/domain values return `400 E_INVALID_REQUEST`.
- Ordering/pagination:
  - strict `idx ASC`.
  - fetch `limit + 1` rows to compute `has_more`.
  - `next_cursor = last_returned_idx` when page has data and `has_more=true`; else `null`.
  - out-of-range cursor semantics are non-error: when `cursor >= max_idx`, return `200` with `data: []`, `page.next_cursor: null`, and `page.has_more: false`.
  - response `data` length never exceeds `limit`.
- Manifest shape:
  - metadata-only; must not include `html_sanitized` or `canonical_text`.
  - query projection must be summary-only: `/chapters` implementation must not select heavyweight content columns (`html_sanitized`, `canonical_text`) from storage.
  - include `idx`, `fragment_id`, `title`, `char_count`, `word_count`, `has_toc_entry`, `primary_toc_node_id`.
- Deterministic chapter summary derivation:
  - `char_count` = Unicode codepoint length of `canonical_text`.
  - `word_count` = non-empty token count from `canonical_text.trim().split(/\s+/)`.
  - `has_toc_entry` true iff any TOC node maps to chapter idx.
  - `primary_toc_node_id` = mapped node with minimum `order_key`; else `null`.
  - `title` fallback chain:
    1. label of primary TOC node (if mapped)
    2. first heading (`h1..h6`) text found in `html_sanitized`
    3. `Chapter {idx+1}`

Required `/chapters/{idx}` behavior:
- `idx` must be integer `>= 0`; invalid idx domain returns `400 E_INVALID_REQUEST`.
- missing chapter row for media returns `404 E_CHAPTER_NOT_FOUND`.
- payload includes manifest fields plus `html_sanitized`, `canonical_text`, `prev_idx`, `next_idx`, `created_at`.
- payload is chapter-scoped only: endpoint returns exactly one persisted chapter fragment for `idx` and must never concatenate adjacent chapters or whole-book content.
- navigation pointers are deterministic by idx bounds only:
  - `prev_idx = idx-1` when `idx > 0` else `null`
  - `next_idx = idx+1` when `idx < max_idx` else `null`

Required `/toc` behavior:
- Read `epub_toc_nodes` rows ordered by `order_key ASC`.
- Materialize a nested tree with `children` arrays preserving sibling order by `order_key`.
- `fragment_idx` may be `null`.
- EPUB with zero TOC rows returns `nodes: []` and `200`.

Implementation constraints:
- No lifecycle mutation in PR-04 read services.
- No extraction recomputation; consume persisted `fragments` and `epub_toc_nodes`.
- Route-facing errors must use existing error taxonomy only.

### `python/nexus/schemas/media.py`
- Add S5 PR-04 response schemas:
  - `EpubChapterSummaryOut`
  - `EpubChapterOut`
  - `EpubTocNodeOut` (recursive `children`)
  - `EpubChapterPageInfoOut` (`next_cursor: int | None`, `has_more: bool`)
  - `EpubChapterListOut` (`data`, `page`)
  - `EpubTocOut` (`nodes`)
- Keep existing S1/S3/S5 schemas unchanged.

### `python/nexus/api/routes/media.py`
- Add read routes:
  - `GET /media/{media_id}/chapters`
  - `GET /media/{media_id}/chapters/{idx}`
  - `GET /media/{media_id}/toc`
- Route layer remains transport-only:
  - extract viewer/db deps
  - call exactly one service function per route
  - return `success_response(...)` envelope
- Do not add DB queries or policy logic to route handlers.

### `python/tests/test_media.py`
- Add PR-04 endpoint tests with deterministic fixtures over persisted fragments + `epub_toc_nodes`.

Required tests:

**test: `test_get_epub_chapters_manifest_pagination_is_deterministic`**
- input:
  - readable EPUB with at least 3 chapter fragments and mapped TOC nodes
  - call `GET /media/{id}/chapters?limit=2`, then next page with returned cursor
- output:
  - strict idx ordering
  - canonical `page.next_cursor` + `page.has_more`
  - no duplicate/omitted chapter idx across pages

**test: `test_get_epub_chapters_cursor_out_of_range_returns_empty_page`**
- input:
  - readable EPUB and `cursor` greater than or equal to current max chapter idx
- output:
  - `200` with empty `data`, `page.next_cursor=null`, `page.has_more=false`

**test: `test_get_epub_chapters_manifest_is_metadata_only`**
- input:
  - readable EPUB chapter manifest request
- output:
  - each item includes summary fields only
  - `html_sanitized` and `canonical_text` keys absent

**test: `test_get_epub_chapters_projection_excludes_heavy_columns`**
- input:
  - invoke chapter-manifest service path with SQL inspection/spy seam enabled
- output:
  - executed chapter-manifest query does not select `html_sanitized` or `canonical_text`

**test: `test_get_epub_chapters_primary_toc_node_uses_min_order_key`**
- input:
  - readable EPUB where multiple TOC nodes map to the same chapter idx with different `order_key` values
- output:
  - `primary_toc_node_id` equals the node id from minimum `order_key`
  - title derivation uses that same primary TOC node label

**test: `test_get_epub_chapter_by_idx_returns_payload_and_navigation`**
- input:
  - readable EPUB with contiguous chapters, fetch middle and boundary chapters
- output:
  - payload contains full chapter fields
  - `prev_idx`/`next_idx` match deterministic bound rules

**test: `test_get_epub_chapter_returns_single_chapter_not_concatenated`**
- input:
  - readable EPUB with at least 2 chapters containing distinct sentinel text per chapter
- output:
  - `/chapters/{idx}` payload contains only sentinel text for requested chapter and excludes adjacent chapter sentinel text

**test: `test_get_epub_chapter_missing_idx_returns_404`**
- input:
  - readable EPUB, request `idx` not present
- output:
  - `404 E_CHAPTER_NOT_FOUND`

**test: `test_get_epub_toc_returns_nested_tree_ordered_by_order_key`**
- input:
  - readable EPUB with nested TOC nodes persisted out-of-insert-order
- output:
  - response tree sibling ordering follows `order_key ASC`
  - parent/child linkage preserved

**test: `test_get_epub_toc_empty_returns_nodes_empty`**
- input:
  - readable EPUB with zero TOC nodes
- output:
  - `200` and `{nodes: []}`

**test: `test_get_epub_read_endpoints_visibility_masking`**
- input:
  - media visible to user A but not user B; call all three endpoints as user B
- output:
  - `404 E_MEDIA_NOT_FOUND` for `/chapters`, `/chapters/{idx}`, `/toc`

**test: `test_get_epub_read_endpoints_kind_and_readiness_guards`**
- input:
  - non-EPUB media and non-ready EPUB media across all read endpoints
- output:
  - non-EPUB -> `400 E_INVALID_KIND`
  - non-ready -> `409 E_MEDIA_NOT_READY`

**test: `test_get_epub_chapters_invalid_limit_cursor_and_idx_are_400`**
- input:
  - invalid `limit`/`cursor` query values and invalid `idx` domain
- output:
  - `400 E_INVALID_REQUEST`

### `apps/web/src/app/api/media/[id]/chapters/route.ts`
- Add Next.js BFF proxy route:
  - `GET /api/media/{id}/chapters` -> `/media/{id}/chapters`
- Must remain transport-only and use `proxyToFastAPI`.

### `apps/web/src/app/api/media/[id]/chapters/[idx]/route.ts`
- Add Next.js BFF proxy route:
  - `GET /api/media/{id}/chapters/{idx}` -> `/media/{id}/chapters/{idx}`
- Must remain transport-only and use `proxyToFastAPI`.

### `apps/web/src/app/api/media/[id]/toc/route.ts`
- Add Next.js BFF proxy route:
  - `GET /api/media/{id}/toc` -> `/media/{id}/toc`
- Must remain transport-only and use `proxyToFastAPI`.

### `apps/web/src/app/api/media/media-routes.test.ts`
- Add BFF proxy-route tests (Vitest) validating new route handlers call `proxyToFastAPI` with exact upstream paths.

Required tests:

**test: `GET /api/media/[id]/chapters proxies to /media/{id}/chapters`**
- input: invoke route handler with id param + optional query string
- output: `proxyToFastAPI` called once with `/media/{id}/chapters`

**test: `GET /api/media/[id]/chapters forwards limit/cursor query string unchanged`**
- input: invoke route handler with `?limit=...&cursor=...`
- output: proxied request preserves query string and upstream path remains `/media/{id}/chapters`

**test: `GET /api/media/[id]/chapters/[idx] proxies to /media/{id}/chapters/{idx}`**
- input: invoke route handler with id + idx params
- output: `proxyToFastAPI` called once with `/media/{id}/chapters/{idx}`

**test: `GET /api/media/[id]/toc proxies to /media/{id}/toc`**
- input: invoke route handler with id param
- output: `proxyToFastAPI` called once with `/media/{id}/toc`

---

## decision ledger

| question | decision | rationale | fallback/default |
|---|---|---|---|
| Should PR-04 extend `media.py` further or introduce a dedicated read service module? | Introduce `python/nexus/services/epub_read.py` as C5 owner. | Keeps lifecycle/extraction/read boundaries explicit and prevents a monolithic media service from accumulating unrelated policy. | If module split blocks merge, allow thin wrappers in `media.py` temporarily but keep authoritative logic in `epub_read.py` before PR close. |
| Should chapter cursor be opaque (base64 token) or integer idx? | Keep integer idx cursor exactly as L2 contract (`idx > cursor`). | Contract already defines integer cursor domain; changing now creates cross-doc drift and unnecessary client migration risk. | Future opaque cursor migration is allowed only via L2/L3 revision in a later slice. |
| How should chapter pagination behave when cursor is beyond the current chapter range? | Treat as non-error exhausted page: return `200` with empty `data`, `next_cursor=null`, `has_more=false`. | Deterministic, idempotent pagination for resumable clients; avoids brittle client branching on benign out-of-range state. | Negative cursor values or malformed cursor values remain invalid and map to `400 E_INVALID_REQUEST`. |
| Where should chapter titles come from in PR-04, given no persisted chapter-title column? | Derive deterministically at read time: primary TOC label (mapped node with minimum `order_key`) -> first heading in sanitized HTML -> `Chapter {idx+1}`. | Preserves deterministic contract without schema expansion and avoids scope creep into PR-02 artifact format. | If heading extraction fails for malformed HTML, fallback immediately to `Chapter {idx+1}`. |
| What guard order should endpoints enforce to avoid information leaks? | Enforce `visibility -> kind -> readiness -> resource lookup`. | Preserves masked existence semantics while still honoring explicit kind/readiness contracts for authorized readers. | If endpoint-specific constraints require additional checks, append after these guards; do not reorder masking check. |
| Should `/toc` be rebuilt from EPUB source or persisted rows? | Use persisted `epub_toc_nodes` only; build nested JSON tree in service layer. | PR-04 owns read APIs, not extraction; recomputing TOC at read time violates C3 ownership and can break determinism. | If malformed persistence is encountered unexpectedly, return deterministic server error and log; do not silently recompute. |
| Is BFF parity optional for backend-read endpoints in this PR? | No. Add matching Next.js `/api/media/...` routes and tests in the same PR. | Constitution requires non-streaming browser traffic via BFF; split delivery would create unsupported direct FastAPI browser calls. | If frontend adoption is deferred (PR-05), BFF transport still lands now as contractual infrastructure. |
| Should `/chapters` read query full fragment payload columns and drop them at serialization time? | No. `/chapters` must use summary-only DB projection and avoid selecting `html_sanitized`/`canonical_text`. | Prevents large-book performance regressions and enforces metadata-only behavior at storage-read boundary, not only at response shape. | If ORM mapping makes projection awkward, use explicit SQL projection for summary fields. |
| How should PR-04 prevent regression to legacy whole-book concatenated read behavior? | `/chapters/{idx}` is strictly single-fragment scoped and must never return concatenated multi-chapter content. | S5 architecture replaces legacy single-blob rendering with deterministic chapter boundaries; this guard preserves that core design. | If a caller needs whole-book content, use existing `/fragments` iteration path outside PR-04 endpoint contracts. |

---

## traceability matrix

| l3 acceptance item | deliverable(s) | test(s) |
|---|---|---|
| `GET /media/{id}/chapters` returns metadata-only chapter manifest with deterministic cursor pagination. | `python/nexus/services/epub_read.py`, `python/nexus/schemas/media.py`, `python/nexus/api/routes/media.py` | `test_get_epub_chapters_manifest_pagination_is_deterministic`, `test_get_epub_chapters_cursor_out_of_range_returns_empty_page`, `test_get_epub_chapters_manifest_is_metadata_only`, `test_get_epub_chapters_projection_excludes_heavy_columns`, `test_get_epub_chapters_primary_toc_node_uses_min_order_key`, `test_get_epub_chapters_invalid_limit_cursor_and_idx_are_400` |
| `GET /media/{id}/chapters/{idx}` returns chapter payload with deterministic `prev_idx`/`next_idx`. | `python/nexus/services/epub_read.py`, `python/nexus/schemas/media.py`, `python/nexus/api/routes/media.py` | `test_get_epub_chapter_by_idx_returns_payload_and_navigation`, `test_get_epub_chapter_returns_single_chapter_not_concatenated`, `test_get_epub_chapter_missing_idx_returns_404` |
| `GET /media/{id}/toc` returns deterministic nested TOC tree ordering by `order_key`. | `python/nexus/services/epub_read.py`, `python/nexus/schemas/media.py`, `python/nexus/api/routes/media.py` | `test_get_epub_toc_returns_nested_tree_ordered_by_order_key`, `test_get_epub_toc_empty_returns_nodes_empty` |
| Visibility masking, readiness guards, and non-EPUB kind guards are enforced exactly per contract. | `python/nexus/services/epub_read.py`, `python/nexus/api/routes/media.py` | `test_get_epub_read_endpoints_visibility_masking`, `test_get_epub_read_endpoints_kind_and_readiness_guards` |
| Matching browser-path BFF transport exists for all new non-streaming EPUB read endpoints introduced in this PR. | `apps/web/src/app/api/media/[id]/chapters/route.ts`, `apps/web/src/app/api/media/[id]/chapters/[idx]/route.ts`, `apps/web/src/app/api/media/[id]/toc/route.ts`, `apps/web/src/app/api/media/media-routes.test.ts` | `GET /api/media/[id]/chapters proxies to /media/{id}/chapters`, `GET /api/media/[id]/chapters forwards limit/cursor query string unchanged`, `GET /api/media/[id]/chapters/[idx] proxies to /media/{id}/chapters/{idx}`, `GET /api/media/[id]/toc proxies to /media/{id}/toc` |

---

## acceptance tests

### file: `python/tests/test_media.py`

**test: `test_get_epub_chapters_manifest_pagination_is_deterministic`**
- input: readable EPUB with 3+ chapters; call `/media/{id}/chapters?limit=2`, then with returned cursor.
- output: deterministic `idx ASC`, stable `next_cursor`, correct `has_more`, no cross-page duplication.

**test: `test_get_epub_chapters_cursor_out_of_range_returns_empty_page`**
- input: readable EPUB with cursor greater than or equal to max chapter idx.
- output: `200` with empty data page (`next_cursor=null`, `has_more=false`).

**test: `test_get_epub_chapters_manifest_is_metadata_only`**
- input: readable EPUB, call `/media/{id}/chapters`.
- output: summary fields present; `html_sanitized` and `canonical_text` absent from every item.

**test: `test_get_epub_chapters_projection_excludes_heavy_columns`**
- input: chapter-manifest read path with query inspection seam.
- output: SQL/projection excludes `html_sanitized` and `canonical_text`.

**test: `test_get_epub_chapters_primary_toc_node_uses_min_order_key`**
- input: readable EPUB where one chapter maps to multiple TOC nodes.
- output: `primary_toc_node_id` and derived title use the mapped node with minimum `order_key`.

**test: `test_get_epub_chapter_by_idx_returns_payload_and_navigation`**
- input: readable EPUB with contiguous chapters; call `/media/{id}/chapters/{idx}` for first/middle/last idx.
- output: deterministic `prev_idx`/`next_idx` values and full chapter payload contract.

**test: `test_get_epub_chapter_returns_single_chapter_not_concatenated`**
- input: readable EPUB with chapter-specific sentinel content.
- output: requested chapter payload excludes sentinel content from adjacent chapters.

**test: `test_get_epub_chapter_missing_idx_returns_404`**
- input: readable EPUB, request non-existent chapter idx.
- output: `404` with `E_CHAPTER_NOT_FOUND`.

**test: `test_get_epub_toc_returns_nested_tree_ordered_by_order_key`**
- input: readable EPUB with nested TOC rows.
- output: nested tree with sibling ordering by `order_key` and stable `fragment_idx` linkage.

**test: `test_get_epub_toc_empty_returns_nodes_empty`**
- input: readable EPUB with no `epub_toc_nodes` rows.
- output: `200` and `data.nodes == []`.

**test: `test_get_epub_read_endpoints_visibility_masking`**
- input: unreadable caller requests `/chapters`, `/chapters/{idx}`, `/toc`.
- output: all return `404 E_MEDIA_NOT_FOUND`.

**test: `test_get_epub_read_endpoints_kind_and_readiness_guards`**
- input: readable non-EPUB media and readable non-ready EPUB media.
- output: non-EPUB => `400 E_INVALID_KIND`; non-ready => `409 E_MEDIA_NOT_READY`.

**test: `test_get_epub_chapters_invalid_limit_cursor_and_idx_are_400`**
- input: invalid `limit`/`cursor` query and invalid idx domain requests.
- output: `400 E_INVALID_REQUEST`.

### file: `apps/web/src/app/api/media/media-routes.test.ts`

**test: `GET /api/media/[id]/chapters proxies to /media/{id}/chapters`**
- input: invoke route handler with id and query string.
- output: `proxyToFastAPI` called with upstream path `/media/{id}/chapters`.

**test: `GET /api/media/[id]/chapters forwards limit/cursor query string unchanged`**
- input: invoke route handler with `?limit=...&cursor=...`.
- output: forwarded request preserves query string and targets `/media/{id}/chapters`.

**test: `GET /api/media/[id]/chapters/[idx] proxies to /media/{id}/chapters/{idx}`**
- input: invoke route handler with id + idx params.
- output: `proxyToFastAPI` called with upstream path `/media/{id}/chapters/{idx}`.

**test: `GET /api/media/[id]/toc proxies to /media/{id}/toc`**
- input: invoke route handler with id param.
- output: `proxyToFastAPI` called with upstream path `/media/{id}/toc`.

---

## non-goals
- Does not change extraction artifact generation, TOC persistence rules, or archive-safety behavior (owned by PR-02).
- Does not change ingest/retry lifecycle orchestration (owned by PR-03).
- Does not implement chapter-reader UX adoption (owned by PR-05).
- Does not modify highlight or quote-to-chat contracts (owned by PR-06).

---

## constraints
- Only touch files listed in deliverables unless spec is revised.
- Follow existing route/service separation guardrails (`python/tests/test_route_structure.py`).
- Preserve existing error taxonomy and response-envelope conventions.
- Keep browser-path transport BFF-only for all non-streaming endpoints.

---

## boundaries (for ai implementers)

**do**:
- Implement only chapter/toc read behavior and BFF parity listed above.
- Keep endpoint outputs deterministic and derived from persisted artifacts.
- Add tests for every behavior-changing decision and every acceptance bullet.

**do not**:
- Add retry/ingest/lifecycle mutations.
- Add reader UI logic or advanced EPUB rendering features.
- Recompute EPUB artifacts from source bytes at read time.
- Alter existing `/media/{id}/fragments` behavior.

---

## open questions + temporary defaults

| question | temporary default behavior | owner | due |
|---|---|---|---|
| none | n/a | n/a | n/a |

---

## checklist
- [ ] every l3 acceptance bullet is in traceability matrix
- [ ] every traceability row has at least one test
- [ ] every behavior-changing decision has assertions
- [ ] only scoped files are touched
- [ ] non-goals are explicit and enforced
