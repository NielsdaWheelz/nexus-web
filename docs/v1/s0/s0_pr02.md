# pr-02_spec.md — db access layer: repositories + transaction pattern (slice 0)

this pr locks the **only allowed database access patterns** for nexus.
after this merges, no endpoint or future pr may invent its own db usage style.

---

## goal

establish a consistent, explicit, testable persistence layer that:
- uses one session per request
- has explicit transaction boundaries for writes
- separates persistence from auth/visibility/business rules
- prevents N+1s and ad-hoc SQL later

this pr intentionally does **not** implement visibility policy (`can_view`) or endpoints.

---

## scope

### includes
- db session dependency
- transaction pattern for writes
- repository modules with exact function signatures
- internal db DTOs (not API schemas)
- repo-level exception types
- composable SQL helpers (for later visibility work)
- integration tests for repo behavior

### excludes
- auth / token verification
- user bootstrap logic
- visibility policy (`can_view`)
- api endpoints
- pydantic request/response models
- rls policies
- migrations (already done in pr-01)

---

## hard decisions (locked)

- **sql layer**: sqlalchemy core (no ORM relationship magic)
- **session lifecycle**: one session per request
- **writes**: always wrapped in `with session.begin():`
- **reads**: no implicit transactions
- **repos**: pure persistence only (no auth, no visibility)
- **errors**: repos raise repo exceptions, never ApiError
- **visibility helper**: returns a composable selectable/cte, not a list
- **sessions**: always passed explicitly, never global
- **dto types**: internal dataclasses, not pydantic

---

## directory structure (binding)

apps/api/
db/
session.py
repos/
init.py
users.py
libraries.py
library_users.py
media.py
library_media.py
highlights.py
visibility_sql.py
models/
db_types.py
tests/
test_repos_users.py
test_repos_libraries.py
test_repos_library_users.py
test_repos_media.py
test_repos_visibility_sql.py

no other db-access locations are allowed.

---

## db session + transaction pattern

### db/session.py

```python
from sqlalchemy.orm import Session

def get_db() -> Session:
    """
    fastapi dependency.
    yields one session per request.
    caller is responsible for commit/rollback via explicit transaction blocks.
    """

rules:
	•	autocommit disabled
	•	no implicit commit at request end
	•	repos never close the session

⸻

repo exception model (authoritative)

models/db_types.py

class RepoError(Exception):
    pass

class RepoNotFound(RepoError):
    pass

class RepoConflict(RepoError):
    pass

class RepoValidation(RepoError):
    pass

class RepoIntegrity(RepoError):
    pass

mapping rules:
	•	sqlalchemy IntegrityError → RepoConflict or RepoIntegrity
	•	repos do not know HTTP semantics

⸻

internal db DTOs (authoritative)

models/db_types.py

from dataclasses import dataclass
from uuid import UUID
from datetime import datetime
from typing import Optional

@dataclass(frozen=True)
class DbUser:
    id: UUID
    email: Optional[str]
    created_at: datetime

@dataclass(frozen=True)
class DbLibrary:
    id: UUID
    owner_user_id: UUID
    is_default: bool
    name: Optional[str]
    created_at: datetime

@dataclass(frozen=True)
class DbMembership:
    library_id: UUID
    user_id: UUID
    role: str
    created_at: datetime

@dataclass(frozen=True)
class DbMedia:
    id: UUID
    kind: str
    processing_status: str
    created_at: datetime

@dataclass(frozen=True)
class DbHighlight:
    id: UUID
    owner_user_id: UUID
    sharing: str
    anchor_media_id: Optional[UUID]
    created_at: datetime

repos must return these exact shapes.

⸻

repository contracts (exact)

repos/users.py

def get_user(session: Session, user_id: UUID) -> DbUser | None
def upsert_user(session: Session, user_id: UUID, email: Optional[str]) -> DbUser

rules:
	•	upsert is idempotent
	•	no transaction opened here (caller decides)

⸻

repos/libraries.py

def create_default_library(session: Session, owner_user_id: UUID) -> DbLibrary
def get_default_library(session: Session, owner_user_id: UUID) -> DbLibrary | None
def list_libraries_for_user(session: Session, user_id: UUID) -> list[DbLibrary]
def get_library(session: Session, library_id: UUID) -> DbLibrary | None
def is_default_library(session: Session, library_id: UUID) -> bool

rules:
	•	create_default_library must tolerate races via unique constraint
	•	no membership logic here

⸻

repos/library_users.py

def add_member(session: Session, library_id: UUID, user_id: UUID, role: str) -> DbMembership
def remove_member(session: Session, library_id: UUID, user_id: UUID) -> None
def get_membership(session: Session, library_id: UUID, user_id: UUID) -> DbMembership | None
def list_members(session: Session, library_id: UUID) -> list[DbMembership]

rules:
	•	role is not validated here beyond enum constraint
	•	admin invariants enforced later (pr-09)

⸻

repos/media.py

def create_media(session: Session, kind: str, processing_status: str = "pending") -> DbMedia
def get_media(session: Session, media_id: UUID) -> DbMedia | None


⸻

repos/library_media.py

def add_media(session: Session, library_id: UUID, media_id: UUID) -> None
def remove_media(session: Session, library_id: UUID, media_id: UUID) -> None


⸻

repos/highlights.py

def list_by_anchor_media(session: Session, media_id: UUID) -> list[DbHighlight]

notes:
	•	no visibility logic
	•	no ordering guarantees beyond created_at asc

⸻

repos/visibility_sql.py

from sqlalchemy.sql import Select

def visible_media_ids_select(viewer_user_id: UUID) -> Select

definition:
	•	returns a selectable/cte producing a single column: media_id
	•	logic:
	•	join library_users → library_media
	•	filter library_users.user_id = viewer_user_id
	•	select distinct library_media.media_id

rules:
	•	must be composable (used in joins/subqueries later)
	•	must not execute the query

⸻

transaction rules (binding)
	•	any repo function that writes assumes the caller wraps it in:

with session.begin():
    ...

	•	repos must not call commit() or rollback()
	•	violations are grounds for rejecting the pr

⸻

tests (mandatory)

tests use real postgres via existing test harness.

required tests
	1.	user upsert idempotence
	•	same user_id twice → one row
	2.	default library creation race safety
	•	call create_default_library twice → one row
	3.	membership uniqueness
	•	duplicate add → RepoConflict
	4.	library_media uniqueness
	•	duplicate add → RepoConflict
	5.	visible_media_ids correctness
	•	user with two libraries sees union of media ids
	•	user sees none if no memberships
	6.	repos do not leak visibility
	•	highlight listing returns rows regardless of owner
	•	visibility filtering happens later

tests must:
	•	open a transaction per test
	•	rollback after test completes

⸻

commands

uv run pytest apps/api/tests/test_repos_*.py


⸻

acceptance criteria

pr-02 is complete when:
	•	all repo functions exist with exact signatures
	•	all tests pass
	•	no endpoint code added
	•	no auth code touched
	•	no visibility policy implemented
	•	no ORM relationships used
	•	no global session usage exists

⸻

guardrails (non-negotiable)

DO NOT:
	•	add ApiError usage
	•	add visibility logic
	•	add endpoints
	•	add pydantic models here
	•	add helper functions not listed
	•	return raw sqlalchemy rows
	•	silently swallow integrity errors

this pr defines the db contract. future prs must conform or be rejected.
