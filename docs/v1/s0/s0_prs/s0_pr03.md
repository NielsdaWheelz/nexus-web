# Nexus — PR-03 Spec (L3)
## Libraries + Membership Rules + Library–Media

This PR implements all **library-domain business logic** for Slice 0.
It must conform to:
- `constitution.md` (v1)
- `s0_spec.md`
- `s0_roadmap.md`

This PR introduces **no new infrastructure** and **no frontend work**.
It is backend-only and service-layer driven.

---

## 1. Goal

Ship the complete, correct, and test-backed implementation of:
- libraries
- memberships
- library–media relationships
- default library closure invariants

After this PR:
- all library invariants are enforced transactionally
- visibility masking works correctly
- no route contains domain logic or raw DB access

---

## 2. Non-Goals

This PR explicitly does **not** include:
- library sharing / invitations
- membership mutation APIs (beyond owner bootstrap)
- media ingestion
- highlights, conversations, search
- frontend or BFF changes

---

## 3. Code Surfaces (Authoritative Inputs)

This PR **must** use the following existing surfaces from PR-01/02:

### DB + Transactions
- `get_db()` → request-scoped `Session`
- `transaction(db)` → atomic service-layer execution

### Errors
- `ApiError(code, message)`
- `ApiErrorCode` enum (no new codes added in this PR)

### Auth Context
- `request.state.viewer_user_id: UUID`
- `request.state.default_library_id: UUID`

### Tables (No Schema Changes)
- `users`
- `libraries`
- `memberships`
- `media`
- `fragments`
- `library_media`

---

## 4. Architectural Rules (Hard)

### 4.1 Service / Route Separation

- **All domain logic lives in `python/nexus/services/libraries.py`.**
- **Routes may not contain domain logic or raw DB access.**
- Routes:
  - extract `viewer_user_id` from `request.state`
  - call exactly one service function
  - return `success(...)` or raise `ApiError`

**Route Signature Pattern (Mandatory):**

Routes must receive the FastAPI `Request` object separately from the body model:

```python
from fastapi import Request, Depends, APIRouter
from sqlalchemy.orm import Session
from nexus.db.session import get_db
from nexus.schemas.library import CreateLibraryRequest, LibraryOut
from nexus.responses import success_response

@router.post("/libraries")
def create_library(
    request: Request,           # FastAPI Request (for request.state)
    body: CreateLibraryRequest, # Pydantic body model
    db: Session = Depends(get_db),
) -> dict:
    viewer_id = request.state.viewer_user_id
    result = libraries_service.create_library(db, viewer_id, body.name)
    return success_response(result.model_dump(mode="json"))
```

**Critical:** `request` is the FastAPI `Request` object. `body` is the Pydantic model. Do not confuse them.

### 4.2 Structural Test — Forbidden Imports

A test **MUST** fail if any `python/nexus/api/routes/*.py` file contains:

**Forbidden imports:**
- Any import from `sqlalchemy` **except** `from sqlalchemy.orm import Session`
- Any import from `nexus.db` **except** `from nexus.db.session import get_db`
- Any usage of `db.execute`, `db.scalar`, `select()`, `insert()`, `update()`, `delete()` in route code

**Allowed imports (exhaustive list):**
- `from fastapi import Request, Depends, APIRouter, HTTPException`
- `from sqlalchemy.orm import Session` (type annotation only)
- `from nexus.db.session import get_db` (dependency only)
- Pydantic schemas from `nexus.schemas.*`
- Service modules from `nexus.services.*`
- Response helper `success_response()` from `nexus.responses`
- `ApiError` from `nexus.errors`

**Implementation:** Use AST parsing or regex to detect forbidden patterns. String matching `db.execute` or `sqlalchemy.sql` catches most violations.

---

## 5. SQLAlchemy Usage Policy

### 5.1 Style

- **Hybrid ORM + Core**
  - ORM or `select()` for simple reads
  - Core expressions for:
    - `INSERT … SELECT`
    - `ON CONFLICT DO NOTHING`
    - membership-count guards

- No lazy-loaded relationships
- No ORM `.relationship()` required in this PR

### 5.2 Transactions

- **Every mutating service function runs inside `transaction(db)`**
- Read-only services may omit transactions
- Use `SELECT … FOR UPDATE` when:
  - deleting libraries
  - renaming libraries
  - removing media from default library
  - computing single-member library sets for cascade removal

---

## 6. Response Schemas (Binding)

All response schemas must match `s0_spec.md` exactly. Routes must not return ORM models directly.

### 6.1 `LibraryOut`

Used by: `create_library`, `rename_library`, `list_libraries`, `get_library`

```python
class LibraryOut(BaseModel):
    id: UUID
    name: str
    owner_user_id: UUID
    is_default: bool
    role: str              # "admin" or "member" — viewer's role in this library
    created_at: datetime
    updated_at: datetime
```

**Critical:** The `role` field is the **viewer's** membership role, not a property of the library itself. Must be computed via JOIN with memberships table.

### 6.2 `MediaOut`

Used by: `list_library_media`, media endpoints (PR-04)

```python
class MediaOut(BaseModel):
    id: UUID
    kind: str              # "web_article", "epub", "pdf", "podcast_episode", "video"
    title: str
    canonical_source_url: str | None
    processing_status: str # "pending", "extracting", "ready_for_reading", "embedding", "ready", "failed"
    created_at: datetime
    updated_at: datetime
```

**Note:** `author` is NOT included. The media schema does not have an `author` column in S0. Authors are added in S2 with metadata extraction.

### 6.3 `LibraryMediaOut`

Used by: `add_media_to_library`

```python
class LibraryMediaOut(BaseModel):
    library_id: UUID
    media_id: UUID
    created_at: datetime
```

---

## 7. Service Layer API (Binding)

All functions live in `python/nexus/services/libraries.py`.

### 7.1 `create_library`

```python
def create_library(db: Session, viewer_id: UUID, name: str) -> LibraryOut
```

**Behavior:**
- `name` is trimmed
- Empty or >100 chars → `E_NAME_INVALID`
- Creates:
  - `libraries` row (`is_default = false`)
  - `memberships` row (`role = admin`)
- Returns created library

**Invariants:**
- Owner membership is always admin
- Default library is never created here

---

### 7.2 `rename_library`

```python
def rename_library(db: Session, viewer_id: UUID, library_id: UUID, name: str) -> LibraryOut
```

**Behavior:**
- Viewer must be admin member
- Non-member → 404 `E_LIBRARY_NOT_FOUND`
- Default library → 403 `E_DEFAULT_LIBRARY_FORBIDDEN`
- Trims name; validates length (1–100 chars)
- Updates both `name` and `updated_at`

**`updated_at` semantics:**

```sql
UPDATE libraries
SET name = :name, updated_at = now()
WHERE id = :library_id
```

---

### 7.3 `delete_library`

```python
def delete_library(db: Session, viewer_id: UUID, library_id: UUID) -> None
```

**Behavior:**
- Viewer must be admin
- Non-member → 404 `E_LIBRARY_NOT_FOUND`
- Default library → 403 `E_DEFAULT_LIBRARY_FORBIDDEN`
- Member-count guard:
  - If membership count > 1 → 403 `E_FORBIDDEN`
- Deletes library row
- Relies on `ON DELETE CASCADE` for cleanup

**Rationale:**
Cascade delete is permitted only when the library is single-member. This guard prevents accidental shared-library deletion in future slices.

---

### 7.4 `list_libraries`

```python
def list_libraries(db: Session, viewer_id: UUID, limit: int) -> list[LibraryOut]
```

**Behavior:**
- Returns libraries where viewer is a member
- Ordering: `created_at ASC`, `id ASC`
- Limit:
  - Default 100
  - Max 200 (clamped)
  - `limit <= 0` → `E_INVALID_REQUEST`

**Query pattern:**

```sql
SELECT l.*, m.role
FROM libraries l
JOIN memberships m ON m.library_id = l.id AND m.user_id = :viewer_id
ORDER BY l.created_at ASC, l.id ASC
LIMIT :limit
```

---

### 7.5 `get_library`

```python
def get_library(db: Session, viewer_id: UUID, library_id: UUID) -> LibraryOut
```

**Behavior:**
- Fetches only if viewer is member
- Otherwise → 404 `E_LIBRARY_NOT_FOUND`

**Note:** No route in this PR uses `get_library` directly. It is included for service-layer completeness and will be used by S1+ features. If you prefer strict minimalism, this function may be deferred to the PR that needs it.

---

### 7.6 `add_media_to_library`

```python
def add_media_to_library(
    db: Session,
    viewer_id: UUID,
    library_id: UUID,
    media_id: UUID,
) -> LibraryMediaOut
```

**Behavior:**
- Viewer must be admin member
- Non-member → 404 `E_LIBRARY_NOT_FOUND`
- Media must exist → else 404 `E_MEDIA_NOT_FOUND`
- Inserts `(library_id, media_id)`
- Default library closure enforced:

```sql
INSERT INTO library_media (library_id, media_id)
SELECT default_lib.id, :media_id
FROM memberships m
JOIN libraries default_lib
  ON default_lib.owner_user_id = m.user_id
 AND default_lib.is_default = true
WHERE m.library_id = :library_id
ON CONFLICT DO NOTHING
```

**Notes:**
- No readability checks on media attachment (any existing media can be added)
- Idempotent inserts required (`ON CONFLICT DO NOTHING`)

---

### 7.7 `remove_media_from_library`

```python
def remove_media_from_library(
    db: Session,
    viewer_id: UUID,
    library_id: UUID,
    media_id: UUID,
) -> None
```

**Check Order (Strict — Prevents Existence Leakage):**

1. Verify viewer is member of `library_id`
   - Not a member → 404 `E_LIBRARY_NOT_FOUND` (masks library existence)
2. Verify viewer is admin
   - Not admin → 403 `E_FORBIDDEN`
3. Verify `(library_id, media_id)` exists in `library_media`
   - Not found → 404 `E_MEDIA_NOT_FOUND` (do NOT separately check `media` table)

**Rationale for step 3:** Checking `library_media` membership is sufficient. If the media doesn't exist in the library, return `E_MEDIA_NOT_FOUND` regardless of whether the media row exists globally. This simplifies logic and avoids separate existence leakage vectors.

**If removing from default library:**
- Delete `(media_id)` from:
  - Default library itself
  - All single-member, viewer-owned non-default libraries

**If removing from non-default library:**
- Delete only that `(library_id, media_id)`
- Default library unaffected

**Locking Rule (Critical for S1+):**

When computing "single-member libraries owned by viewer," the query MUST:
- Run inside the same transaction as the delete
- Use `FOR UPDATE` on `libraries` rows to prevent concurrent membership changes from racing

```sql
DELETE FROM library_media
WHERE media_id = :media_id
AND library_id IN (
    SELECT l.id
    FROM libraries l
    JOIN memberships m ON m.library_id = l.id
    WHERE l.owner_user_id = :viewer_id
    AND l.is_default = false
    GROUP BY l.id
    HAVING COUNT(m.user_id) = 1
    FOR UPDATE OF l
)
```

**Note:** Default library (`is_default = true`) is explicitly excluded from cascade. The default library deletion is handled separately.

---

### 7.8 `list_library_media`

```python
def list_library_media(
    db: Session,
    viewer_id: UUID,
    library_id: UUID,
    limit: int,
) -> list[MediaOut]
```

**Behavior:**
- Viewer must be member of `library_id` → else 404 `E_LIBRARY_NOT_FOUND`
- Ordering: `library_media.created_at DESC`, `media.id DESC`
- Limit rules same as `list_libraries`

**Query pattern:**

```sql
SELECT m.id, m.kind, m.title, m.canonical_source_url,
       m.processing_status, m.created_at, m.updated_at
FROM media m
JOIN library_media lm ON lm.media_id = m.id
WHERE lm.library_id = :library_id
AND EXISTS (
    SELECT 1 FROM memberships mem
    WHERE mem.library_id = :library_id AND mem.user_id = :viewer_id
)
ORDER BY lm.created_at DESC, m.id DESC
LIMIT :limit
```

**Note:** The `EXISTS` subquery ensures non-members get 404 before any media is returned. Alternatively, verify membership in a separate step before the query.

---

## 8. API Routes (Transport Only)

All routes live in `python/nexus/api/routes/libraries.py`.

**Routes implemented:**
- `GET /libraries`
- `POST /libraries`
- `PATCH /libraries/{id}`
- `DELETE /libraries/{id}`
- `GET /libraries/{id}/media`
- `POST /libraries/{id}/media`
- `DELETE /libraries/{id}/media/{media_id}`

**Rules:**
- No DB access
- No branching on role logic
- Call service → return `success(...)`

---

## 9. Error Semantics (Strict)

| Situation | Error |
|-----------|-------|
| Not authenticated | 401 `E_UNAUTHENTICATED` |
| Not a member | 404 `E_LIBRARY_NOT_FOUND` |
| Not admin | 403 `E_FORBIDDEN` |
| Default library mutation | 403 `E_DEFAULT_LIBRARY_FORBIDDEN` |
| Media missing or masked | 404 `E_MEDIA_NOT_FOUND` |
| Invalid name | 400 `E_NAME_INVALID` |
| `limit ≤ 0` | 400 `E_INVALID_REQUEST` |

---

## 10. Tests (Mandatory)

### 10.1 FastAPI Integration Tests

Must cover:
- Create / rename / delete library
- Admin vs non-admin behavior
- Default library protections
- Member-count delete guard
- Add/remove media closure logic
- 404 masking semantics
- Ordering stability
- Limit clamping

### 10.2 Structural Test

A test **MUST** fail if:
- Any `python/nexus/api/routes/*.py` violates the import rules in §4.2

See §4.2 for the exhaustive list of allowed vs forbidden imports.

---

## 11. Exit Criteria

PR-03 is complete when:
- All service functions implemented exactly as specified
- All routes wired correctly
- All tests pass
- No invariant violations
- No TODOs for library logic
- Next PR (PR-04) can add media routes without touching library code
