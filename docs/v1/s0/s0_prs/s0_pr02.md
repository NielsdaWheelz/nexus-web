# Nexus — PR-02 Spec (L3)

## Auth Boundary + Bootstrap + Test Harness

This PR establishes the authentication boundary, identity bootstrap, and test harness.
It hardens the system against unauthorized access and guarantees user/default-library invariants.

This PR depends on **PR-01** and must not introduce any domain logic beyond auth + bootstrap.

---

## 0. Goals and Non-Goals

### Goals
- Enforce **bearer-only authentication** in FastAPI
- Enforce **BFF-only access** in staging/prod via internal header
- Verify Supabase JWTs correctly and securely
- Guarantee:
  - user row exists
  - exactly one default library exists
  - owner admin membership exists
- Make auth + bootstrap **race-safe**
- Establish a **deterministic, fast test harness**

### Non-Goals
- No library CRUD beyond bootstrap
- No media ingestion
- No UI work
- No refresh token handling
- No browser-to-FastAPI calls

---

## 1. Auth Boundary (Hard Constraints)

### 1.1 Accepted Auth Mechanism
- **Only** `Authorization: Bearer <jwt>`
- FastAPI **never**:
  - reads cookies
  - reads headers/body fields as user id
  - accepts refresh tokens

### 1.2 Authorization Header Parsing

Exact rules:
1. Header must be present
2. Value must start with `Bearer ` (case-insensitive, single space)
3. Token is everything after `Bearer `
4. Token must be non-empty after trimming whitespace

Failure conditions (all → 401 `E_UNAUTHENTICATED`):
- Missing `Authorization` header
- Value does not match `Bearer <token>` pattern
- Token part is empty or whitespace-only
- Multiple tokens or malformed format

```python
# Pseudocode
auth_header = request.headers.get("Authorization")
if not auth_header:
    raise E_UNAUTHENTICATED

if not auth_header.lower().startswith("bearer "):
    raise E_UNAUTHENTICATED

token = auth_header[7:].strip()
if not token:
    raise E_UNAUTHENTICATED
```

### 1.3 Internal Header Enforcement (BFF Gate)

| Environment | Header Required |
|------------|-----------------|
| `local` | no |
| `test` | no |
| `staging` | yes |
| `prod` | yes |

- Header name: `X-Nexus-Internal`
- Value must match `NEXUS_INTERNAL_SECRET`
- **Comparison must use constant-time comparison** (`hmac.compare_digest`)
- Missing or mismatched header → **403 `E_INTERNAL_ONLY`**
- Header check runs **before JWT verification** when enforced

```python
import hmac

def verify_internal_header(header_value: str | None, secret: str) -> bool:
    if header_value is None:
        return False
    return hmac.compare_digest(header_value.encode(), secret.encode())
```

### 1.4 Middleware Scope

**Auth middleware is mounted globally.** All routers are behind it.

Exclusions:
- `GET /health` — no auth required

Every other route, including future routes in PR-03+, automatically goes through auth middleware. No per-router opt-in required.

---

## 2. Token Verification

### 2.1 Verifier Interface

```python
class TokenVerifier(Protocol):
    def verify(self, token: str) -> dict:
        """
        Verify token and return decoded claims.

        Raises:
            ApiError(E_UNAUTHENTICATED): token is invalid, expired, or malformed
            ApiError(E_AUTH_UNAVAILABLE): infrastructure failure (JWKS unreachable)
        """
        ...
```

The interface allows **either** error to be raised. Middleware passes them through unchanged.

### 2.2 Production Verifier (Supabase)

**Implementation:** `SupabaseJwksVerifier`

**Configuration (all required in staging/prod):**
- `SUPABASE_JWKS_URL` — full URL to JWKS endpoint
- `SUPABASE_ISSUER` — expected `iss` claim value
- `SUPABASE_AUDIENCES` — comma-separated list of allowed `aud` values

**Issuer normalization:**
- Strip trailing slash from configured issuer before comparison
- Strip trailing slash from token `iss` claim before comparison
- This prevents mismatch due to `https://foo.supabase.co` vs `https://foo.supabase.co/`

**Validation requirements:**
- Signature verified via JWKS
- Algorithm: RS256 only (reject others)
- `exp` validated with ±60s clock skew allowance
- `iss` must match configured issuer (after normalization)
- `aud` handling:
  - If token has `aud` claim: must be in `SUPABASE_AUDIENCES` list
  - If token lacks `aud` claim: **reject** (tokens must have audience)
- `sub` must parse as valid UUID

**JWKS behavior:**
- Cache keys for 1 hour (TTL-based)
- If `kid` not found in cache:
  - Refresh JWKS once (single attempt)
  - Retry verification with new keys
  - If still missing → `E_UNAUTHENTICATED`
- JWKS fetch failure (network, timeout, invalid response) → `E_AUTH_UNAVAILABLE`

**Error mapping:**
| Condition | Error |
|-----------|-------|
| Invalid signature | `E_UNAUTHENTICATED` |
| Wrong algorithm | `E_UNAUTHENTICATED` |
| Expired token | `E_UNAUTHENTICATED` |
| Bad issuer | `E_UNAUTHENTICATED` |
| Bad/missing audience | `E_UNAUTHENTICATED` |
| Invalid sub UUID | `E_UNAUTHENTICATED` |
| Kid not found after refresh | `E_UNAUTHENTICATED` |
| JWKS fetch failure | `E_AUTH_UNAVAILABLE` |

### 2.3 Test Verifier

**Implementation:** `TestTokenVerifier`

- Uses locally generated RS256 keypair (no network)
- Accepts tokens minted by test helpers
- **Validates the same claim structure as production:**
  - `exp` with ±60s clock skew
  - `sub` must be valid UUID
  - `iss` validated against `TEST_TOKEN_ISSUER` setting (default: `test-issuer`)
  - `aud` validated against `TEST_TOKEN_AUDIENCES` setting (default: `["test-audience"]`)

This ensures test tokens exercise the same validation paths as production, catching config mistakes early.

**Test helpers:**

```python
def mint_test_token(
    user_id: UUID,
    expires_in: int = 3600,
    issuer: str = "test-issuer",
    audience: str = "test-audience",
) -> str:
    """Mint a valid test JWT."""
    ...

def mint_expired_token(user_id: UUID) -> str:
    """Mint a token that expired 1 hour ago."""
    ...

def auth_headers(user_id: UUID) -> dict:
    """Return headers dict with valid Authorization."""
    return {"Authorization": f"Bearer {mint_test_token(user_id)}"}
```

---

## 3. Middleware Ordering (Critical)

For every request except `/health`:

1. **Internal header check** (if `NEXUS_ENV` ∈ {staging, prod})
   - Missing/invalid → 403 `E_INTERNAL_ONLY`
2. **Extract bearer token** (see §1.2)
   - Invalid format → 401 `E_UNAUTHENTICATED`
3. **Verify token** via injected verifier
   - Invalid token → 401 `E_UNAUTHENTICATED`
   - Infra failure → 503 `E_AUTH_UNAVAILABLE`
4. **Parse `sub`** as UUID → `viewer_user_id`
5. **Call `ensure_user_and_default_library(viewer_user_id)`**
6. **Attach to request state:**
   - `viewer_user_id: UUID`
   - `default_library_id: UUID`

Failure at any step short-circuits request with appropriate error.

---

## 4. Bootstrap Logic (Race-Safe)

### 4.1 Contract

After `ensure_user_and_default_library(user_id)` returns:
- `users(id=user_id)` exists
- Exactly one default library exists for user
- Owner admin membership exists
- Function is idempotent
- Concurrent calls converge to correct state

### 4.2 Implementation Requirements

- Single DB transaction
- Use `INSERT … ON CONFLICT DO NOTHING` for user
- For library: SELECT then INSERT with UniqueViolationError recovery
- Recover from partial failure (e.g. library exists but membership missing)
- Rely on DB uniqueness constraints, not application-level checks

**Reference logic:** matches `s0_spec.md` §3.4

---

## 5. API Surface (Slice 0 Only)

### `GET /me`

- Requires auth
- Triggers bootstrap (via middleware)
- Returns minimal identity info

**Response:**

```json
{
  "data": {
    "user_id": "uuid",
    "default_library_id": "uuid"
  }
}
```

**Errors:**
- 401 `E_UNAUTHENTICATED`
- 403 `E_INTERNAL_ONLY` (staging/prod)
- 503 `E_AUTH_UNAVAILABLE`

---

## 6. Error Semantics

### Required Error Codes (Auth)

| Code | HTTP | Meaning |
|------|------|---------|
| `E_UNAUTHENTICATED` | 401 | Missing/invalid/expired token |
| `E_INTERNAL_ONLY` | 403 | Missing or bad internal header |
| `E_AUTH_UNAVAILABLE` | 503 | JWKS fetch or auth infra failure |

- All errors use standard envelope:

```json
{ "error": { "code": "...", "message": "..." } }
```

- No auth error leaks internal details
- Infra failures are not misreported as 401

---

## 7. Settings and Configuration

### Required Settings

| Setting | Required | Notes |
|---------|----------|-------|
| `NEXUS_ENV` | always | `local`, `test`, `staging`, `prod` |
| `NEXUS_INTERNAL_SECRET` | staging/prod | Crash if missing |
| `SUPABASE_JWKS_URL` | staging/prod | Full JWKS endpoint URL |
| `SUPABASE_ISSUER` | staging/prod | Expected issuer (trailing slash stripped) |
| `SUPABASE_AUDIENCES` | staging/prod | Comma-separated allowed audiences |

**Test settings (optional, have defaults):**
| Setting | Default | Notes |
|---------|---------|-------|
| `TEST_TOKEN_ISSUER` | `test-issuer` | Issuer for test tokens |
| `TEST_TOKEN_AUDIENCES` | `test-audience` | Comma-separated test audiences |

**Startup validation:**
- Missing required settings in staging/prod → crash on boot
- Log which settings are missing (but never log secret values)

### NEXUS_INTERNAL_SECRET Security (BFF Side)

When PR-05 implements the Next.js BFF:
- `NEXUS_INTERNAL_SECRET` must be a **server-only environment variable**
- It must **never** be exposed to the browser bundle
- Next.js route handlers (server-side) attach it to outgoing requests
- Client-side JavaScript must never have access to this value

This is a **hard constraint** for PR-05, documented here for completeness.

---

## 8. Auth Failure Logging

### Requirements

All auth failures must be logged with structured data:

```python
logger.warning(
    "auth_failure",
    extra={
        "reason": "expired_token",  # or invalid_signature, bad_issuer, etc.
        "request_path": request.url.path,
        "request_id": request.state.request_id,  # if available
    }
)
```

**Rules:**
- **Never log the raw token** (contains credentials)
- Log failure reason at granular level (helps debugging)
- Include request path and request ID (if available)
- Use structured logging (JSON-compatible extra fields)

**Failure reasons to distinguish:**
- `missing_header` — no Authorization header
- `invalid_header_format` — not `Bearer <token>`
- `invalid_signature` — JWT signature verification failed
- `expired_token` — token past exp + skew
- `invalid_issuer` — iss mismatch
- `invalid_audience` — aud not in allowlist
- `invalid_sub` — sub not a valid UUID
- `kid_not_found` — signing key not in JWKS
- `jwks_unavailable` — couldn't fetch JWKS
- `internal_header_missing` — X-Nexus-Internal absent
- `internal_header_mismatch` — X-Nexus-Internal wrong value

---

## 9. Test Harness

### 9.1 Unit Tests — SupabaseJwksVerifier

**These tests mock HTTP calls to JWKS endpoint.** No database needed.

| # | Scenario | Setup | Expected |
|---|----------|-------|----------|
| 1 | Valid token | Mock JWKS returns correct key | Claims returned |
| 2 | Invalid signature | Mock JWKS returns wrong key | `E_UNAUTHENTICATED` |
| 3 | Expired token | Valid key, token exp in past | `E_UNAUTHENTICATED` |
| 4 | Wrong issuer | Valid sig, bad iss | `E_UNAUTHENTICATED` |
| 5 | Wrong audience | Valid sig, bad aud | `E_UNAUTHENTICATED` |
| 6 | Missing audience | Valid sig, no aud claim | `E_UNAUTHENTICATED` |
| 7 | Invalid sub format | Valid sig, sub not UUID | `E_UNAUTHENTICATED` |
| 8 | Kid miss triggers refresh | First call returns no kid, refresh returns it | Claims returned |
| 9 | Kid miss after refresh | Kid missing even after refresh | `E_UNAUTHENTICATED` |
| 10 | JWKS fetch failure | Mock HTTP error | `E_AUTH_UNAVAILABLE` |
| 11 | JWKS invalid response | Mock returns garbage | `E_AUTH_UNAVAILABLE` |
| 12 | Clock skew accepted | Token exp 30s ago | Claims returned |
| 13 | Clock skew exceeded | Token exp 90s ago | `E_UNAUTHENTICATED` |

### 9.2 Integration Tests — Middleware + Bootstrap

**These use TestTokenVerifier (no JWKS mocking). Full FastAPI app with DB.**

**Auth boundary:**

| # | Scenario | Expected |
|---|----------|----------|
| 14 | No Authorization header | 401 `E_UNAUTHENTICATED` |
| 15 | Authorization header wrong format (`Basic ...`) | 401 `E_UNAUTHENTICATED` |
| 16 | Authorization header `Bearer ` (empty token) | 401 `E_UNAUTHENTICATED` |
| 17 | Invalid token (bad signature) | 401 `E_UNAUTHENTICATED` |
| 18 | Expired token | 401 `E_UNAUTHENTICATED` |
| 19 | Missing internal header (`NEXUS_ENV=staging`) | 403 `E_INTERNAL_ONLY` |
| 20 | Wrong internal header value (`NEXUS_ENV=staging`) | 403 `E_INTERNAL_ONLY` |

**Bootstrap:**

| # | Scenario | Expected |
|---|----------|----------|
| 21 | First authenticated request | User row created |
| 22 | Default library created | Exactly one, `is_default=true` |
| 23 | Default library name | `"My Library"` |
| 24 | Owner membership | Admin role, owner is user |
| 25 | Concurrent first requests | Single default library (race-safe) |
| 26 | Partial state recovery | Missing membership repaired on next request |

**GET /me:**

| # | Scenario | Expected |
|---|----------|----------|
| 27 | Valid auth | 200 with user_id and default_library_id |
| 28 | Response shape | Matches schema exactly |

---

## 10. Exit Criteria

PR-02 is complete when:
- No FastAPI endpoint (except `/health`) is reachable without auth
- Auth middleware is globally mounted
- Internal header enforced correctly by environment (constant-time comparison)
- JWT verification is correct with proper JWKS caching
- All claim validations match spec (including audience list)
- Bootstrap invariants hold under concurrency
- Auth failures are logged with structured data (never logging tokens)
- All 28 test scenarios pass deterministically
- No domain logic beyond identity/bootstrap exists
- Ready to build library CRUD in PR-03

**Tag the merge commit:** `slice-0-pr-02-complete`
