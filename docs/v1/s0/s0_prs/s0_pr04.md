# Nexus — PR-04 Spec (L3)
## Media + Fragments API + Full Slice-0 Test Suite

This PR completes Slice 0 by exposing media read APIs, seeding fixture media/fragments, and running the full Slice-0 integration test suite.  
It must conform to `s0_spec.md` and the Slice-0 PR roadmap.

---

## 0. Goal

Deliver a complete, visibility-safe **read surface** for media in Slice 0:
- Media metadata fetch
- Fragment fetch (sanitized HTML + canonical text)
- Correct 404 masking for unreadable media
- Stable fixture seeding
- Full Slice-0 test coverage

No new domain concepts are introduced.

---

## 1. Non-Goals

This PR explicitly does **not** include:
- Media ingestion
- Media creation endpoints
- Highlights, annotations, or conversations
- Search
- Jobs, storage, or processing logic
- UI changes (handled in PR-05)

---

## 2. Schema Alignment (Blocking Decision)

### 2.1 Processing Status Values

**Decision (binding):**
`media.processing_status` MUST match `s0_spec.md` values:

```
pending
extracting
ready_for_reading
embedding
ready
failed
```

**Status:** PR-01 migration spec uses these correct values. No corrective migration needed in PR-04.

Fixture media MUST use `ready_for_reading`.

### 2.2 No New Tables or Columns

PR-04 MUST NOT introduce:
- New tables
- New columns
- Any schema changes

This PR is read-only infrastructure on top of PR-01/02/03 schema.

---

## 3. New Backend Modules

### 3.1 Dependency Contract (From PR-01)

PR-04 services MUST use the error infrastructure from `app/errors.py`:

```python
from app.errors import ApiError, ApiErrorCode

# Raise errors like this:
raise ApiError(code=ApiErrorCode.E_MEDIA_NOT_FOUND, message="Media not found")
```

**Rules:**
- Do NOT invent new error classes
- Do NOT catch exceptions in service layer (let global handler wrap)
- Routes call service → service raises `ApiError` → global handler formats envelope

---

### 3.2 Media Service (NEW)

**Path:** `python/nexus/services/media.py`

**Responsibilities:**
- Visibility-safe media fetch
- Visibility-safe fragment listing
- No request/response shaping
- No FastAPI imports

**Required functions:**

```python
def get_media_for_viewer(
    db: Session,
    viewer_id: UUID,
    media_id: UUID
) -> Media:
    """
    Returns media row if readable by viewer.
    Raises ApiError(E_MEDIA_NOT_FOUND) otherwise.
    """

def list_fragments_for_viewer(
    db: Session,
    viewer_id: UUID,
    media_id: UUID
) -> list[Fragment]:
    """
    Returns ordered fragments if media is readable.
    Raises ApiError(E_MEDIA_NOT_FOUND) otherwise.
    """
```

**Query Constraints (Strict):**

**`get_media_for_viewer` — MUST be single query:**
- Execute ONE SQL query that returns a row only if readable
- Use JOIN or EXISTS to combine existence + visibility check
- Do NOT fetch media first, then call `can_read_media()` separately
- If query returns no row → raise `E_MEDIA_NOT_FOUND`

```sql
-- Correct pattern (single query):
SELECT m.* FROM media m
WHERE m.id = :media_id
AND EXISTS (
    SELECT 1 FROM library_media lm
    JOIN memberships mem ON mem.library_id = lm.library_id
    WHERE lm.media_id = m.id AND mem.user_id = :viewer_id
)
```

**`list_fragments_for_viewer` — allowed 2 queries:**
- Query 1: Check readability (same as above, or inline)
- Query 2: Fetch fragments ordered by `idx ASC`
- This is acceptable because fragments are a separate table

```sql
-- Query 1: readable check (or reuse can_read_media)
-- Query 2:
SELECT f.* FROM fragments f
WHERE f.media_id = :media_id
ORDER BY f.idx ASC
```

**Rationale:** Single-query for `get_media_for_viewer` prevents accidental error message differences and ensures no timing side-channel on existence.

---

### 3.3 Visibility Policy (If Not Already Added)

If not already present from PR-03, introduce:

**Path:** `app/policies/visibility.py`

```python
def can_read_media(db: Session, viewer_id: UUID, media_id: UUID) -> bool
```

Media service MAY inline the readable-row query instead of calling this, but visibility logic must not be duplicated elsewhere.

---

## 4. New API Routes

### 4.1 Media Routes (NEW)

**Path:** `python/nexus/api/routes/media.py`
Registered in `python/nexus/api/routes/__init__.py` via `create_api_router` (no prefix).

#### `GET /media/{media_id}`

**Behavior:**
- Returns media metadata if readable
- Returns 404 `E_MEDIA_NOT_FOUND` if:
  - Media does not exist, OR
  - Viewer cannot read it

**Response:**

```json
{
  "data": {
    "id": "uuid",
    "kind": "web_article",
    "title": "string",
    "canonical_source_url": "string | null",
    "processing_status": "ready_for_reading",
    "created_at": "iso8601",
    "updated_at": "iso8601"
  }
}
```

---

#### `GET /media/{media_id}/fragments`

**Behavior:**
- Same visibility rules as `/media/{id}`
- Ordered by `idx ASC`
- Never returns unsanitized HTML

**Response:**

```json
{
  "data": [
    {
      "id": "uuid",
      "media_id": "uuid",
      "idx": 0,
      "html_sanitized": "<p>…</p>",
      "canonical_text": "…",
      "created_at": "iso8601"
    }
  ]
}
```

---

## 5. Pydantic Schemas

**Path:** `app/schemas/media.py`

```python
class MediaOut(BaseModel):
    id: UUID
    kind: str
    title: str
    canonical_source_url: str | None
    processing_status: str
    created_at: datetime
    updated_at: datetime

class FragmentOut(BaseModel):
    id: UUID
    media_id: UUID
    idx: int
    html_sanitized: str
    canonical_text: str
    created_at: datetime
```

**Field rules:**
- No `author` field (excluded per s0_spec/PR-03)
- No extra metadata

### 5.1 Timestamp Serialization (Binding)

**Requirements:**
- All timestamps MUST be UTC
- Serialization format: ISO8601 with timezone suffix (`Z` or `+00:00`)
- Do NOT emit naive datetimes

**Source rule:**
- `created_at` and `updated_at` come from **DB columns only**
- Do NOT compute timestamps in Python (e.g., no `datetime.utcnow()`)
- Service returns ORM objects; Pydantic serializes DB values

**Test guidance:**
- Validate parseability (ISO8601 compliant)
- Do not assert exact string format unless standardized project-wide

---

## 6. Fixture Seeding (Tests + Dev)

### 6.1 Test Fixtures (Required)

**Path:** `tests/fixtures.py`

**Stable IDs (binding):**

```python
FIXTURE_MEDIA_ID    = UUID("00000000-0000-0000-0000-000000000001")
FIXTURE_FRAGMENT_ID = UUID("00000000-0000-0000-0000-000000000002")
```

**Seeded data:**
- One `web_article` media
- `processing_status = ready_for_reading`
- One fragment (`idx = 0`)
- HTML already sanitized
- Canonical text present

**Fixture HTML Content (Realistic):**

The fixture fragment MUST include realistic HTML to exercise rendering assumptions:

```python
FIXTURE_HTML_SANITIZED = """
<p>This is a <strong>seeded test article</strong> for Slice 0 validation.</p>
<p>It includes <em>inline formatting</em> and a
<a href="https://example.com/test">sample link</a>.</p>
<p>Image placeholder: <img src="https://example.com/placeholder.png" alt="Placeholder" /></p>
"""

FIXTURE_CANONICAL_TEXT = """
This is a seeded test article for Slice 0 validation.
It includes inline formatting and a sample link.
Image placeholder:
"""
```

**Why:** Even though S0 doesn't test the sanitizer or image proxy, realistic fixture content surfaces UI rendering issues early in PR-05.

**Rules:**
- Fixture media is NOT auto-added to any library
- Tests must explicitly add it via library-media endpoints
- No fixture data in migrations

---

### 6.2 Dev Seeding (Optional but Recommended)

**Path:** `scripts/seed_dev.py`

Seeds the same fixture for local UI testing.

**Constraints (mandatory):**

```python
# scripts/seed_dev.py

import os
import sys

def main():
    # 1. Environment check (hard fail)
    nexus_env = os.getenv("NEXUS_ENV", "local")
    if nexus_env not in ("local", "test"):
        print(f"ERROR: seed_dev.py refuses to run in NEXUS_ENV={nexus_env}")
        sys.exit(1)

    # 2. Idempotent seeding (ON CONFLICT DO NOTHING)
    # ... insert media ...
    # ... insert fragment ...

    # 3. Print what was done
    print(f"Seeded fixture media: {FIXTURE_MEDIA_ID}")
    print(f"Seeded fixture fragment: {FIXTURE_FRAGMENT_ID}")
```

**Rules:**
- MUST check `NEXUS_ENV` and refuse to run in `staging` or `prod`
- MUST use `ON CONFLICT DO NOTHING` for idempotency
- MUST print what it did
- Never runs automatically (manual invocation only)

---

## 7. Test Requirements (Binding)

### 7.1 Test File Layout (Mandatory)

Tests MUST be organized into these files:

| File | Scope | Scenarios |
|------|-------|-----------|
| `tests/test_auth.py` | Auth boundary | Unauthenticated, invalid token, expired token, internal header |
| `tests/test_bootstrap.py` | Identity bootstrap | `/me`, default library creation, race-safety |
| `tests/test_libraries.py` | Library CRUD + closure | Create, rename, delete, list, add/remove media |
| `tests/test_media.py` | Media/fragments endpoints | `GET /media/{id}`, `GET /media/{id}/fragments`, masking |
| `tests/test_visibility_closure.py` | Multi-user visibility | V1–V6 scenarios from s0_spec |

---

### 7.2 Test Helpers (Required)

**Path:** `tests/helpers/auth.py`

```python
from uuid import UUID

def mint_test_token(user_id: UUID, expires_in: int = 3600) -> str:
    """Mint a valid test JWT using the test keypair."""
    ...

def mint_expired_token(user_id: UUID) -> str:
    """Mint a token that expired 1 hour ago."""
    ...

def auth_headers(user_id: UUID) -> dict:
    """Return headers dict with valid Authorization."""
    return {"Authorization": f"Bearer {mint_test_token(user_id)}"}

def auth_headers_with_internal(user_id: UUID, internal_secret: str) -> dict:
    """Return headers with both auth and internal header (for staging/prod env tests)."""
    return {
        "Authorization": f"Bearer {mint_test_token(user_id)}",
        "X-Nexus-Internal": internal_secret,
    }
```

**Path:** `tests/helpers/api.py`

```python
from httpx import Response

def assert_success(response: Response, status_code: int = 200) -> dict:
    """Assert response is success envelope and return data."""
    assert response.status_code == status_code
    body = response.json()
    assert "data" in body
    return body["data"]

def assert_error(response: Response, expected_code: str, status_code: int) -> dict:
    """Assert response is error envelope with expected code."""
    assert response.status_code == status_code
    body = response.json()
    assert "error" in body
    assert body["error"]["code"] == expected_code
    return body["error"]
```

**Token minting decision (binding):**
- Tests use `TestTokenVerifier` with locally generated RS256 keypair
- No real Supabase in tests
- Test tokens exercise same validation paths as production (exp, iss, aud, sub)

---

### 7.3 FastAPI Integration Tests (20)

Must pass all 20 scenarios from `s0_spec.md §10`:

| # | Scenario | File |
|---|----------|------|
| 1 | Unauthenticated request → 401 | test_auth.py |
| 2 | Invalid token → 401 | test_auth.py |
| 3 | Missing internal header (staging) → 403 | test_auth.py |
| 4 | First login creates user + default library | test_bootstrap.py |
| 5 | Concurrent first logins are race-safe | test_bootstrap.py |
| 6 | Default library name is "My Library" | test_bootstrap.py |
| 7 | Cannot delete default library → 403 | test_libraries.py |
| 8 | Cannot rename default library → 403 | test_libraries.py |
| 9 | Admin can delete non-default library | test_libraries.py |
| 10 | Non-admin cannot delete library → 403 | test_libraries.py |
| 11 | Non-member cannot read library → 404 | test_libraries.py |
| 12 | Non-member cannot read media → 404 | test_media.py |
| 13 | Default library closure on add | test_libraries.py |
| 14 | Default library closure on remove | test_libraries.py |
| 15 | Last admin cannot be removed → 403 | test_libraries.py |
| 16 | Owner membership cannot be removed → 403 | test_libraries.py |
| 17 | Media listing has stable ordering | test_libraries.py |
| 18 | Library deletion cascades library_media | test_libraries.py |
| 19 | GET /media/{id} enforces visibility → 404 | test_media.py |
| 20 | GET /media/{id}/fragments returns content | test_media.py |

---

### 7.4 Visibility Closure Tests (6)

Must pass all 6 multi-user scenarios from `s0_spec.md §10`:

| # | Scenario | Expected |
|---|----------|----------|
| V1 | User A adds media M to library LA | A can read M |
| V2 | User B (no membership in LA) tries to read M | 404 `E_MEDIA_NOT_FOUND` |
| V3 | User A creates new library LB, does NOT add M | A can still read M (default library closure) |
| V4 | User A removes M from default library | M removed from all A's single-member libraries |
| V5 | After V4, User A tries to read M | 404 `E_MEDIA_NOT_FOUND` |
| V6 | User B adds same media M to their library | B can read M; A still cannot |

All visibility tests live in `tests/test_visibility_closure.py`.

---

### 7.5 Guarantees Under Test

- No endpoint leaks existence of unreadable media
- No endpoint ever returns unsanitized HTML
- Ordering guarantees hold (`idx ASC` for fragments, stable ordering for media list)
- Tests pass deterministically (no order dependence)
- Timestamps are valid ISO8601 with timezone

---

## 8. Error Semantics (Reaffirmed)

- Unreadable media → 404 `E_MEDIA_NOT_FOUND`
- No 403 for visibility failures
- Envelope always `{ "data": … }` or `{ "error": … }`

---

## 9. Acceptance Criteria

PR-04 is complete when:
- `python/nexus/services/media.py` exists and is used by routes
- Media + fragments routes implemented exactly as spec'd
- Schema constraint for `processing_status` matches `s0_spec`
- Fixture media + fragment seeded via pytest
- All 26 FastAPI scenarios pass (20 + 6)
- No visibility leaks
- No TODOs for Slice-0 invariants
- Ready to merge into PR-05 without backend changes

---

## 10. Explicit Non-Followups

This PR does **not**:
- Prepare for highlights
- Add search indices
- Add linked-items endpoints
- Introduce ingestion or jobs
- Touch frontend code

Those belong to later slices.
