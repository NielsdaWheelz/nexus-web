# PR-09 — Frontend Highlight Creation, Editing, Deletion, and Annotations (L3)

This PR implements user-driven highlight creation and annotation editing for
web articles, completing the Slice 2 interaction loop.

It builds on:
- PR-06 (highlight + annotation backend APIs)
- PR-07 (pure overlap segmenter)
- PR-08 (read-only highlight rendering + canonical cursor mapping)

This PR is frontend-only except for consuming existing backend endpoints.

---

## 1. Goal

Enable users to:
- Select text in a web article
- Create highlights with a fixed color palette
- Edit highlight bounds via re-selection
- Delete highlights
- Add, edit, and delete annotations
- Interact deterministically with overlapping highlights

All interactions must produce stable canonical offsets and survive reloads
without drift.

---

## 2. Non-Goals

This PR explicitly does NOT include:
- Highlight sharing
- Tags
- Drag handles for resizing highlights
- Autosave annotations
- Keyboard shortcuts beyond `Escape` and `Cmd+Enter`
- Optimistic UI updates
- Any backend changes

---

## 3. Preconditions / Assumptions

- Backend APIs from PR-06 are live and stable.
- Fragment rendering + overlap spans + anchors exist (PR-08).
- Canonical cursor mapping returns:
  ```ts
  {
    nodes: Array<{ node: Text; start: number; end: number }>;
    emitted: string;
    length: number;
  }
  ```
- `emitted === fragment.canonical_text` has already been validated in PR-08 for rendering; mismatch disables highlighting.

---

## 4. Selection → Offset Conversion

### 4.1 Canonical Offset Algorithm

Given a browser `Range`:

1. Identify `startContainer`, `startOffset`, `endContainer`, `endOffset`.

2. **Normalize backwards selections:**
   - If user drags right→left, `startContainer/startOffset` may be after `endContainer/endOffset`
   - Compare positions; swap if needed so we always have `start < end`
   - Use `Range.compareBoundaryPoints()` or position comparison

3. Look up both text nodes in the canonical cursor mapping:
   - `startNode = cursor.nodes.find(n => n.node === startContainer)`
   - `endNode = cursor.nodes.find(n => n.node === endContainer)`
   - If either lookup fails, selection is outside rendered content → abort

4. Convert UTF-16 offsets to Unicode codepoint offsets:
   ```ts
   const startLocalCp = [...startNode.node.textContent!.slice(0, startOffset)].length;
   const endLocalCp = [...endNode.node.textContent!.slice(0, endOffset)].length;
   ```

5. Compute absolute offsets:
   ```ts
   const absStart = startNode.start + startLocalCp;
   const absEnd = endNode.start + endLocalCp;
   ```

6. **Final normalization:** Ensure `absStart < absEnd` (should already be true after step 2).

### 4.2 Whitespace Normalization

Before submitting:
- Trim leading and trailing whitespace in canonical space
- Use `fragment.canonical_text.slice(absStart, absEnd)` to get exact text
- Find first non-whitespace codepoint → new `absStart`
- Find last non-whitespace codepoint → new `absEnd`
- If trimming results in an empty span (`absStart >= absEnd`), abort creation

### 4.3 Length Constraints (UI-Enforced)

After trimming:
- Minimum highlight length: 2 codepoints
- Maximum highlight length: 2000 codepoints

Selections outside these bounds are rejected with a toast.

---

## 5. Disallowed Selections

### 5.1 `<pre>` / `<code>` Intersection Detection

A selection is rejected if any spanned text node is inside `<pre>` or `<code>`.

**Algorithm:**

```ts
function selectionIntersectsCodeBlock(
  cursor: CanonicalCursorResult,
  absStart: number,
  absEnd: number
): boolean {
  // Find all text nodes whose range intersects [absStart, absEnd)
  for (const entry of cursor.nodes) {
    // Check if ranges intersect: !(entry.end <= absStart || entry.start >= absEnd)
    if (entry.start < absEnd && entry.end > absStart) {
      // Check ancestor chain for pre or code
      let el: Element | null = entry.node.parentElement;
      while (el) {
        const tag = el.tagName.toLowerCase();
        if (tag === "pre" || tag === "code") {
          return true;
        }
        el = el.parentElement;
      }
    }
  }
  return false;
}
```

**UX:** toast

> "Highlighting code blocks is not supported yet."

---

## 6. Canonical Mismatch Guard

If at any point:

```ts
cursor.emitted !== fragment.canonical_text
```

Then:
- Disable highlight creation entirely
- Render article normally (no highlights)
- Show non-fatal banner: "Highlights disabled due to content mismatch. Try reloading."

No highlight POST requests may be issued in this state.

---

## 7. Highlight Creation

### 7.1 Selection Popover Trigger

Popover appears when ALL conditions are met:
- Selection is non-collapsed (`!range.collapsed`)
- Selection is within the HtmlRenderer container element
- Not in mismatch-disabled state (§6)
- Selection passes `<pre>`/`<code>` check

### 7.2 Popover Dismissal

Popover disappears on:
- `Escape` key
- Click outside popover
- Selection collapse (e.g., user clicks elsewhere)
- Successful highlight creation

### 7.3 Popover Positioning

- Anchor to `range.getBoundingClientRect()`
- Clamp to viewport bounds (don't render offscreen)
- Position above selection if space allows, below otherwise

### 7.4 Color Selection

- Default color: `yellow` (used if user clicks "Create" without selecting a color)
- User may pick from fixed palette:
  ```
  yellow | green | blue | pink | purple
  ```

### 7.5 API Call

```
POST /fragments/{fragment_id}/highlights
```

Body:

```json
{
  "start_offset": number,
  "end_offset": number,
  "color": "yellow" | "green" | "blue" | "pink" | "purple"
}
```

### 7.6 Duplicate Span Handling (409)

If backend returns `E_HIGHLIGHT_CONFLICT`:

1. Refetch highlights for the fragment
2. Find highlight with identical `(start_offset, end_offset)` — must match the **final normalized offsets** (after trimming)
3. Focus that highlight (see §9)
4. No error surfaced to user

**Pre-check (optimization):**
- Before calling API, check if any loaded highlight has `start_offset === absStart && end_offset === absEnd`
- If match found, focus it directly without API call
- Pre-check uses the same final normalized offsets

---

## 8. Editing and Deleting Highlights

### 8.1 Focus Model

At any time, there is at most one focused highlight.

Focus determines:
- Which linked-item row is expanded
- Which annotation is visible
- Which highlight receives edit/delete actions

### 8.2 Focus Persistence After Refetch

After any highlight refetch:
- If focused highlight ID still exists in new list → keep focus
- If focused highlight ID no longer exists → clear focus
- On 409 conflict refocus → focus by matching ID
- On delete → clear focus (or optionally focus next highlight in list)

### 8.3 Editing Bounds ("Edit Mode")

- User focuses a highlight
- Clicks "Edit bounds"
- Next valid text selection replaces bounds:
  ```
  PATCH /highlights/{highlight_id}
  ```
- Same trimming, length, and `<pre>`/`<code>` rules apply
- `created_at` must remain unchanged (server handles this)

### 8.4 Color Changes

- Changing color sends PATCH with `{ color }`
- No re-selection required

### 8.5 Deletion

```
DELETE /highlights/{highlight_id}
```

- Deletes highlight
- Cascades annotation deletion (server-side)
- UI refetches highlights
- Clear focus (or focus next)

---

## 9. Overlapping Highlight Interaction

### 9.1 Click Resolution

Given a click event on a highlight span:

1. Read `data-active-highlight-ids` and `data-highlight-top`
2. First click on a segment focuses `data-highlight-top`
3. Subsequent clicks on **the same segment element** cycle through `data-active-highlight-ids` in order

### 9.2 Segment Identity

A "segment" is identified by the DOM element with `data-active-highlight-ids`:
- Track the last-clicked element reference (or use a stable key like `data-seg-key`)
- Cycling resets when clicking a different segment element

### 9.3 Focus Semantics

Focus updates:
- Linked-items pane selection
- Annotation editor target
- Optional: add `.hl-focused` class to all spans containing focused highlight ID

**Critical:** Focus changes must NOT trigger a full HTML rerender (see §11).

---

## 10. Annotation UI

### 10.1 Placement

Annotation editor lives inside the focused highlight's row in the linked-items pane.

### 10.2 API

Upsert:
```
PUT /highlights/{highlight_id}/annotation
```

Delete:
```
DELETE /highlights/{highlight_id}/annotation
```

### 10.3 UX Rules

- Plain text only
- UI max length: 10,000 characters
- Save via:
  - "Save" button, OR
  - `Cmd+Enter`
- No autosave

### 10.4 Empty Body Handling

Before saving:
- Trim annotation body (`body.trim()`)
- If trimmed body is empty string:
  - Treat as delete: call `DELETE /highlights/{highlight_id}/annotation`
  - Do NOT call PUT with empty body (backend rejects `min_length=1`)

### 10.5 Error Handling

On error:
- Keep text intact in editor
- Show toast with generic message
- Log `error.request_id` to console

---

## 11. State Management Strategy

### 11.1 No Optimistic Updates

After any mutation (create/update/delete highlight or annotation):
- Refetch highlights for the fragment
- Recompute segmenter output

### 11.2 Highlights Version Tracking

Maintain `highlightsVersion` as page-level state:

```ts
const [highlightsVersion, setHighlightsVersion] = useState(0);

// After successful mutation + refetch:
setHighlightsVersion(v => v + 1);
```

This forces recomputation of rendered HTML with highlights.

### 11.3 Render Recomputation Rules

The renderer output HTML string recomputes **only when**:
- `fragment.id` changes
- `highlightsVersion` changes (mutation/refetch)

Focus state changes update:
- Linked-items pane state
- Optional CSS class toggles via DOM query (e.g., `.hl-focused`)
- **NOT** the HtmlRenderer re-render

---

## 12. Error Handling UX

| Condition | UX |
|-----------|-----|
| Invalid range / too short / too long | Toast |
| `<pre>`/`<code>` selection | Toast |
| 409 conflict | Silent refocus |
| 404 masked | Behaves as "not found" — clear UI state |
| Network / 5xx | Toast with generic message |

### 12.1 Request ID Logging

- BFF proxy (`proxyToFastAPI`) must pass through `request_id` from error responses
- Frontend logs `error.request_id` to console on any API error
- Toast shows generic message (e.g., "Something went wrong")
- Optional: "Show details" expander revealing request ID for support

---

## 13. Tests (Vitest)

### Required Unit Tests

1. Selection → offset conversion with astral characters (emoji)
2. Leading/trailing whitespace trimming
3. Min/max length enforcement
4. `<pre>`/`<code>` rejection via cursor.nodes iteration
5. Duplicate span pre-check (must use final normalized offsets)
6. 409 conflict → refocus behavior
7. Overlap cycling order (reset on different segment)
8. Annotation save/delete flow
9. Empty annotation → delete behavior

### Additional Required Tests

10. **Backwards selection normalization:**
    - User selects right→left
    - Assert `absStart < absEnd` after normalization
    - Assert offsets match forward selection of same text

11. **Selection spanning block boundary with newlines:**
    - Selection crosses `<p>` boundary (canonical has `\n\n`)
    - Trimming preserves interior content correctly
    - Offsets account for virtual newlines

### Invariants to Assert

- No UTF-16 index leakage (test with emoji, ZWJ sequences)
- Focus changes do not trigger `renderHtmlWithHighlights()` call (spy test)
- Canonical mismatch disables creation
- Renderer recomputes only on `fragment.id` or `highlightsVersion` change

---

## 14. File Deliverables

```
apps/web/src/lib/highlights/
  ├── selectionToOffsets.ts       # Selection → offset conversion
  ├── selectionToOffsets.test.ts
  ├── useHighlightInteraction.ts  # Hook for click/focus/cycling
  └── useHighlightInteraction.test.ts

apps/web/src/components/
  ├── SelectionPopover.tsx        # Color picker + create button
  ├── HighlightEditor.tsx         # Edit bounds, color, delete
  └── AnnotationEditor.tsx        # Annotation text editor
```

---

## 15. Done Definition

PR-09 is complete when:
- Users can create, edit, delete highlights reliably
- Backwards selections work identically to forward selections
- Overlapping highlights behave deterministically (cycling resets on different segment)
- Annotations work end-to-end (including empty → delete)
- No canonical drift occurs
- All vitest tests pass in CI
- Focus changes do not cause full re-renders
- No backend changes are required
