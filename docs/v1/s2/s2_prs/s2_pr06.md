# PR-06 Spec â€” Highlights + Annotations Backend (Slice 2)

Implements highlight + annotation CRUD for web article fragments per the Slice 2 L2 spec.

This PR assumes PR-00..PR-05 are merged.

---

## 0) Goal

Ship backend support for:
- creating, listing, fetching, updating, deleting highlights
- upserting and deleting the single optional annotation per highlight
- strict validation + 404 masking for unauthorized access
- deterministic error codes (`E_HIGHLIGHT_INVALID_RANGE`, `E_HIGHLIGHT_CONFLICT`, `E_MEDIA_NOT_READY`)
- **standardize `updated_at` updates to DB time** via `func.now()` in SQLAlchemy update statements
- **add minimal ORM relationships** to simplify queries and avoid N+1

---

## 1) Non-Goals

- no library sharing / visibility beyond owner-only
- no pagination on highlight list
- no search integration
- no frontend work
- no updated_at triggers (service-layer/db-update statements only)
- no performance optimizations beyond avoiding N+1 for annotations

---

## 2) Dependencies

- Alembic rev `0003_slice2_highlights_annotations.py` exists
- Models exist: `Media`, `Fragment`, `Highlight`, `Annotation`
- Permission predicate exists: `can_read_media(db, viewer_user_id, media_id)`
- Viewer dependency exists: `Viewer(user_id, default_library_id)`
- Error framework exists: `ApiError`, `NotFoundError`, `ERROR_CODE_TO_STATUS`
- Error codes exist: `E_HIGHLIGHT_INVALID_RANGE`, `E_HIGHLIGHT_CONFLICT`, `E_MEDIA_NOT_READY`, `E_MEDIA_NOT_FOUND`, `E_NOT_FOUND`, `E_INVALID_REQUEST`

---

## 3) ORM Relationships (Add in this PR)

Add minimal relationships to `python/nexus/db/models.py`. These are schema-safe (no migration needed):

```py
# In Fragment class
media: Mapped["Media"] = relationship("Media", lazy="joined")

# In Highlight class
fragment: Mapped["Fragment"] = relationship("Fragment", lazy="joined")
annotation: Mapped["Annotation | None"] = relationship(
    "Annotation", uselist=False, back_populates="highlight", lazy="joined"
)

# In Annotation class
highlight: Mapped["Highlight"] = relationship("Highlight", back_populates="annotation")
```

Benefits:
- `fragment.media` avoids extra query in permission check
- `highlight.annotation` enables single-query list with embedded annotations
- `highlight.fragment` enables offset validation without extra query

---

## 4) Endpoints (Exact)

All routes are implemented in `python/nexus/api/routes/highlights.py`.

### Highlights
- `POST   /fragments/{fragment_id}/highlights`
- `GET    /fragments/{fragment_id}/highlights`
- `GET    /highlights/{highlight_id}`
- `PATCH  /highlights/{highlight_id}`
- `DELETE /highlights/{highlight_id}`

### Annotation (0..1 per highlight)
- `PUT    /highlights/{highlight_id}/annotation`
- `DELETE /highlights/{highlight_id}/annotation`

**Response envelope**
- success: `{ "data": <payload> }`
- error: `{ "error": { "code": "E_*", "message": "...", "request_id": "..." } }`

---

## 5) Data Contracts (Schemas)

### 5.1 Create highlight
Request schema (`schemas/highlights.py`):
```py
class HighlightCreateIn(BaseModel):
    start_offset: int = Field(..., ge=0)
    end_offset: int = Field(..., gt=0)
    color: HIGHLIGHT_COLORS
```

Response schema:

```py
class HighlightOut(BaseModel):
    id: UUID
    fragment_id: UUID
    start_offset: int
    end_offset: int
    color: HIGHLIGHT_COLORS
    exact: str
    prefix: str
    suffix: str
    created_at: datetime
    updated_at: datetime
    annotation: AnnotationOut | None
```

### 5.2 Patch highlight (partial)

```py
class HighlightUpdateIn(BaseModel):
    start_offset: int | None = Field(None, ge=0)
    end_offset: int | None = Field(None, gt=0)
    color: HIGHLIGHT_COLORS | None = None
```

### 5.3 Upsert annotation

```py
class AnnotationUpsertIn(BaseModel):
    body: str = Field(..., min_length=1)
```

Response:

```py
class AnnotationOut(BaseModel):
    id: UUID
    highlight_id: UUID
    body: str
    created_at: datetime
    updated_at: datetime
```

---

## 6) Service Layer (One function per route)

Create `python/nexus/services/highlights.py`:

### 6.1 Constants

```py
READY_STATUSES: set[str] = {"ready_for_reading", "embedding", "ready"}
```

### 6.2 Shared helpers (inside services/highlights.py)

#### 6.2.1 get_fragment_for_viewer_or_404

```py
def get_fragment_for_viewer_or_404(db: Session, viewer_id: UUID, fragment_id: UUID) -> Fragment:
    """Load fragment with eager-loaded media.

    Raises:
        NotFoundError(E_MEDIA_NOT_FOUND): If fragment doesn't exist OR viewer cannot read its media.
    """
    fragment = db.get(Fragment, fragment_id)
    if fragment is None:
        raise NotFoundError(ApiErrorCode.E_MEDIA_NOT_FOUND, "Not found")
    if not can_read_media(db, viewer_id, fragment.media_id):
        raise NotFoundError(ApiErrorCode.E_MEDIA_NOT_FOUND, "Not found")
    return fragment  # fragment.media available via relationship
```

#### 6.2.2 require_media_ready_or_409

```py
def require_media_ready_or_409(processing_status: str) -> None:
    """Raise 409 if media is not in a ready state for highlight mutations."""
    if processing_status not in READY_STATUSES:
        raise ApiError(ApiErrorCode.E_MEDIA_NOT_READY, "Media not ready")
```

#### 6.2.3 validate_offsets_or_400

**Call this BEFORE derive_exact_prefix_suffix.**

```py
def validate_offsets_or_400(canonical_text: str, start: int, end: int) -> None:
    """Validate offsets are within bounds.

    Raises:
        ApiError(E_HIGHLIGHT_INVALID_RANGE): If offsets invalid.
    """
    if start < 0 or end <= start or end > len(canonical_text):
        raise ApiError(ApiErrorCode.E_HIGHLIGHT_INVALID_RANGE, "Invalid highlight range")
```

#### 6.2.4 derive_exact_prefix_suffix

Offsets are half-open [start,end) over fragment.canonical_text in Unicode codepoints.

```py
def derive_exact_prefix_suffix(canonical_text: str, start: int, end: int) -> tuple[str, str, str]:
    """Derive exact/prefix/suffix from canonical_text using codepoint offsets.

    Assumes offsets already validated.
    """
    exact = canonical_text[start:end]
    prefix = canonical_text[max(0, start - 64):start]
    suffix = canonical_text[end:min(len(canonical_text), end + 64)]
    return exact, prefix, suffix
```

#### 6.2.5 map_integrity_error

Handle IntegrityError with constraint-name inspection:

```py
def map_integrity_error(e: IntegrityError) -> ApiError:
    """Map IntegrityError to appropriate ApiError based on constraint name."""
    constraint_name = None
    if hasattr(e.orig, "diag") and hasattr(e.orig.diag, "constraint_name"):
        constraint_name = e.orig.diag.constraint_name
    else:
        # Fallback: search exception message
        msg = str(e.orig) if e.orig else str(e)
        for name in ("uix_highlights_user_fragment_offsets", "ck_highlights_offsets_valid", "ck_highlights_color"):
            if name in msg:
                constraint_name = name
                break

    if constraint_name == "uix_highlights_user_fragment_offsets":
        return ApiError(ApiErrorCode.E_HIGHLIGHT_CONFLICT, "Highlight already exists at this range")
    if constraint_name in ("ck_highlights_offsets_valid", "ck_highlights_color"):
        return ApiError(ApiErrorCode.E_INVALID_REQUEST, "Invalid highlight data")

    # Unknown constraint â€” internal error
    return ApiError(ApiErrorCode.E_INTERNAL, "Database constraint violation")
```

#### 6.2.6 get_highlight_for_viewer_or_404

```py
def get_highlight_for_viewer_or_404(db: Session, viewer_id: UUID, highlight_id: UUID) -> Highlight:
    """Load highlight with relationships, enforce ownership and media readability.

    Raises:
        NotFoundError(E_MEDIA_NOT_FOUND): If highlight doesn't exist, not owned, or media not readable.
    """
    highlight = db.get(Highlight, highlight_id)
    if highlight is None or highlight.user_id != viewer_id:
        raise NotFoundError(ApiErrorCode.E_MEDIA_NOT_FOUND, "Not found")
    if not can_read_media(db, viewer_id, highlight.fragment.media_id):
        raise NotFoundError(ApiErrorCode.E_MEDIA_NOT_FOUND, "Not found")
    return highlight  # highlight.fragment.media and highlight.annotation available
```

---

### 6.3 Media Readiness Rules

**Operations that require media ready (depend on canonical_text correctness):**
- `create_highlight` â€” deriving exact/prefix/suffix
- `update_highlight` â€” re-deriving if offsets change
- `upsert_annotation` â€” annotation implies valid highlight state

**Operations that do NOT require media ready (allow even if status drifts):**
- `list_highlights` â€” read-only, no mutation
- `get_highlight` â€” read-only
- `delete_highlight` â€” allows cleanup even if media failed
- `delete_annotation` â€” allows cleanup

---

### 6.4 Route service functions

#### create_highlight_for_fragment

```py
def create_highlight_for_fragment(
    db: Session, viewer_id: UUID, fragment_id: UUID, req: HighlightCreateIn
) -> HighlightOut:
```

Behavior:
1. `fragment = get_fragment_for_viewer_or_404(db, viewer_id, fragment_id)`
2. `require_media_ready_or_409(fragment.media.processing_status)`
3. `validate_offsets_or_400(fragment.canonical_text, req.start_offset, req.end_offset)`
4. `exact, prefix, suffix = derive_exact_prefix_suffix(...)`
5. Create Highlight ORM object with all fields (user_id, fragment_id, offsets, color, exact/prefix/suffix)
6. `db.add(highlight); db.flush()` â€” catch IntegrityError â†’ `map_integrity_error()`
7. Return `HighlightOut` with `annotation=None`

#### list_highlights_for_fragment

```py
def list_highlights_for_fragment(
    db: Session, viewer_id: UUID, fragment_id: UUID
) -> list[HighlightOut]:
```

Behavior:
- `get_fragment_for_viewer_or_404(...)` (readability check, NO ready check)
- Query highlights where `user_id == viewer_id AND fragment_id == fragment_id`
- Eager load annotations via relationship
- Order by `start_offset ASC`, `created_at ASC`
- Return `list[HighlightOut]`

**Route wraps as:** `success_response({"highlights": [h.model_dump(...) for h in highlights]})`

#### get_highlight

```py
def get_highlight(db: Session, viewer_id: UUID, highlight_id: UUID) -> HighlightOut:
```

Behavior:
- `highlight = get_highlight_for_viewer_or_404(...)` (NO ready check)
- Return `HighlightOut` including annotation if present

#### update_highlight

```py
def update_highlight(
    db: Session, viewer_id: UUID, highlight_id: UUID, req: HighlightUpdateIn
) -> HighlightOut:
```

Behavior:
1. `highlight = get_highlight_for_viewer_or_404(...)`
2. `require_media_ready_or_409(highlight.fragment.media.processing_status)`
3. Compute final offsets by overlaying req onto existing values
4. If offsets changed:
   - `validate_offsets_or_400(...)`
   - `exact, prefix, suffix = derive_exact_prefix_suffix(...)`
   - Update highlight fields
5. If color changed: update color
6. Execute update via SQLAlchemy:
   ```py
   stmt = (
       update(Highlight)
       .where(Highlight.id == highlight_id)
       .values(..., updated_at=func.now())
       .returning(Highlight)
   )
   result = db.execute(stmt)
   db.flush()
   ```
7. Catch IntegrityError â†’ `map_integrity_error()`
8. Return updated `HighlightOut` including annotation

#### delete_highlight

```py
def delete_highlight(db: Session, viewer_id: UUID, highlight_id: UUID) -> None:
```

Behavior:
- `highlight = get_highlight_for_viewer_or_404(...)` (NO ready check â€” allow cleanup)
- `db.delete(highlight)` â€” annotation cascades via FK
- `db.flush()`

Route returns 204.

#### upsert_annotation_for_highlight

```py
def upsert_annotation_for_highlight(
    db: Session, viewer_id: UUID, highlight_id: UUID, req: AnnotationUpsertIn
) -> tuple[AnnotationOut, bool]:
    """Returns (annotation, created) where created=True if inserted, False if updated."""
```

Behavior (simple 2-step, not ON CONFLICT):
1. `highlight = get_highlight_for_viewer_or_404(...)`
2. `require_media_ready_or_409(highlight.fragment.media.processing_status)`
3. Query existing annotation: `existing = db.query(Annotation).filter_by(highlight_id=highlight_id).first()`
4. If exists:
   - Execute update:
     ```py
     stmt = (
         update(Annotation)
         .where(Annotation.highlight_id == highlight_id)
         .values(body=req.body, updated_at=func.now())
         .returning(Annotation)
     )
     ```
   - Return `(AnnotationOut, False)`
5. Else:
   - Create new Annotation, `db.add()`, `db.flush()`
   - Return `(AnnotationOut, True)`

Route returns 201 if created, 200 if updated.

#### delete_annotation_for_highlight

```py
def delete_annotation_for_highlight(db: Session, viewer_id: UUID, highlight_id: UUID) -> None:
```

Behavior:
- `highlight = get_highlight_for_viewer_or_404(...)` (NO ready check â€” allow cleanup)
- Delete annotation if exists (idempotent): `db.query(Annotation).filter_by(highlight_id=highlight_id).delete()`
- `db.flush()`

Route returns 204.

---

## 7) Routes (Transport-only)

`python/nexus/api/routes/highlights.py`:
- Define `router = APIRouter(tags=["highlights"])` (no prefix)
- Each endpoint:
  - depends on `viewer: Viewer = Depends(get_viewer)`
  - calls exactly one service function
  - wraps result with `success_response()`
  - for list: `success_response({"highlights": [...]})`
  - for annotation upsert: return 201 if created else 200

---

## 8) Error Semantics (Exact)

| Condition | Error Code | HTTP |
|-----------|------------|------|
| Invalid range/bounds | `E_HIGHLIGHT_INVALID_RANGE` | 400 |
| Check constraint violation (offsets/color) | `E_INVALID_REQUEST` | 400 |
| Uniqueness collision (same span) | `E_HIGHLIGHT_CONFLICT` | 409 |
| Media not ready | `E_MEDIA_NOT_READY` | 409 |
| Not found / not owned / not readable | `E_MEDIA_NOT_FOUND` | 404 |
| Unknown integrity error | `E_INTERNAL` | 500 |

**404 Masking:** Use `E_MEDIA_NOT_FOUND` consistently for ALL fragment/highlight/annotation 404s. This prevents probing attacks that could differentiate "doesn't exist" from "exists but not readable."

---

## 9) Tests (Pytest)

Add tests in `python/tests/`:

### 9.1 Fixtures

Create helper fixture that sets up:
- user + default library + membership
- media(kind=web_article, processing_status=ready_for_reading)
- fragment(idx=0, canonical_text with emoji: `"Hello ðŸŽ‰ World"`)
- library_media linking media to default library

### 9.2 Test cases

1. **create_highlight_success**
   - POST create highlight with valid range
   - assert exact/prefix/suffix derived correctly
   - assert annotation null

2. **create_highlight_out_of_bounds**
   - end_offset > len(canonical_text)
   - returns 400 `E_HIGHLIGHT_INVALID_RANGE`

3. **create_highlight_duplicate_conflict**
   - create same span twice
   - second returns 409 `E_HIGHLIGHT_CONFLICT`

4. **create_overlapping_allowed**
   - create overlapping highlights, both succeed

5. **list_highlights_includes_annotations**
   - create highlight + annotation
   - list returns highlight with embedded annotation

6. **get_highlight_owner_only**
   - different user tries to GET highlight â†’ 404 masked (`E_MEDIA_NOT_FOUND`)

7. **update_color_only_updates_updated_at**
   - patch color only
   - created_at unchanged
   - updated_at changes (>= previous updated_at)

8. **update_offsets_recomputes_exact**
   - patch start/end
   - exact/prefix/suffix updated and validated
   - conflict on update returns 409

9. **delete_highlight_cascades_annotation**
   - delete highlight, verify annotation removed

10. **delete_annotation_idempotent**
    - delete annotation when missing returns 204

11. **media_not_ready_blocks_create_update_upsert**
    - set media.processing_status=pending
    - create highlight â†’ 409 `E_MEDIA_NOT_READY`
    - update highlight (offsets) â†’ 409 `E_MEDIA_NOT_READY`
    - upsert annotation â†’ 409 `E_MEDIA_NOT_READY`

12. **media_not_ready_allows_list_get_delete**
    - create highlight while media ready
    - set media.processing_status=pending
    - list highlights â†’ 200 (still works)
    - get highlight â†’ 200 (still works)
    - delete highlight â†’ 204 (cleanup allowed)
    - delete annotation â†’ 204 (cleanup allowed)

13. **emoji_codepoint_slicing**
    - canonical_text contains astral char (ðŸŽ‰)
    - create highlight spanning emoji
    - exact derived correctly via Python codepoint slicing
    - (validates server uses Python string slicing, not UTF-16)

14. **cannot_highlight_without_library_membership**
    - user B not a member of library containing media
    - user B tries to create highlight â†’ 404 `E_MEDIA_NOT_FOUND`
    - user B tries to list highlights â†’ 404 `E_MEDIA_NOT_FOUND`
    - user B tries to get highlight (by id) â†’ 404 `E_MEDIA_NOT_FOUND`

15. **annotation_upsert_returns_correct_status**
    - first PUT â†’ 201
    - second PUT (update) â†’ 200

---

## 10) Completion Checklist

- [ ] ORM relationships added to `Fragment`, `Highlight`, `Annotation` models
- [ ] `READY_STATUSES` constant defined and used
- [ ] all endpoints implemented in `api/routes/highlights.py`
- [ ] all service functions exist in `services/highlights.py`
- [ ] service functions enforce: owner-only + can_read_media
- [ ] media ready enforced only for create/update/upsert (not list/get/delete)
- [ ] exact/prefix/suffix server-derived; offsets validated BEFORE deriving
- [ ] IntegrityError mapped: unique â†’ 409, check â†’ 400, unknown â†’ 500
- [ ] `updated_at` updates use `func.now()` in SQLAlchemy update statements
- [ ] all 404s use `E_MEDIA_NOT_FOUND` consistently (no probing leaks)
- [ ] `make test` passes
- [ ] `make test-migrations` passes
- [ ] no changes to frontend in this PR
