# PR-10 — Linked-Items Vertical Alignment (Highlights)

This PR implements vertically aligned linked-items for web article highlights.
It introduces a dedicated linked-items pane whose rows align to highlight
anchors in the content pane under scroll, resize, and layout shifts.

This PR completes the core "aligned linked-items" invariant required by v1.

---

## 1. Goal

Enable users to:
- See a list of highlights in a linked-items pane
- Have each list row vertically aligned to its highlight's position in the content pane
- Scroll the article and see linked-items track deterministically
- Click a linked-item to jump to its highlight

Alignment must be stable, performant, and deterministic under:
- scrolling
- resizing
- async image loading
- overlapping highlights

---

## 2. Non-Goals

This PR explicitly does NOT include:
- annotations UI expansion (rows are fixed-height)
- grouping or collapsing overlapping highlights
- leader lines or arrows
- virtualization
- E2E browser tests
- support for media kinds other than `web_article`

---

## 3. Preconditions

- PR-08 has landed:
  - Each rendered highlight inserts **exactly one**
    `<span data-highlight-anchor="{highlight_id}"></span>`
  - Anchor is placed at the highlight's start boundary
  - Rendered HTML is replaced wholesale (no incremental DOM mutation)
  - Highlight spans include `data-active-highlight-ids` (space-delimited)
- PR-09 has landed:
  - Highlights CRUD exists
  - Highlight list data is available to the frontend

---

## 4. Constants

```ts
const ROW_HEIGHT = 28;          // px, fixed row height
const ROW_GAP = 4;              // px, minimum vertical gap between rows
const SCROLL_TARGET_FRACTION = 0.2;  // fraction from top when scrolling to highlight
const MEASURE_DEBOUNCE_MS = 75; // ms, debounce interval for layout measurement
```

---

## 5. UI Structure

### 5.1 Pane Layout

PR-10 introduces a second pane:

```
PaneContainer
├── Pane (content)
│   └── .content  ← scroll container (overflow-y: auto)
│       └── HtmlRenderer
│           └── <rendered HTML with anchors>
├── Pane (linked-items)
│   └── .linkedItemsContainer
│       └── absolutely positioned rows
```

### 5.2 Linked-Items Container CSS

```css
.linkedItemsContainer {
  position: relative;
  height: 100%;
  overflow: hidden;
}

.linkedItemRow {
  position: absolute;
  left: 0;
  right: 0;
  height: 28px;  /* ROW_HEIGHT */
  will-change: transform;
}
```

### 5.3 Scroll Model

- Content pane scrolls vertically (`overflow-y: auto` on `.content`)
- Linked-items pane does NOT scroll independently
- Linked-items rows reposition based on content scroll position
- Rows that fall outside the container are clipped by `overflow: hidden`

---

## 6. Linked-Item Rows

### 6.1 Row Properties

- Fixed height: `ROW_HEIGHT = 28px`
- Minimum vertical gap: `ROW_GAP = 4px`
- One row per highlight
- Row content (v1):
  - color swatch
  - truncated exact text preview (single line)
  - hover + click affordance

### 6.2 Overflow Indicator

When rows are pushed outside the visible container:

- Display a small indicator at the bottom of `.linkedItemsContainer`:
  - "{N} more below" when rows overflow the bottom
- Indicator is optional in v1 (may be deferred) but `overflow: hidden` is required

---

## 7. Alignment Model

Alignment is computed in two phases.

### 7.1 Phase 1 — Layout Measurement

Performed when layout may have changed. Measures anchor positions in document space.

**Steps:**

For each highlight:

1. Locate anchor element:
   ```ts
   const anchor = contentRoot.querySelector(
     `[data-highlight-anchor="${highlightId}"]`
   );
   ```

2. Handle missing anchor:
   ```ts
   if (!anchor) {
     console.warn("highlight_anchor_missing", { highlightId });
     // Exclude from aligned list; row not rendered
     continue;
   }
   ```

3. Measure absolute position in document space:
   ```ts
   const anchorRect = anchor.getBoundingClientRect();
   const contentRect = contentRoot.getBoundingClientRect();
   const anchorTopInDocument = anchorRect.top - contentRect.top + contentRoot.scrollTop;
   ```

4. Cache result:
   ```ts
   anchorPositions.set(highlightId, anchorTopInDocument);
   ```

**Scheduling:**

Measurement is scheduled via:

```ts
// On initial render / highlight change:
requestAnimationFrame(() => measure());

// On resize / image load:
// Debounced, coalesces rapid events
scheduleMeasure();  // internally uses MEASURE_DEBOUNCE_MS
```

### 7.2 Measurement Triggers

| Trigger | Detection |
|---------|-----------|
| Initial render | `useEffect` on mount / highlight list change |
| Highlights added/removed | `highlightsVersion` change |
| Content pane resize | `ResizeObserver` on `.content` element |
| Linked-items pane resize | `ResizeObserver` on `.linkedItemsContainer` |
| Image load | `load`/`error` listeners on `contentRoot.querySelectorAll("img")` |
| Pane width change | Same ResizeObserver (width changes trigger reflow) |

**Image Load Listeners:**

```ts
// After render, install listeners:
const images = contentRoot.querySelectorAll("img");
images.forEach(img => {
  img.addEventListener("load", scheduleMeasure);
  img.addEventListener("error", scheduleMeasure);
});

// On cleanup, remove listeners to avoid leaks:
images.forEach(img => {
  img.removeEventListener("load", scheduleMeasure);
  img.removeEventListener("error", scheduleMeasure);
});
```

### 7.3 Phase 2 — Scroll Alignment (Per-Frame)

Runs on scroll using `requestAnimationFrame`.

**Scroll Event Wiring:**

```ts
let rafId: number | null = null;

function onScroll() {
  if (rafId === null) {
    rafId = requestAnimationFrame(() => {
      rafId = null;
      alignRows();
    });
  }
}

// Attach to content pane scroll container:
contentElement.addEventListener("scroll", onScroll, { passive: true });
```

**Alignment Computation:**

```ts
function alignRows() {
  const scrollTop = contentElement.scrollTop;

  // Compute desiredY for each highlight
  const rows = highlights.map(h => ({
    highlight: h,
    desiredY: anchorPositions.get(h.id)! - scrollTop,
  }));

  // Sort by desiredY, then canonical tie-breakers
  rows.sort((a, b) => {
    if (a.desiredY !== b.desiredY) return a.desiredY - b.desiredY;
    if (a.highlight.start !== b.highlight.start) return a.highlight.start - b.highlight.start;
    if (a.highlight.end !== b.highlight.end) return a.highlight.end - b.highlight.end;
    if (a.highlight.created_at_ms !== b.highlight.created_at_ms) {
      return a.highlight.created_at_ms - b.highlight.created_at_ms;
    }
    return a.highlight.id.localeCompare(b.highlight.id);
  });

  // Apply collision resolution
  let previousBottom = -Infinity;
  for (const row of rows) {
    row.top = Math.max(row.desiredY, previousBottom + ROW_GAP);
    previousBottom = row.top + ROW_HEIGHT;
  }

  // Apply transforms (mutate DOM refs, avoid setState per frame)
  for (const row of rows) {
    const el = rowRefs.get(row.highlight.id);
    if (el) {
      el.style.transform = `translateY(${row.top}px)`;
    }
  }
}
```

**Critical Constraint:**

The scroll loop uses **only** cached `anchorPositions` + `scrollTop`. Any `getBoundingClientRect()` call is **forbidden** inside `alignRows()`. All layout reads happen exclusively in `measure()`.

---

## 8. Collision Resolution Policy

Policy: deterministic push-down stacking, sorted by visual position.

**Algorithm:**

1. Sort rows by `desiredY` ascending (primary)
2. Tie-break by canonical order:
   - `start_offset` ASC
   - `end_offset` ASC
   - `created_at_ms` ASC
   - `highlight_id` ASC
3. For each row in sorted order:
   ```ts
   top = max(desiredY, previousBottom + ROW_GAP)
   previousBottom = top + ROW_HEIGHT
   ```
4. Store `top` for rendering

**Rationale:**

Sorting by `desiredY` first ensures the linked-items list follows the visual page order. Canonical tie-breakers provide determinism when two highlights have the same visual position (due to overlapping spans or adjacent anchors).

**Notes:**
- Rows never overlap
- Rows may be displaced downward relative to their anchor
- No leader lines in v1

---

## 9. Rendering

- Rows are absolutely positioned within `.linkedItemsContainer`
- Position applied via `transform: translateY(px)` (avoids layout thrash from `top` mutations)
- Use React refs to mutate `style.transform` directly during scroll (avoid `setState` per frame)
- Re-render React component only when:
  - `anchorPositions` change (measurement completed)
  - highlight list changes
  - NOT on every scroll frame

---

## 10. Interaction Model

### 10.1 Click

Clicking a row scrolls content pane so the highlight anchor is visible:

```ts
const anchorTop = anchorPositions.get(highlightId);
if (anchorTop !== undefined) {
  contentElement.scrollTo({
    top: anchorTop - contentElement.clientHeight * SCROLL_TARGET_FRACTION,
    behavior: "smooth"
  });
}
```

### 10.2 Hover

Hovering a row temporarily outlines all DOM segments belonging to that highlight.

**Selector Strategy (PR-08 requirement):**

PR-08 must emit highlight spans with space-delimited IDs:

```html
<span data-active-highlight-ids="id1 id2" ...>text</span>
```

On hover, use attribute token matching:

```ts
const segments = contentRoot.querySelectorAll(
  `[data-active-highlight-ids~="${highlightId}"]`
);
segments.forEach(el => el.classList.add("hl-hover-outline"));
```

On hover end, remove the class.

**Note:** Using `~=` (whitespace-delimited token match) is efficient. Do **not** use `*=` (substring match) which is slower and can match partial IDs.

---

## 11. Missing Anchor Handling

Anchors can be missing if:
- Highlight list includes a highlight for a fragment not currently rendered (future multi-fragment)
- A render bug prevented anchor insertion

**Behavior:**

- If anchor not found during measurement:
  - Exclude the row from the aligned list (do not render)
  - Log warning: `console.warn("highlight_anchor_missing", { highlightId })`
- Never crash or break other rows due to one missing anchor

---

## 12. Performance Constraints

- Must remain responsive with ≤500 highlights in a single fragment
- No synchronous DOM measurement during scroll
- No layout reads (`getBoundingClientRect`) inside scroll alignment loop
- Layout reads happen **only** in `measure()` phase
- Transforms are written to DOM refs directly, not via React state per frame
- Measurement debounced to avoid reflow storms on rapid image loads

---

## 13. Tests

### 13.1 Unit Tests (Vitest)

Pure logic only:

1. **Sort by desiredY + canonical tie-breakers:**
   - Two rows with different desiredY → sorted by desiredY
   - Two rows with same desiredY → sorted by start_offset
   - Full tie-breaker chain (start, end, created_at, id)

2. **Collision resolution (push-down):**
   - Non-overlapping rows → positions unchanged
   - Overlapping rows → pushed down with ROW_GAP
   - Push-down monotonicity: no row moves up after collision resolution

3. **desiredY computation:**
   - From cached anchor positions + scrollTop
   - Various scrollTop values

4. **Sort + push-down integration:**
   - Highlights whose canonical order differs from visual order
   - Assert final positions follow visual order with deterministic ties

5. **Missing anchor handling:**
   - Rows with missing anchors excluded from output

### 13.2 Manual Verification Checklist

- highlights remain aligned while scrolling
- alignment updates after images load
- alignment updates after pane resize
- overlapping highlights do not cause jitter
- clicking row scrolls to highlight
- hover outlines correct highlight spans
- rows that overflow bottom are clipped (not visible)

No E2E browser tests required for PR-10.

---

## 14. File Deliverables

```
apps/web/src/components/
  ├── LinkedItemsPane.tsx       # Container + row rendering
  ├── LinkedItemsPane.module.css
  └── LinkedItemRow.tsx         # Individual row component

apps/web/src/lib/highlights/
  ├── alignmentEngine.ts        # Sort, collision, transform logic
  └── alignmentEngine.test.ts
```

---

## 15. PR-08 Modification Required

PR-08 must be updated to emit space-delimited IDs for efficient hover selection:

**Change from:**
```html
<span data-highlight-ids="id1,id2" ...>
```

**Change to:**
```html
<span data-active-highlight-ids="id1 id2" ...>
```

This enables the `~=` attribute selector for O(1) token matching.

---

## 16. Acceptance Criteria

- Linked-items pane renders one row per highlight
- Rows align vertically with highlight anchors
- Alignment remains stable under scroll and resize
- Overlapping highlights resolve deterministically (by visual position, then canonical)
- No visible jank during scroll
- No infinite reflow loops
- Works with async image loading via proxy
- Missing anchors handled gracefully (row excluded, warning logged)

---

## 17. Non-Regression Guarantees

- Does not mutate sanitized HTML post-render
- Does not introduce incremental DOM mutations
- Does not affect highlight creation/edit/delete logic
- Does not affect content pane scrolling behavior

---

## 18. Future Work (Out of Scope)

- leader lines for displaced rows
- grouping overlapping highlights
- independent linked-items scrolling
- annotations expansion
- virtualization for very large highlight counts
- E2E browser tests
- "+N more below" overflow indicator (optional v1, required v2)
