# PR-07 — Frontend Highlight Overlap Segmenter (Pure)

This PR introduces a **pure, deterministic overlap segmenter** for highlights.
It performs no DOM work and has no backend dependencies.

The segmenter is the canonical frontend implementation of overlap semantics
used by PR-08 (rendering) and PR-09 (interaction).

---

## Goal

Given:
- a canonical text length (in **Unicode codepoints**)
- a list of highlight ranges

Produce:
- a deterministic set of disjoint segments
- each segment annotated with:
  - active highlight IDs (ordered by topmost comparator)
  - the "topmost" highlight (for color/rendering)

This logic must be:
- deterministic
- fast (O(n log n))
- independent of DOM or HTML
- fully unit-tested (vitest)

---

## Non-Goals

- No DOM traversal
- No HTML manipulation
- No selection handling
- No backend calls
- No Unicode parsing — offsets are trusted as codepoint indices; validation is limited to bounds checking against `textLen` (which must be codepoint length)

---

## Inputs

### NormalizedHighlight (input to segmenter)

Segmenter **does not** accept raw API objects.

All inputs must be normalized upstream.

```ts
export type HighlightColor =
  | "yellow"
  | "green"
  | "blue"
  | "pink"
  | "purple";

export type NormalizedHighlight = {
  id: string;
  start: number;      // inclusive, codepoint index
  end: number;        // exclusive, codepoint index
  color: HighlightColor;
  created_at_ms: number; // Date.parse(created_at)
};
```

### Text Length

```ts
textLen: number; // number of Unicode codepoints in canonical_text
```

**Important:** `textLen` MUST be computed using codepoint length, e.g.:

```ts
const textLen = Array.from(canonical_text).length;
```

Using `canonical_text.length` (UTF-16 code units) is forbidden.

---

## Output

```ts
export type Segment = {
  start: number;          // inclusive
  end: number;            // exclusive
  activeIds: string[];    // ordered by (created_at_ms DESC, id ASC)
  topmostId: string;
  topmostColor: HighlightColor;
};

export type SegmentResult = {
  segments: Segment[];
  droppedIds: string[];   // invalid highlights ignored
};
```

### Emitted Segments

- Only ranges with ≥1 active highlight are emitted
- Unhighlighted gaps are omitted
- Segments are disjoint and cover only highlighted ranges

---

## Topmost Highlight Rule (Binding)

Topmost highlight is chosen by:

```
(created_at_ms DESC, id ASC)
```

This rule is:
- deterministic
- stable across reloads
- resilient to equal timestamps

All ordering of `activeIds` uses the same comparator.

---

## Invalid Highlight Handling

A highlight is invalid if any of the following hold:
- `start` is not an integer
- `end` is not an integer
- `start < 0`
- `end <= start`
- `end > textLen`
- `textLen` is not a non-negative integer
- `created_at_ms` is `NaN`
- `color` not in allowed palette

### Behavior

- Invalid highlights are **dropped** (not floored, clamped, or repaired)
- Their IDs are returned in `droppedIds`
- Segmenter never throws in production

(Tests may assert on dropped IDs.)

---

## Algorithm (Event Sweep)

### Overview

1. Convert each valid highlight into two events:
   - `{ pos: start, type: "start", highlight }`
   - `{ pos: end, type: "end", highlight }`

2. Sort events by:
   1. `pos` ASC
   2. `type`: `"end"` before `"start"` (half-open ranges: `[start, end)` means an end at `pos` must remove the highlight before considering segments starting at `pos`)
   3. Highlight order: `(created_at_ms DESC, id ASC)` — ensures output is independent of input order

3. Sweep left → right:
   - Maintain active set (see Data Structure below)
   - On position change with non-empty active set, emit a segment

### Data Structure for Active Set

Since v1 targets ~200–500 highlights per fragment, use a simple approach:

- **Membership:** `Map<id, NormalizedHighlight>` for O(1) add/remove
- **On emit:** Build array from map values, sort by `(created_at_ms DESC, id ASC)`, extract IDs
- **Topmost:** First element after sort

This is O(k log k) per segment where k = active count, acceptable for typical workloads.

**Do not** iterate per-character. The algorithm processes only boundary events.

### Complexity

- Time: O(n log n) overall (n = number of highlights)
- Space: O(n)

---

## Invariants (Must Hold)

1. Segments are strictly ordered: `segments[i].end <= segments[i+1].start`
2. `segment.start < segment.end` (no zero-width segments)
3. `segment.activeIds.length >= 1`
4. `segment.topmostId ∈ segment.activeIds`
5. `segment.topmostId === segment.activeIds[0]`
6. Output does not depend on input order (deterministic)
7. **No adjacent duplicates:** No two consecutive segments may have identical `activeIds` sets (merge them)
8. **Coverage:** Union of emitted segment ranges equals union of valid highlight ranges (no holes inside overlaps)

---

## Location

```
apps/web/src/lib/highlights/
  ├── segmenter.ts
  └── segmenter.test.ts
```

---

## Public API

```ts
export function segmentHighlights(
  textLen: number,
  highlights: NormalizedHighlight[]
): SegmentResult;
```

The function must be:
- pure
- referentially transparent
- safe to memoize

---

## Tests (Vitest)

### Required Test Cases

1. **Single highlight** — one segment covering exact range
2. **Non-overlapping highlights** — multiple disjoint segments
3. **Partially overlapping highlights** — boundary splits correctly
4. **Nested highlights** — inner/outer produce 3 segments
5. **Multiple overlaps with deterministic topmost** — verify topmost by created_at_ms
6. **Equal timestamps → ID tie-break** — alphabetical ID wins
7. **Invalid highlight dropped** — out of bounds, non-integer, bad color
8. **Adjacent segments merged** — same active set doesn't produce duplicates
9. **Boundary cases** — start=0, end=textLen, touching ranges
10. **Stress test (seeded):**
    - Generate 500 highlights with seeded PRNG (e.g., seed=42)
    - Random ranges within textLen=10000
    - Assert all invariants hold
    - Do NOT assert timing (flaky in CI); O(n log n) verified by code review

### Explicit Non-Tests

- Unicode parsing correctness (offset correctness is tested in offset-mapper PRs)

---

## Done Definition

PR-07 is complete when:
- `segmentHighlights()` is implemented per spec
- All vitest tests pass in CI
- No DOM, HTML, or API dependencies exist
- Output contract is consumed unchanged by PR-08
- All 8 invariants hold for all test cases
