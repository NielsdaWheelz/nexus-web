# PR-08 â€” Frontend Read-Only Highlight Rendering (L3 Spec)

This PR implements **read-only rendering of highlights** for web articles.
Users can see previously created highlights rendered deterministically on sanitized HTML, with correct handling of overlapping spans.

This PR **does not** include selection, creation, editing, or deletion of highlights (those land in PR-09).

---

## 1. Goal

Render highlights on a web article such that:
- Highlight spans align exactly with backend `canonical_text` offsets
- Overlapping highlights render deterministically
- Rendering is stable across reloads (no drift)
- Rendering is robust (a single bad highlight does not break the document)

This PR establishes the frontend DOM-mapping and wrapping model used by all later document-like media (EPUB, transcripts).

---

## 2. Non-Goals

This PR explicitly does **not** include:
- Creating or editing highlights
- Text selection handling
- Annotation UI
- Vertical alignment of linked-items pane (PR-10)
- PDF / EPUB / transcript rendering
- Sharing or visibility logic (already enforced server-side)

---

## 3. Inputs and Dependencies

### 3.1 Backend APIs (must already exist)

- `GET /media/{id}`
- `GET /media/{id}/fragments`
  - For `web_article`, exactly one fragment (`idx = 0`)
  - Includes:
    - `html_sanitized`
    - `canonical_text`
- `GET /fragments/{fragment_id}/highlights`
  - Returns all highlights owned by the viewer for that fragment

### 3.2 Highlight Shape (normalized client-side)

```ts
type NormalizedHighlight = {
  id: string;
  start: number;        // start_offset
  end: number;          // end_offset (half-open)
  color: HighlightColor;
  created_at_ms: number;
};
```

### 3.3 Segmenter Output (from PR-07)

```ts
type Segment = {
  start: number;
  end: number;
  activeIds: string[];      // ordered by (created_at_ms DESC, id ASC)
  topmostId: string;
  topmostColor: HighlightColor;
};
```

---

## 4. Rendering Architecture (High-Level)

1. Fetch fragment (`html_sanitized`, `canonical_text`)
2. Fetch highlights â†’ normalize â†’ run segmenter
3. Build canonical cursor by walking DOM with token stream (see Â§5)
4. **Validate:** Assert `emitted === fragment.canonical_text`; if mismatch, abort highlight rendering and warn
5. Apply highlight segments by:
   - Splitting text nodes at segment boundaries
   - Wrapping text segments in `<span>` elements
6. Insert a single zero-width anchor per highlight at its start offset
7. Serialize transformed DOM â†’ render via `dangerouslySetInnerHTML`

All DOM work happens on a detached DOM tree, never mutating the live DOM incrementally.

---

## 5. Canonical Cursor Builder (Critical)

### 5.1 Purpose

The backend canonicalizer inserts characters (`\n`, `\n\n`) that do not exist in the HTML DOM.
The frontend must reproduce these insertions exactly to map offsets correctly.

### 5.2 Block Elements (must match backend exactly)

```ts
const BLOCK_ELEMENTS = new Set([
  "p", "li", "ul", "ol", "h1", "h2", "h3", "h4", "h5", "h6",
  "blockquote", "pre",
  "div", "section", "article", "header", "footer", "nav", "aside",
  "figure", "figcaption",
  "table", "tr", "td", "th"
]);
```

### 5.3 Token Stream Algorithm

The canonical cursor is built using a **token stream** to match backend behavior exactly:

**Token types:**
```ts
type Token =
  | { type: "TEXT"; text: string; node: Text }
  | { type: "BR" }
  | { type: "BLOCK_BREAK" };
```

**Emission rules (matching `canonicalize.py`):**

1. **Text nodes:** Emit `TEXT` token with:
   - Unicode NFC normalized
   - Whitespace collapsed to single spaces
   - (Trimming happens at final string level, not per-node)

2. **`<br>` element:** Emit `BR` token (represents `\n`)

3. **Block elements:** Emit `BLOCK_BREAK` token **on exit** (after processing all children)

4. **Exclusions (skip entirely, no tokens):**
   - Elements with `hidden` attribute
   - Elements with `aria-hidden="true"`
   - `<script>`, `<style>` elements

**Post-processing (collapse):**
- Adjacent `BLOCK_BREAK` tokens collapse to a single `BLOCK_BREAK`
- `BLOCK_BREAK` at start or end of stream is removed
- Then convert: `BR` â†’ `"\n"`, `BLOCK_BREAK` â†’ `"\n\n"`, `TEXT` â†’ text content

This produces the `emitted` string and computes `start`/`end` offsets for each `TEXT` token's source node.

### 5.4 Return Type

```ts
type CanonicalCursorResult = {
  nodes: Array<{
    node: Text;
    start: number;  // codepoint offset in emitted string
    end: number;    // codepoint offset (exclusive)
  }>;
  emitted: string;  // the reconstructed canonical text
  length: number;   // codepoint length of emitted
};

function buildCanonicalCursor(root: HTMLElement): CanonicalCursorResult;
```

### 5.5 Validation Gate

After building the cursor:

```ts
if (result.emitted !== fragment.canonical_text) {
  console.warn("canonical_text_mismatch", {
    fragmentId: fragment.id,
    emittedLength: result.length,
    expectedLength: Array.from(fragment.canonical_text).length,
  });
  // Abort highlight rendering for this fragment
  // Render html_sanitized without highlights
  return;
}
```

This is a **hard correctness gate**. If frontend and backend canonicalization drift, highlights will misalign. Failing loudly is better than rendering incorrectly.

---

## 6. Highlight Wrapping Strategy

### 6.1 Wrapper Element

- Use `<span>` (not `<mark>`)
- Attributes:
  - `data-highlight-ids="{activeIds.join(",")}"` â€” **must preserve segmenter ordering**
  - `data-highlight-top="{topmostId}"`
- Class:
  - `.hl-{topmostColor}` where color âˆˆ {yellow, green, blue, pink, purple}

**Reason:**
- Avoid browser default `<mark>` styles
- Full visual control
- `data-highlight-ids` ordering matches segmenter for consistent behavior

### 6.2 Text Node Splitting

For each segment:
1. Locate affected text nodes via canonical cursor
2. Split text nodes at segment boundaries (codepoint-aware)
3. Wrap only the exact range in `<span>`

Do not use `Range.surroundContents()`.

---

## 7. Overlapping Highlight Policy

- Segmenter already determines topmost highlight
- Rendering rule:
  - Background color = `segment.topmostColor`
  - All active highlights listed in `data-highlight-ids`
- Topmost selection (must match PR-07 exactly):
  - Primary: `created_at_ms` **descending** (newest wins)
  - Tie-break: `id` **ascending** (alphabetical)

Hover / interaction is deferred to PR-09.

---

## 8. Highlight Anchors (for Future Alignment)

For each highlight, insert exactly one zero-width anchor:

```html
<span data-highlight-anchor="{highlight_id}"></span>
```

### Anchor Placement Rule

The anchor is inserted at the **first segment where the highlight becomes active**:

1. Find first segment where `highlight.id âˆˆ segment.activeIds`
2. If that segment's `start === highlight.start`:
   - Insert anchor immediately before the wrapped span for that segment
3. Else:
   - Insert anchor at the position corresponding to `highlight.start` within that segment's wrapped span
4. If no segment contains the highlight (should not happen for valid highlights):
   - Do not insert anchor; log warning

**Invariant:** Exactly one anchor per highlight that was successfully rendered.

---

## 9. Failure Handling

If a highlight cannot be applied (e.g. mapping mismatch, out of bounds):
- Skip rendering that highlight
- Log a structured warning:
  ```ts
  console.warn("highlight_render_failed", { highlightId, fragmentId, reason })
  ```
- Never break document rendering

If canonical text validation fails (Â§5.5):
- Skip ALL highlight rendering for that fragment
- Render plain `html_sanitized`
- Log once per fragment

Robustness > strictness.

---

## 10. Performance Requirements

### 10.1 Memoization

DOM transform must be memoized:
- Cache key: `(fragment.id, highlights_hash)`
- Recompute only when:
  - Fragment changes (should not happen after `ready_for_reading`)
  - Highlights list changes

### 10.2 Highlights Hash (Stable)

```ts
function computeHighlightsHash(highlights: NormalizedHighlight[]): string {
  return highlights
    .map(h => `${h.id}:${h.start}:${h.end}:${h.color}:${h.created_at_ms}`)
    .sort()
    .join("|");
}
```

- Cheap to compute
- Stable across runs (sorted)
- No crypto dependency

### 10.3 Constraints

- No per-scroll or per-hover DOM mutation in this PR
- No pointer-events changes (selection must still work for PR-09)

---

## 11. Styling

Add highlight styles to a CSS module (e.g., `highlights.module.css`):

```css
/* Base highlight styles */
.hl-yellow { background: rgba(255, 235, 59, 0.5); }
.hl-green  { background: rgba(76, 175, 80, 0.4); }
.hl-blue   { background: rgba(33, 150, 243, 0.35); }
.hl-pink   { background: rgba(233, 30, 99, 0.35); }
.hl-purple { background: rgba(156, 39, 176, 0.35); }

/* Optional: subtle rounding */
[data-highlight-ids] {
  border-radius: 2px;
}

/* Anchor is invisible */
[data-highlight-anchor] {
  display: inline;
  width: 0;
  height: 0;
}
```

**Constraints:**
- No borders or outlines in v1
- No `pointer-events` changes (must not break text selection)
- Colors are suggestions; may be adjusted for theme consistency
- Keep styling minimal and overridable

---

## 12. Tests (Vitest)

Use happy-dom. Do not rely on Selection APIs.

### 12.1 Canonical Cursor Tests

1. **Block boundary insertion** â€” `\n\n` between blocks
2. **`<br>` handling** â€” single `\n`
3. **Adjacent block collapse** â€” multiple blocks â†’ single `\n\n`
4. **Hidden / `aria-hidden` exclusion** â€” no tokens emitted
5. **Codepoint length accounting for astral characters:**
   - Input HTML with emoji (e.g., `<p>Hello ðŸŽ‰ World</p>`)
   - Assert `emitted === fragment.canonical_text`
   - Assert node `start`/`end` correctly account for emoji as 1 codepoint
6. **Whitespace normalization** â€” multiple spaces â†’ single space
7. **Validation gate** â€” mismatch triggers warning and aborts

### 12.2 Segment Rendering Tests

1. Single highlight
2. Nested highlights (3 segments)
3. Partial overlaps
4. Deterministic topmost selection (verify by `created_at_ms`, then `id`)

### 12.3 DOM Output Tests

1. Correct `<span>` wrapping with expected classes
2. `data-highlight-ids` matches segmenter ordering
3. `data-highlight-top` matches `topmostId`
4. Exactly one anchor per highlight
5. Anchor at correct position (first segment where active)
6. Valid HTML output (no broken nesting)

### 12.4 Failure Handling Tests

1. Invalid highlight (out of bounds) â€” skipped, warning logged
2. Canonical mismatch â€” all highlights skipped, plain HTML rendered

---

## 13. File Deliverables

```
apps/web/src/lib/highlights/
  â”œâ”€â”€ canonicalCursor.ts       # buildCanonicalCursor()
  â”œâ”€â”€ canonicalCursor.test.ts
  â”œâ”€â”€ applySegments.ts         # applySegmentsToDom()
  â”œâ”€â”€ applySegments.test.ts
  â””â”€â”€ highlights.module.css    # .hl-* styles

apps/web/src/components/
  â””â”€â”€ HtmlRenderer.tsx         # Modified to accept pre-rendered HTML with highlights
```

### HtmlRenderer Changes

The component should accept either:
- `htmlSanitized: string` (current behavior, no highlights)
- `renderedHtml: string` (post-highlight-application HTML)

Or a single prop with the transformed HTML. Implementation detail, but the component must not perform highlight application itselfâ€”that happens upstream.

---

## 14. Done Definition

PR-08 is complete when:
- Highlights render correctly on real ingested web articles
- Canonical cursor `emitted` matches `fragment.canonical_text` for all test fixtures
- Overlapping highlights behave deterministically (topmost by `created_at_ms DESC, id ASC`)
- Emoji / Unicode offsets remain stable across reloads
- All vitest tests pass in CI
- No regressions to rendering without highlights
- Validation gate fires correctly on mismatch (tested)

---

## 15. Follow-Ups (Explicitly Deferred)

- PR-09: selection + create/update/delete highlights
- PR-10: linked-items vertical alignment
- PR-11+: reuse canonical cursor for EPUB and transcripts
