# pr-06: conversation shared-read + share routes

## goal
align conversation read contracts with s4 canonical visibility and add owner-managed conversation share routes without relaxing owner-only writes.

## context
- `docs/v1/s4/s4_roadmap.md` assigns pr-06 ownership of conversation read scopes, share endpoints, `ConversationOut` additive fields, and bff proxy parity.
- `docs/v1/s4/s4_spec.md` section 6.5 defines `scope=mine|all|shared`, shared-read endpoint behavior, ordering/cursor, and owner-only write invariants.
- `docs/v1/s4/s4_spec.md` section 6.6 defines `GET/PUT /conversations/{conversation_id}/shares` and default-library prohibition.
- `docs/v1/s4/s4_spec.md` section 3.6 requires additive `ConversationOut` fields: `owner_user_id`, `is_owner`, including send-message payloads.
- merged baseline still has gaps:
  - `python/nexus/api/routes/conversations.py` has no `scope` query and no `/shares` routes.
  - `python/nexus/services/conversations.py` list path is owner-only.
  - `python/nexus/schemas/conversation.py` lacks `owner_user_id`/`is_owner` and share-route schemas.
  - `apps/web/src/app/api/conversations/**` has no `[id]/shares` proxy route.

## dependencies
- pr-02

---

## deliverables

### `python/nexus/schemas/conversation.py`
- add `ConversationOut` fields:
  - `owner_user_id: UUID`
  - `is_owner: bool`
- keep additive compatibility: existing fields remain unchanged.
- add share-route request/response schemas:
  - `SetConversationSharesRequest` with:
    - `sharing: Literal["library"]`
    - `library_ids: list[UUID]`
  - `ConversationShareTargetOut` with:
    - `library_id: UUID`
    - `created_at: datetime`
  - `ConversationSharesOut` with:
    - `conversation_id: UUID`
    - `sharing: str`
    - `shares: list[ConversationShareTargetOut]`

### `python/nexus/schemas/__init__.py`
- re-export new conversation share schemas so route/service imports stay centralized.

### `python/nexus/auth/permissions.py`
- add a reusable conversation-visibility expression/helper used by list and point-read paths so read-auth logic remains canonical and single-sourced.
- keep `can_read_conversation(...)` semantics unchanged:
  - owner, or public, or library-share with active dual membership.

### `python/nexus/services/conversations.py`
- update `conversation_to_out(...)` to populate `owner_user_id` and viewer-local `is_owner`.
- update all `ConversationOut` construction paths to pass viewer context:
  - create conversation
  - get conversation
  - list conversations
  - send-message response path integration (via `conversation_to_out` calls from `send_message.py`)
- extend list API to support scope contract:
  - `scope="mine"`: owned only (default).
  - `scope="all"`: all visible conversations.
  - `scope="shared"`: visible but not owned.
- enforce deterministic ordering and cursor semantics exactly as l2:
  - order: `updated_at DESC, id DESC`
  - cursor tuple: `(updated_at, id)`
  - tuple ordering remains global across `mine|all|shared`.
- enforce visibility filtering before pagination:
  - `scope=all|shared` visibility predicate must be applied in SQL before cursor comparison and `LIMIT`.
  - post-fetch filtering after `LIMIT` is forbidden (breaks global cursor correctness).
- list implementation must use canonical visibility helper(s); do not introduce a parallel ad-hoc read-auth SQL path.
- keep write/send/delete owner-only logic unchanged.

### `python/nexus/services/shares.py`
- add owner-scoped service entry points for route usage:
  - `get_conversation_shares_for_owner(...)`
  - `set_conversation_shares_for_owner(...)`
- auth and masking rules for share endpoints:
  - not visible conversation -> masked `404 E_CONVERSATION_NOT_FOUND`.
  - visible conversation but caller not owner -> `403 E_OWNER_REQUIRED`.
- `PUT /shares` behavior:
  - target payload is treated as a set (dedupe duplicate `library_ids` before write).
  - replacement is atomic all-or-nothing.
  - owner must be member of every target library.
  - any default-library target fails with `403 E_CONVERSATION_SHARE_DEFAULT_LIBRARY_FORBIDDEN`.
  - preserve existing s3 share invariants (`E_SHARE_REQUIRED`, `E_SHARES_NOT_ALLOWED`) where applicable.
- deterministic share-list ordering for read path:
  - `ORDER BY library_id ASC`.
- response snapshot contract:
  - both owner share service entry points return a `ConversationSharesOut` snapshot using deterministic ordering.
- transaction ownership cleanup:
  - route/service orchestration owns transaction boundaries.
  - helper internals must not call `commit()`/`rollback()`.

### `python/nexus/api/routes/conversations.py`
- extend `GET /conversations` query contract:
  - add `scope` query with allowed values `mine|all|shared`, default `mine`.
  - perform explicit app-level scope validation (no framework-enum/422 leakage):
    - accept only exact case-sensitive tokens `mine|all|shared`.
    - invalid scope returns `400 E_INVALID_REQUEST`.
- add share routes:
  - `GET /conversations/{conversation_id}/shares`
  - `PUT /conversations/{conversation_id}/shares`
- share route response contract:
  - both routes return `success_response(ConversationSharesOut)`.
- route handlers stay transport-only (single service call, no raw sql).
- preserve existing owner-only write/send/delete route behavior.

### `python/nexus/services/send_message.py`
- ensure both send-message endpoints return updated `ConversationOut` fields by passing viewer context into `conversation_to_out(...)`.
- no mutation/auth behavior changes in send flow.

### `apps/web/src/app/api/conversations/[id]/shares/route.ts` (new)
- add next.js bff proxy route with:
  - `GET -> /conversations/{id}/shares`
  - `PUT -> /conversations/{id}/shares`
- keep existing `proxyToFastAPI` pattern and dynamic param handling.

### `apps/web/src/app/api/conversations/shares-routes.test.ts` (new)
- add route proxy tests proving `[id]/shares` handlers forward method + path exactly.

### `python/tests/test_conversations.py`
- add integration coverage for:
  - default `scope=mine` behavior.
  - invalid scope returns deterministic `400 E_INVALID_REQUEST` (never `422`).
  - `scope=all` includes visible owned + non-owned.
  - `scope=shared` returns visible not-owned only.
  - shared-reader success for:
    - `GET /conversations/{id}`
    - `GET /conversations/{id}/messages`
  - owner-only mutation paths remain denied for shared readers.
  - deterministic pagination across mixed visibility conversation sets.

### `python/tests/test_shares.py`
- add/upgrade tests for share endpoint/service semantics:
  - owner-only share management behavior.
  - visible non-owner receives `403 E_OWNER_REQUIRED`.
  - default-library target rejection with `E_CONVERSATION_SHARE_DEFAULT_LIBRARY_FORBIDDEN`.
  - duplicate `library_ids` deduped.
  - invalid target causes atomic failure (no partial share replacement).
  - `GET /shares` deterministic ordering.

### `python/tests/test_send_message.py`
- add assertions that send-message response `conversation` includes:
  - `owner_user_id`
  - `is_owner`
- cover both new-conversation and existing-conversation send paths.

---

## decision ledger

| id | question | decision | rationale | fallback/default |
|---|---|---|---|---|
| d-001 | what is pr-06 scope boundary? | restrict to conversation read scope contract, conversation share endpoints, `ConversationOut` additive fields, and bff share proxy parity. | matches l3 ownership and prevents leakage into highlight/search prs. | if additional surfaces are required, patch l3/l2 first. |
| d-002 | what does `scope=shared` include? | all visible not-owned conversations, including public + library-shared. | keeps clean set algebra: `all = mine âˆª shared`. | if product later wants `library_shared_only`, add a new explicit scope. |
| d-003 | how are share endpoint owner failures surfaced? | not-visible -> masked `404 E_CONVERSATION_NOT_FOUND`; visible non-owner -> `403 E_OWNER_REQUIRED`. | aligns with l2 masking policy (`404` for visibility failure, `403` for capability failure). | do not silently switch to masked 404 for this new endpoint family. |
| d-004 | how to handle duplicate `library_ids` in `PUT /shares`? | treat as set; dedupe before validation/write. | idempotent desired-state APIs should absorb client duplication noise. | if dedupe is removed later, l2/l3 docs must be updated first. |
| d-005 | do partial share updates apply when one target is invalid? | no; validate all targets first and apply replacement atomically. | partial success creates reconciliation ambiguity and retry hazards. | any validation failure leaves prior shares unchanged. |
| d-006 | what ordering must `GET /shares` use? | deterministic `ORDER BY library_id ASC`. | prevents non-deterministic db-return order and flaky tests. | if ui-specific ordering is needed later, add explicit sort parameter contract. |
| d-007 | how is canonical visibility reuse enforced for list/get/messages? | list/get/messages must consume canonical helper(s); no duplicate ad-hoc read-auth SQL path. | reduces auth drift and ensures search alignment in pr-08. | if helper gap exists, extend canonical helper layer first. |
| d-008 | should share helpers own commits? | no. helpers should be transaction-scoped and never call `commit()/rollback()`. | avoids partial-state risks and composes safely with route/service orchestration. | temporary compatibility wrappers are allowed only during refactor and must be removed before merge. |
| d-009 | how is `ConversationOut` additive contract kept consistent across routes? | emit `owner_user_id` and `is_owner` from one constructor path (`conversation_to_out`) reused by read/list/send-message responses. | avoids per-endpoint divergence and keeps additive evolution safe. | patch bypassing paths to use the shared constructor before merge. |
| d-010 | how do we prevent response-shape drift for new share routes? | define a concrete `ConversationSharesOut` schema and require both GET/PUT share routes to return it. | avoids endpoint divergence and simplifies bff/client consumption. | if shape changes later, patch l2/l3/l4 and tests together. |
| d-011 | how do we preserve cursor correctness for `scope=all|shared`? | apply visibility predicate in SQL before cursor + limit; forbid post-limit filtering. | post-limit filtering creates skipped/duplicated results and unstable pagination. | if canonical helper cannot express SQL predicate, add helper extension first, then use it. |
| d-012 | how do we guarantee deterministic invalid-scope behavior? | validate `scope` in application logic and return `400 E_INVALID_REQUEST` for any non-`mine|all|shared` token; do not emit framework `422`. | framework-level enum validation yields transport-dependent status/shape drift and weakens API determinism. | if validation is refactored, keep explicit contract tests asserting status/code and not-422 behavior. |

---

## traceability matrix

| l3 acceptance item | deliverable(s) | test(s) |
|---|---|---|
| `GET /conversations` supports `scope=mine|all|shared`, default `mine`. | `python/nexus/api/routes/conversations.py`; `python/nexus/services/conversations.py`; `python/nexus/auth/permissions.py` | `test_list_conversations_default_scope_is_mine`; `test_list_conversations_scope_all_includes_visible_non_owned`; `test_list_conversations_scope_shared_returns_visible_non_owned_only` |
| invalid conversation scope input is deterministic: `GET /conversations?scope=<invalid>` returns `400 E_INVALID_REQUEST` (not framework `422`). | `python/nexus/api/routes/conversations.py`; `python/nexus/services/conversations.py` | `test_list_conversations_invalid_scope_returns_400_e_invalid_request_not_422` |
| `GET /conversations/{id}` and `GET /conversations/{id}/messages` allow shared readers via canonical visibility. | `python/nexus/services/conversations.py`; `python/nexus/api/routes/conversations.py`; `python/nexus/auth/permissions.py` | `test_get_conversation_shared_reader_succeeds`; `test_list_messages_shared_reader_succeeds` |
| write/send/delete endpoints remain owner-only. | `python/nexus/services/conversations.py`; `python/nexus/api/routes/conversations.py`; `python/nexus/services/send_message.py` | `test_delete_conversation_shared_reader_still_masked_404`; `test_delete_message_shared_reader_still_masked_404`; `test_send_message_existing_conversation_non_owner_still_masked_404` |
| conversation endpoints consume pr-02 canonical helpers; no ad-hoc duplicate read-auth sql paths. | `python/nexus/auth/permissions.py`; `python/nexus/services/conversations.py` | `test_list_conversations_scope_all_uses_canonical_visibility`; `test_list_conversations_scope_all_matches_visibility_matrix` |
| share endpoints implemented: `GET/PUT /conversations/{conversation_id}/shares`. | `python/nexus/api/routes/conversations.py`; `python/nexus/services/shares.py`; `python/nexus/schemas/conversation.py`; `python/nexus/schemas/__init__.py` | `test_get_conversation_shares_owner_success`; `test_get_conversation_shares_visible_non_owner_forbidden`; `test_get_conversation_shares_non_visible_is_masked_404`; `test_put_conversation_shares_owner_success` |
| share target default-library prohibition enforced with `E_CONVERSATION_SHARE_DEFAULT_LIBRARY_FORBIDDEN`. | `python/nexus/services/shares.py`; `python/nexus/api/routes/conversations.py` | `test_put_conversation_shares_default_library_forbidden` |
| `ConversationOut` includes `owner_user_id` and `is_owner` across all serialized conversation payloads (including send-message responses). | `python/nexus/schemas/conversation.py`; `python/nexus/services/conversations.py`; `python/nexus/services/send_message.py` | `test_get_conversation_response_includes_owner_fields`; `test_list_conversations_response_includes_owner_fields`; `test_send_message_response_includes_owner_fields` |
| add matching next.js bff proxy route for conversation share endpoints. | `apps/web/src/app/api/conversations/[id]/shares/route.ts`; `apps/web/src/app/api/conversations/shares-routes.test.ts` | `test_get_conversation_shares_bff_proxy_path`; `test_put_conversation_shares_bff_proxy_path` |
| tests updated in `test_conversations.py`, `test_shares.py`, and send-message tests where conversation payload is returned. | `python/tests/test_conversations.py`; `python/tests/test_shares.py`; `python/tests/test_send_message.py` | named tests in acceptance-test section below |

---

## acceptance tests

### file: `python/tests/test_conversations.py`

**test: `test_list_conversations_default_scope_is_mine`**
- input: viewer owns `C1`, can read non-owned `C2`.
- output: `GET /conversations` (no scope param) returns only owned conversations.

**test: `test_list_conversations_invalid_scope_returns_400_e_invalid_request_not_422`**
- input: `GET /conversations?scope=ALL` and `GET /conversations?scope=invalid`.
- output: both return `400 E_INVALID_REQUEST`; response is never `422`.

**test: `test_list_conversations_scope_all_includes_visible_non_owned`**
- input: viewer owns one conversation, can read one public and one library-shared conversation.
- output: `GET /conversations?scope=all` returns all three with deterministic order.

**test: `test_list_conversations_scope_shared_returns_visible_non_owned_only`**
- input: viewer owns one conversation and can read two non-owned visible conversations.
- output: `GET /conversations?scope=shared` returns only non-owned visible conversations.

**test: `test_get_conversation_shared_reader_succeeds`**
- input: conversation shared to non-default library where viewer is member and not owner.
- output: `GET /conversations/{id}` returns `200`.

**test: `test_list_messages_shared_reader_succeeds`**
- input: same visibility setup with existing messages.
- output: `GET /conversations/{id}/messages` returns `200` and message list.

**test: `test_delete_conversation_shared_reader_still_masked_404`**
- input: viewer can read conversation via share but is not owner.
- output: `DELETE /conversations/{id}` returns masked `404 E_CONVERSATION_NOT_FOUND`.

**test: `test_list_conversations_scope_all_cursor_is_stable_across_mixed_visibility`**
- input: mixed owned/non-owned visible conversations with overlapping timestamps.
- output: paginated `scope=all` traversal has no duplicates/skips and preserves tuple ordering.

**test: `test_list_conversations_scope_all_matches_visibility_matrix`**
- input: matrix of owner/public/library-shared conversations with revoked-share and revoked-membership rows included.
- output: `scope=all` includes only rows allowed by canonical conversation visibility and excludes revoked paths.

### file: `python/tests/test_shares.py`

**test: `test_get_conversation_shares_owner_success`**
- input: owner conversation with multiple shares.
- output: `GET /conversations/{id}/shares` returns deterministic list ordered by `library_id`.

**test: `test_get_conversation_shares_visible_non_owner_forbidden`**
- input: viewer can read conversation but is not owner.
- output: `GET /conversations/{id}/shares` returns `403 E_OWNER_REQUIRED`.

**test: `test_get_conversation_shares_non_visible_is_masked_404`**
- input: viewer cannot read the conversation at all.
- output: `GET /conversations/{id}/shares` returns masked `404 E_CONVERSATION_NOT_FOUND`.

**test: `test_put_conversation_shares_owner_success`**
- input: owner sends valid non-default library target set.
- output: `PUT /conversations/{id}/shares` replaces targets atomically, updates sharing state, and returns `ConversationSharesOut`.

**test: `test_put_conversation_shares_default_library_forbidden`**
- input: payload includes default library id.
- output: `403 E_CONVERSATION_SHARE_DEFAULT_LIBRARY_FORBIDDEN`; prior shares unchanged.

**test: `test_put_conversation_shares_duplicate_library_ids_are_deduped`**
- input: payload repeats same library id.
- output: one share row exists for that library after update.

**test: `test_put_conversation_shares_invalid_target_is_atomic_no_partial_write`**
- input: payload includes one valid and one invalid (owner-not-member) target.
- output: request fails and existing share set remains unchanged.

### file: `python/tests/test_send_message.py`

**test: `test_send_message_new_conversation_includes_owner_fields`**
- input: `POST /conversations/messages` happy path.
- output: `data.conversation` includes `owner_user_id` and `is_owner=true`.

**test: `test_send_message_existing_conversation_includes_owner_fields`**
- input: `POST /conversations/{id}/messages` by owner.
- output: `data.conversation` includes `owner_user_id` and `is_owner=true`.

### file: `apps/web/src/app/api/conversations/shares-routes.test.ts`

**test: `test_get_conversation_shares_bff_proxy_path`**
- input: invoke bff `GET /api/conversations/{id}/shares`.
- output: proxies to fastapi `GET /conversations/{id}/shares`.

**test: `test_put_conversation_shares_bff_proxy_path`**
- input: invoke bff `PUT /api/conversations/{id}/shares`.
- output: proxies to fastapi `PUT /conversations/{id}/shares`.

---

## non-goals
- does not implement multi-author conversation write semantics.
- does not change highlight shared-read behavior (pr-07).
- does not change search visibility behavior (pr-08).
- does not alter public response envelope contracts.

---

## constraints
- only touch files listed in deliverables unless this spec is explicitly revised.
- preserve conversation list limit contract (`default=50`, bounds `1..100`).
- preserve deterministic invalid-scope contract (`400 E_INVALID_REQUEST`, never `422`).
- preserve masked/not-found semantics for non-visible resources.
- keep route handlers transport-only; no raw db access in routes.
- no public bff proxy routes for internal-only endpoints.

---

## boundaries (for ai implementers)

**do**:
- implement only pr-06 owned behavior.
- keep visibility logic canonical and centralized.
- add tests for every behavior-changing decision.
- preserve backward-compatible additive response evolution.

**do not**:
- implement pr-07/pr-08 scope.
- introduce partial-success semantics for share replacement.
- add duplicate read-auth sql paths for conversation visibility.
- relax owner-only mutation constraints on conversation/message writes.

---

## open questions + temporary defaults

| question | temporary default behavior | owner | due |
|---|---|---|---|
| none | n/a | n/a | n/a |

---

## checklist
- [x] every l3 acceptance bullet is in traceability matrix
- [x] every traceability row has at least one test
- [x] every behavior-changing decision has assertions
- [x] only scoped files are touched
- [x] non-goals are explicit and enforced
