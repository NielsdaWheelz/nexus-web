# pr-05: closure materialization + backfill worker + internal requeue

## goal
make closure invariants true across all writer paths and make backfill recovery operational under concurrency.

## context
- `docs/v1/s4/s4_roadmap.md` assigns closure materialization, backfill worker, and internal requeue endpoint ownership to pr-05.
- `docs/v1/s4/s4_spec.md` section 7 defines closure write rules, gc rules, worker contract, retry policy, and strict-revocation constraints.
- `docs/v1/s4/s4_spec.md` section 6.9 defines internal requeue auth, state transitions, and response contract.
- pr-02 established intrinsic write-through baseline that pr-05 must preserve.
- pr-04 established accept-path durable backfill-job upsert; pr-05 owns worker execution semantics.

## dependencies
- pr-01
- pr-02
- pr-04

---

## deliverables

### `python/nexus/services/default_library_closure.py` (new)
- add a focused service module that owns s4 closure/intrinsic/backfill invariants.
- module contract:
  - all helpers accept `Session` and are side-effect scoped to that session.
  - helpers never call `commit()`/`rollback()`; caller owns transaction boundaries.
  - all insert paths are idempotent (`ON CONFLICT DO NOTHING`).
  - lock order is explicit and consistent for worker paths:
    - claim/update `default_library_backfill_jobs`
    - lock membership row `(source_library_id, user_id)`
    - closure/materialization writes + gc
- define retry and guardrail constants exactly:
  - `BACKFILL_RETRY_DELAYS_SECONDS = (60, 300, 900, 3600, 21600)`
  - `BACKFILL_MAX_ATTEMPTS = 5`
  - `BACKFILL_PENDING_AGE_P95_GUARDRAIL_SECONDS = 900`
  - `BACKFILL_PENDING_COUNT_GUARDRAIL = 500`
- implement default-library provenance helpers used by all writer touchpoints:
  - add-to-default helper: ensure `library_media(default_library_id, media_id)` and `default_library_intrinsics(default_library_id, media_id)` exist; never writes closure edges.
  - remove-from-default helper: remove intrinsic row, then gc materialized default row iff no intrinsic and no closure edge remain.
  - add-to-non-default helper: insert closure edges for current source-library members with default libraries, then materialize default `library_media` rows from those edges.
  - remove-from-non-default helper: remove source-specific closure edges and gc affected default rows.
  - membership-removal helper: remove closure edges for `(default_library_id(target_user), *, source_library_id)` and gc affected rows.
- implement durable backfill state-machine helpers:
  - `validate_backfill_job_tuple(...)`:
    - job row exists,
    - `default_library_id` is default and owned by `user_id`,
    - `source_library_id` is non-default.
  - `claim_backfill_job_pending(...)`:
    - single atomic statement `pending -> running` with `RETURNING`.
    - missing/non-pending row returns idempotent no-op result.
  - `mark_backfill_job_completed(...)`:
    - status-guarded transition `running -> completed`.
  - `mark_backfill_job_failed(...)`:
    - status-guarded transition `running -> failed`, increment `attempts`, set `last_error_code`.
  - `reset_backfill_job_to_pending_for_retry(...)`:
    - transition `failed -> pending`, clear `finished_at`, clear `last_error_code` for retry branch.
  - retry delay selection is exact and deterministic:
    - increment attempts first; delay index is `attempts - 1`.
    - `attempts < 5` retries; `attempts >= 5` terminal failed.
  - membership gate for materialization:
    - lock membership row `(source_library_id, user_id)` before reading source media.
    - if membership absent, perform zero inserts and treat as successful completion.
- expose enqueue and guardrail helpers:
  - `enqueue_backfill_job(default_library_id, source_library_id, user_id, request_id=None, countdown=None) -> bool`
  - route task `backfill_default_library_closure_job` to queue `ingest`
  - never raises to callers; logs and returns `False` on dispatch failure
  - in test env, skip queue dispatch and return `False`
  - `get_backfill_backlog_health(db) -> {pending_count, pending_age_p95_seconds, degraded}` for s4 guardrail checks

### `python/nexus/services/libraries.py`
- replace ad hoc closure behavior in writer paths with calls to `default_library_closure.py` helpers.
- `add_media_to_library`:
  - keep admin/member auth and base source insert behavior.
  - default target: ensure intrinsic + default `library_media`, no closure edges.
  - non-default target: create closure edges + materialized default rows for all current members.
- `remove_media_from_library`:
  - remove legacy "cascade to single-member libraries" behavior.
  - default target: remove intrinsic only; preserve closure-derived state and run gc.
  - non-default target: remove source row, remove source closure edges, run gc.
- `remove_library_member`:
  - keep owner/last-admin guards and idempotent absent-member behavior.
  - preserve membership lock before delete.
  - on successful delete, run membership-removal closure cleanup + gc for removed user.
  - delete matching backfill job row `(default_library_id, source_library_id, user_id)` in same transaction.
- `_enqueue_default_library_backfill_job(...)`:
  - remove stub logging-only behavior and delegate to shared enqueue helper.

### `python/nexus/services/upload.py`
- replace direct intrinsic upsert duplication with shared helper call(s) from `default_library_closure.py`.
- keep behavior unchanged for upload flows:
  - upload init still adds to viewer default library.
  - intrinsic provenance still guaranteed.
  - default-library direct writer paths never create closure edges.

### `python/nexus/services/media.py`
- keep `/media/from_url` behavior and public contract unchanged.
- keep provisional creation path routed through shared default provenance helper.
- no ad hoc closure-edge writes in this module.

### `python/nexus/tasks/ingest_web_article.py`
- in duplicate winner attachment path, replace direct default-library + intrinsic sql with shared helper call.
- preserve existing dedupe contract (attach winner before deleting loser).

### `python/nexus/tasks/backfill_default_library_closure.py` (new)
- add celery task:
  - name: `backfill_default_library_closure_job`
  - signature: `(default_library_id: str, source_library_id: str, user_id: str, request_id: str | None = None)`
  - `max_retries=0` (retry orchestration is explicit in durable job state machine, not celery autoretry).
- task behavior:
  - parse uuid args and open worker session via `get_session_factory()`.
  - configure structured task logging with `task_name`, `task_id`, and `request_id`.
  - run tuple validation prior to materialization; invalid tuple is terminal failure path with no closure inserts.
  - claim pending durable row atomically (`pending -> running`); missing/non-pending claim returns idempotent skipped result.
  - lock membership row `(source_library_id, user_id)` before materialization.
  - if membership is absent, do zero materialization work and mark completed.
  - run materialization via service helper(s) with all inserts idempotent.
  - complete path uses status-guarded `running -> completed`.
  - failure path uses status-guarded `running -> failed`, then deterministic retry branch:
    - retriable and `attempts < 5`: reset to pending + enqueue with exact countdown.
    - non-retriable or `attempts >= 5`: leave failed for explicit operator requeue.
  - enqueue failure in retry branch is non-fatal; row stays committed `pending`.
  - emit guardrail warning logs when backlog health reports degraded.

### `python/nexus/tasks/__init__.py`
- register and export new backfill task so worker imports activate task registration:
  - add `from nexus.tasks.backfill_default_library_closure import backfill_default_library_closure_job`
  - include task in `__all__`.

### `apps/worker/main.py`
- import new backfill task in explicit task-registration block (same pattern as `ingest_web_article`).
- keep worker startup semantics unchanged otherwise.

### `python/nexus/celery.py`
- add explicit task route for `backfill_default_library_closure_job` to queue `ingest`.
- do not rely on default queue routing for backfill dispatch.

### `python/nexus/schemas/library.py`
- add internal requeue request/response schemas:
  - `RequeueDefaultLibraryBackfillJobRequest`
    - `default_library_id: UUID`
    - `source_library_id: UUID`
    - `user_id: UUID`
  - `DefaultLibraryBackfillJobOut`
    - `default_library_id: UUID`
    - `source_library_id: UUID`
    - `user_id: UUID`
    - `status: Literal["pending", "running", "completed", "failed"]`
    - `attempts: int`
    - `last_error_code: str | None`
    - `updated_at: datetime`
    - `finished_at: datetime | None`
    - `idempotent: bool`
    - `enqueue_dispatched: bool`
- export new models in module `__all__`.

### `python/nexus/schemas/__init__.py`
- re-export new internal backfill requeue request/response schemas.

### `python/nexus/api/routes/internal_libraries.py` (new)
- add internal-only endpoint:
  - `POST /internal/libraries/backfill-jobs/requeue`
- route behavior:
  - transport-only; one service call; `success_response(...)` envelope.
  - request body uses `RequeueDefaultLibraryBackfillJobRequest`.
  - response body uses `DefaultLibraryBackfillJobOut`.
  - no next.js bff proxy route.

### `python/nexus/api/routes/__init__.py`
- register new internal libraries route module in `create_api_router(...)`.
- do not add app-level one-off include for this route; keep `stream_tokens` as historical exception only.

### `python/tests/test_libraries.py`
- rewrite legacy closure assertions that conflict with s4 section 7 semantics.
- add/replace tests for library/membership writer-path invariants:
  - `test_add_media_non_default_creates_closure_edges_and_default_materialization`
  - `test_remove_media_non_default_deletes_source_edges_and_gcs_default_row`
  - `test_remove_media_from_default_removes_intrinsic_but_keeps_row_when_closure_exists`
  - `test_remove_media_from_default_row_is_gc_after_closure_removed`
  - `test_remove_library_member_deletes_member_closure_edges_and_gcs_rows`
  - `test_remove_library_member_deletes_matching_backfill_job_row`
- remove or rewrite old cascade expectation tests:
  - old behavior "remove from default cascades to single-member libraries" must not remain.

### `python/tests/test_upload.py`
- add provenance assertions for upload writer path:
  - `test_upload_init_creates_default_library_intrinsic_row`
  - `test_ingest_duplicate_keeps_winner_attached_with_intrinsic`

### `python/tests/test_from_url.py`
- add provenance assertion:
  - `test_from_url_creates_default_library_intrinsic_row`

### `python/tests/test_ingest_web_article.py`
- add dedupe-path provenance assertion:
  - `test_dedup_winner_attachment_writes_intrinsic_provenance`

### `python/tests/test_default_library_backfill.py` (new)
- add dedicated backfill worker + requeue state-machine coverage:
  - `test_backfill_worker_claims_pending_and_completes_materialization`
  - `test_backfill_worker_noops_when_job_missing_or_not_pending`
  - `test_backfill_worker_complete_and_fail_are_status_guarded`
  - `test_backfill_worker_failure_attempt_lt_5_requeues_with_expected_delay`
  - `test_backfill_worker_failure_attempt_5_stays_failed_without_requeue`
  - `test_backfill_worker_invalid_tuple_is_terminal_failed_without_retry`
  - `test_backfill_worker_does_not_materialize_when_membership_is_absent`
  - `test_backfill_worker_retry_enqueue_failure_keeps_pending_state`
  - `test_backfill_backlog_guardrail_flags_degraded_when_threshold_exceeded`
  - `test_requeue_endpoint_missing_job_returns_404_e_not_found`
  - `test_requeue_endpoint_running_job_returns_200_idempotent_noop`
  - `test_requeue_endpoint_pending_failed_completed_reset_to_pending_and_enqueue`
  - `test_requeue_endpoint_returns_operator_state_fields`
  - `test_requeue_endpoint_enqueue_failure_reports_enqueue_dispatched_false`
  - `test_requeue_endpoint_requires_internal_header_when_middleware_enforces_it`
  - `test_no_public_bff_proxy_for_internal_requeue_route`

---

## decision ledger

| id | question | decision | rationale | fallback/default |
|---|---|---|---|---|
| d-001 | what is pr-05 boundary? | closure writer touchpoints + backfill worker + internal requeue only. | aligns exactly with l3 ownership and prevents scope bleed. | if scope expands, patch roadmap/spec first. |
| d-002 | where should closure/backfill invariants live and who owns transactions? | centralize in `default_library_closure.py`; helpers never commit/rollback. | prevents sql drift and preserves clear transaction ownership. | keep module even if helper surface is trimmed. |
| d-003 | which queue should backfill use in mvp? | queue `ingest`, with explicit backlog guardrails (`p95 age > 900s` or `pending > 500` for 15m). | current workers already consume ingest; guardrails make starvation explicit. | split queue topology in later ops slice if thresholds breach. |
| d-004 | how is duplicate-delivery idempotency enforced? | claim via single atomic `pending -> running` statement with `RETURNING`; non-pending/missing is no-op. | eliminates two-step claim races. | duplicate deliveries remain no-op. |
| d-005 | how are stale worker updates blocked? | complete/fail updates are status-guarded on `running`. | prevents stale tasks from clobbering terminal state. | status mismatch returns skipped/stale result. |
| d-006 | how is retry timing encoded? | durable-state retry loop with exact delays `[60,300,900,3600,21600]`, delay index `attempts-1`, max 5 attempts. | deterministic and inspectable retry state in db. | enqueue failure after state commit is non-fatal. |
| d-007 | should worker trust task args? | no; validate tuple integrity before writes. invalid tuple is terminal failed (no inserts). | protects provenance from malformed/corrupt task inputs. | operator requeue/manual repair handles invalid tuples. |
| d-008 | how do we enforce strict revocation under concurrency? | lock membership row before materialization; missing membership completes with zero inserts. | prevents revoke/remove races from reintroducing closure edges. | if membership absent, job completes no-op. |
| d-009 | what happens to durable jobs on member removal? | delete matching backfill row during member-removal cleanup transaction. | removes obsolete intent and replay noise after revocation. | stale queued task still no-ops on claim/gates. |
| d-010 | what is authoritative default-remove behavior? | remove intrinsic + gc only; no cascade delete across non-default libraries. | old cascade behavior violates s4 section 7. | none; legacy tests must fail. |
| d-011 | how is internal requeue auth enforced? | existing global middleware/internal-header policy only; no route-local auth fork. | keeps one internal auth path and avoids policy divergence. | tighten policy centrally in middleware/deps if needed. |
| d-012 | what should requeue endpoint return? | full operator state (`status`, `attempts`, `last_error_code`, `updated_at`, `finished_at`, `idempotent`, `enqueue_dispatched`). | status-only payload is insufficient for incident triage. | if payload is reduced, patch l2/l3 before implementation. |
| d-013 | where should internal route be registered? | register through `create_api_router(...)`; no public bff proxy; `stream_tokens` app include is legacy exception. | keeps route discoverable and enforces internal-only boundary. | if router-order issue appears, explicit app include is allowed only with same contract. |

---

## traceability matrix

| l3 acceptance item | deliverable(s) | test(s) |
|---|---|---|
| all remaining closure-edge/backfill writer touchpoints are updated together (no mixed old/new closure behavior). | `python/nexus/services/default_library_closure.py`; `python/nexus/services/libraries.py`; `python/nexus/services/upload.py`; `python/nexus/services/media.py`; `python/nexus/tasks/ingest_web_article.py` | `test_add_media_non_default_creates_closure_edges_and_default_materialization`; `test_remove_media_non_default_deletes_source_edges_and_gcs_default_row`; `test_upload_init_creates_default_library_intrinsic_row`; `test_from_url_creates_default_library_intrinsic_row`; `test_dedup_winner_attachment_writes_intrinsic_provenance` |
| builds on pr-02 intrinsic write-through baseline; does not regress pr-02 rollout safety. | `python/nexus/services/default_library_closure.py`; `python/nexus/services/upload.py`; `python/nexus/services/media.py`; `python/nexus/tasks/ingest_web_article.py` | `test_upload_init_creates_default_library_intrinsic_row`; `test_from_url_creates_default_library_intrinsic_row`; `test_ingest_duplicate_keeps_winner_attached_with_intrinsic` |
| membership accept/remove and library media add/remove enforce intrinsic/closure/gc rules from spec. | `python/nexus/services/libraries.py`; `python/nexus/services/default_library_closure.py` | `test_remove_library_member_deletes_member_closure_edges_and_gcs_rows`; `test_remove_library_member_deletes_matching_backfill_job_row`; `test_remove_media_from_default_removes_intrinsic_but_keeps_row_when_closure_exists`; `test_remove_media_from_default_row_is_gc_after_closure_removed` |
| backfill worker task implements idempotent materialization and state transitions with atomic claim + status guards. | `python/nexus/tasks/backfill_default_library_closure.py`; `python/nexus/services/default_library_closure.py`; `python/nexus/tasks/__init__.py`; `apps/worker/main.py`; `python/nexus/celery.py` | `test_backfill_worker_claims_pending_and_completes_materialization`; `test_backfill_worker_noops_when_job_missing_or_not_pending`; `test_backfill_worker_complete_and_fail_are_status_guarded` |
| worker enforces tuple integrity and strict-revocation lock protocol. | `python/nexus/tasks/backfill_default_library_closure.py`; `python/nexus/services/default_library_closure.py`; `python/nexus/services/libraries.py` | `test_backfill_worker_invalid_tuple_is_terminal_failed_without_retry`; `test_backfill_worker_does_not_materialize_when_membership_is_absent` |
| automatic retries follow fixed delay schedule exactly with `delay[attempts-1]` semantics. | `python/nexus/tasks/backfill_default_library_closure.py`; `python/nexus/services/default_library_closure.py`; `python/nexus/celery.py` | `test_backfill_worker_failure_attempt_lt_5_requeues_with_expected_delay`; `test_backfill_worker_failure_attempt_5_stays_failed_without_requeue`; `test_backfill_worker_retry_enqueue_failure_keeps_pending_state` |
| queue topology remains `ingest` for s4 mvp with explicit backlog guardrails. | `python/nexus/celery.py`; `python/nexus/tasks/backfill_default_library_closure.py`; `python/nexus/services/default_library_closure.py` | `test_backfill_backlog_guardrail_flags_degraded_when_threshold_exceeded` |
| internal operator endpoint implemented: `POST /internal/libraries/backfill-jobs/requeue`. | `python/nexus/schemas/library.py`; `python/nexus/schemas/__init__.py`; `python/nexus/api/routes/internal_libraries.py`; `python/nexus/api/routes/__init__.py`; `python/nexus/services/default_library_closure.py` | `test_requeue_endpoint_missing_job_returns_404_e_not_found`; `test_requeue_endpoint_running_job_returns_200_idempotent_noop`; `test_requeue_endpoint_pending_failed_completed_reset_to_pending_and_enqueue` |
| requeue endpoint semantics: `running` -> 200 idempotent no-op (`enqueue_dispatched=false`). | `python/nexus/services/default_library_closure.py`; `python/nexus/api/routes/internal_libraries.py` | `test_requeue_endpoint_running_job_returns_200_idempotent_noop` |
| requeue endpoint semantics: `pending|failed|completed` -> `pending` + attempts reset + re-enqueue attempt. | `python/nexus/services/default_library_closure.py`; `python/nexus/api/routes/internal_libraries.py` | `test_requeue_endpoint_pending_failed_completed_reset_to_pending_and_enqueue`; `test_requeue_endpoint_enqueue_failure_reports_enqueue_dispatched_false` |
| requeue endpoint exposes operator state fields. | `python/nexus/schemas/library.py`; `python/nexus/services/default_library_closure.py`; `python/nexus/api/routes/internal_libraries.py` | `test_requeue_endpoint_returns_operator_state_fields` |
| internal endpoint requires internal-header auth path; no public bff proxy route added. | `python/nexus/api/routes/internal_libraries.py`; `python/nexus/auth/middleware.py`; `apps/web/src/app/api/**` (no new route) | `test_requeue_endpoint_requires_internal_header_when_middleware_enforces_it`; `test_no_public_bff_proxy_for_internal_requeue_route` |
| tests cover writer-path consistency and backfill/requeue state machine behavior. | `python/tests/test_libraries.py`; `python/tests/test_upload.py`; `python/tests/test_from_url.py`; `python/tests/test_ingest_web_article.py`; `python/tests/test_default_library_backfill.py` | named tests in acceptance-test section below |

---

## acceptance tests

### file: `python/tests/test_libraries.py`

**test: `test_add_media_non_default_creates_closure_edges_and_default_materialization`**
- input: owner and member both in non-default library `L`; add media `M` to `L`.
- output: `library_media(L, M)` exists; closure edges exist for both member default libraries; default materialized rows exist for both.

**test: `test_remove_media_non_default_deletes_source_edges_and_gcs_default_row`**
- input: `M` in non-default `L` with closure materialization to viewer default; no intrinsic for viewer default.
- output: after removing `M` from `L`, source closure edges are deleted and viewer default materialized row is gcâ€™d.

**test: `test_remove_media_from_default_removes_intrinsic_but_keeps_row_when_closure_exists`**
- input: viewer default has `M` via both intrinsic and active closure edge.
- output: removing `M` from default deletes intrinsic row but keeps `library_media(default, M)` while closure edge remains.

**test: `test_remove_media_from_default_row_is_gc_after_closure_removed`**
- input: viewer default has `M` via closure only after intrinsic removal.
- output: when final closure edge is removed, gc deletes `library_media(default, M)`.

**test: `test_remove_library_member_deletes_member_closure_edges_and_gcs_rows`**
- input: target member has closure-derived materialization from source library.
- output: removing membership deletes target-specific closure edges and gc removes unjustified materialized rows.

**test: `test_remove_library_member_deletes_matching_backfill_job_row`**
- input: pending/retry-able backfill row exists for `(default_library_id, source_library_id, target_user_id)` and member is removed.
- output: membership removal deletes that backfill job row in the same transaction.

### file: `python/tests/test_upload.py`

**test: `test_upload_init_creates_default_library_intrinsic_row`**
- input: authenticated upload init for file-backed media.
- output: created media is attached to default library and intrinsic row exists for `(default_library_id, media_id)`.

**test: `test_ingest_duplicate_keeps_winner_attached_with_intrinsic`**
- input: duplicate ingest path where loser is deleted and winner reused.
- output: winner remains attached to actor default library and intrinsic row exists.

### file: `python/tests/test_from_url.py`

**test: `test_from_url_creates_default_library_intrinsic_row`**
- input: `POST /media/from_url` with valid URL.
- output: `library_media(default_library_id, media_id)` and `default_library_intrinsics(default_library_id, media_id)` both exist.

### file: `python/tests/test_ingest_web_article.py`

**test: `test_dedup_winner_attachment_writes_intrinsic_provenance`**
- input: canonical-url dedupe path in ingest task for actor user.
- output: winner is attached to actor default library with intrinsic provenance row; loser deleted.

### file: `python/tests/test_default_library_backfill.py`

**test: `test_backfill_worker_claims_pending_and_completes_materialization`**
- input: pending backfill row with source media and active membership.
- output: job transitions `pending -> running -> completed`, closure edges/default materialization inserted idempotently.

**test: `test_backfill_worker_noops_when_job_missing_or_not_pending`**
- input: task invoked for missing row or non-pending row.
- output: task returns skipped/no-op; no inserts.

**test: `test_backfill_worker_complete_and_fail_are_status_guarded`**
- input: helper calls against row not in `running`.
- output: no transition occurs; stale worker cannot overwrite terminal state.

**test: `test_backfill_worker_failure_attempt_lt_5_requeues_with_expected_delay`**
- input: forced worker failure on attempt `n < 5`.
- output: row records failure, resets to `pending`, enqueue called with countdown `delay[n-1]`.

**test: `test_backfill_worker_failure_attempt_5_stays_failed_without_requeue`**
- input: forced worker failure at fifth attempt.
- output: row remains `failed`, no re-enqueue call.

**test: `test_backfill_worker_invalid_tuple_is_terminal_failed_without_retry`**
- input: job tuple where default/source/user invariants are invalid.
- output: no closure inserts; row becomes terminal failed; no auto-retry enqueue.

**test: `test_backfill_worker_does_not_materialize_when_membership_is_absent`**
- input: claimed job but membership removed before materialization.
- output: zero inserts; row marked completed; strict revocation preserved.

**test: `test_backfill_worker_retry_enqueue_failure_keeps_pending_state`**
- input: retry branch where enqueue dispatch raises.
- output: row remains committed `pending` with reset fields; no rollback.

**test: `test_backfill_backlog_guardrail_flags_degraded_when_threshold_exceeded`**
- input: synthetic pending row distribution exceeding age/count guardrails.
- output: guardrail helper returns `degraded=true` with expected counts/age.

**test: `test_requeue_endpoint_missing_job_returns_404_e_not_found`**
- input: POST requeue for absent row.
- output: `404 E_NOT_FOUND`.

**test: `test_requeue_endpoint_running_job_returns_200_idempotent_noop`**
- input: POST requeue for row currently `running`.
- output: `200`, unchanged running state, `idempotent=true`, `enqueue_dispatched=false`.

**test: `test_requeue_endpoint_pending_failed_completed_reset_to_pending_and_enqueue`**
- input: POST requeue for each of `pending`, `failed`, `completed`.
- output: each resets to `pending` with attempts/error/finished reset, and enqueues once.

**test: `test_requeue_endpoint_returns_operator_state_fields`**
- input: successful requeue call.
- output: response includes `status`, `attempts`, `last_error_code`, `updated_at`, `finished_at`, `idempotent`, `enqueue_dispatched`.

**test: `test_requeue_endpoint_enqueue_failure_reports_enqueue_dispatched_false`**
- input: requeue path with enqueue dispatch failure.
- output: committed pending state returned with `enqueue_dispatched=false`.

**test: `test_requeue_endpoint_requires_internal_header_when_middleware_enforces_it`**
- input: endpoint under `requires_internal_header=True` with missing/invalid header.
- output: `403 E_INTERNAL_ONLY`; valid header succeeds.

**test: `test_no_public_bff_proxy_for_internal_requeue_route`**
- input: static file scan of `apps/web/src/app/api/**`.
- output: no proxy route exists for `/internal/libraries/backfill-jobs/requeue`.

---

## non-goals
- does not change public user-facing endpoint contracts beyond pr-05 ownership.
- does not add frontend/operator ui tooling.
- does not implement conversation/highlight/search behavior owned by pr-06/pr-07/pr-08.

---

## constraints
- only touch files listed in deliverables unless this spec is explicitly revised.
- preserve masked/not-found and internal-auth semantics from l2.
- no public next.js bff proxy route for internal requeue endpoint.
- do not introduce alternate media read-auth predicates; `can_read_media` remains authoritative.
- enforce lock ordering and status-guarded transitions exactly as specified.

---

## boundaries (for ai implementers)

**do**:
- implement only behaviors required by pr-05 acceptance bullets.
- keep writer-path behavior consistent across all touched write surfaces.
- add tests for every behavior-changing decision.
- preserve immediate-read access invariant (backfill remains closure materialization, not read auth gating).

**do not**:
- implement features owned by pr-06 or later prs.
- add ad hoc alternate closure/auth logic paths.
- change external contracts not owned by pr-05.
- add a public bff proxy for `/internal/libraries/backfill-jobs/requeue`.

---

## open questions + temporary defaults

| question | temporary default behavior | owner | due |
|---|---|---|---|
| none | n/a | n/a | n/a |

---

## checklist
- [x] every l3 acceptance bullet is in traceability matrix
- [x] every traceability row has at least one test
- [x] every behavior-changing decision has assertions
- [x] only scoped files are touched
- [x] non-goals are explicit and enforced
