# Nexus — L3 PR Spec: S1 · PR-03

**Processing Status · Capability Derivation · Media List**

This PR formalizes **viewer-scoped capabilities**, clarifies **processing semantics**, and introduces the first **list endpoint**. It does not add extractors, jobs, or new media kinds.

PR-03 is the contract that downstream UI and later slices rely on. If this is wrong, everything after it is wrong.

---

## 0) Preconditions (Must Be True Before Merge)

- PR-01 merged:
  - S1 migration applied (`media` fields, enums, `media_file`)
- PR-02 merged:
  - `can_read_media_bulk`
  - admin predicates
  - request-id propagation
- `GET /media/{id}` exists and returns a stable envelope
- No extractors are active (S1 invariant)

If any precondition is false, **this PR blocks**.

---

## 1) Goals

- Define a **single source of truth** for what a viewer can do with a media item
- Make UI behavior depend on **capabilities**, not raw status fields
- Add a **default-library media list** endpoint with pagination
- Encode the PDF exception cleanly without leaking S6 assumptions

---

## 2) Non-Goals

- No extraction
- No enqueueing jobs
- No search
- No sharing
- No schema changes (beyond PR-01)

---

## 3) Terminology

- **Viewer**: authenticated user making the request
- **Authorized**: viewer has library access via `can_read_media` (permission predicate)
- **Capability**: a derived boolean describing an allowed interaction **given current processing state**

**Critical distinction:**
- Authorization = "viewer may access this media object at all" (library membership)
- Capability = "viewer can perform this action now" (content state)

The endpoint enforces authorization. Capabilities describe what's possible once authorized.

---

## 4) Capability Model (Hard Contract)

Capabilities are **viewer-scoped** and **derived**, never stored.

### Capability Object

Returned by all media read/list endpoints:

```json
"capabilities": {
  "can_read": false,
  "can_highlight": false,
  "can_quote": false,
  "can_search": false,
  "can_play": false,
  "can_download_file": false
}
```

**Semantic clarification:**
- `can_read` means "content is renderable now," not "viewer is authorized"
- Authorization is a precondition; if unauthorized, the endpoint returns 404 before capabilities are computed

### Inputs (Only These)

Capabilities are derived only from:

- `media.kind` (enum)
- `media.processing_status` (enum)
- `media.last_error_code` (text, nullable)
- `media_file_exists` := `media_file` row exists for this media_id (boolean)
- `external_playback_url_exists` := `media.external_playback_url IS NOT NULL` (boolean)

No other fields may influence capability logic.

**Note:** `media_file_exists` checks DB row existence only, not storage object existence. Storage integrity is enforced at download time in `GET /media/{id}/file`.

---

## 5) Capability Rules (Authoritative)

### Global Rules (All Kinds)

- `can_download_file` = true iff `media_file_exists`
- `can_play` = true iff `external_playback_url_exists`

**Rationale for `can_play`:** Playback should work whenever a valid URL exists, regardless of processing status. This is user-friendly (play while transcript ingests) and doesn't violate any invariants. Transcript-dependent features (`can_read`, `can_highlight`, etc.) are gated separately.

### Web Article / EPUB

| Capability | Rule |
|------------|------|
| `can_read` | `processing_status >= ready_for_reading` |
| `can_highlight` | same as `can_read` |
| `can_quote` | same as `can_read` |
| `can_search` | same as `can_read` |

### PDF (S1 Special Case)

PDFs are readable as soon as the file exists (pdf.js can render).

| Capability | Rule |
|------------|------|
| `can_read` | `media_file_exists` |
| `can_highlight` | same as `can_read` (geometry-based) |
| `can_quote` | false in S1 |
| `can_search` | false in S1 |

**Rationale:** `plain_text` does not exist yet. `can_quote` and `can_search` flip to true in S6 when text extraction is complete.

### Podcast Episode / Video

| Capability | Rule |
|------------|------|
| `can_read` | `processing_status >= ready_for_reading` (transcript exists) |
| `can_highlight` | same as `can_read` |
| `can_quote` | same as `can_read` |
| `can_search` | same as `can_read` |
| `can_play` | see Global Rules (`external_playback_url_exists`) |

**Playback-only mode:** When transcript is unavailable:
- `processing_status = failed`, `last_error_code = E_TRANSCRIPT_UNAVAILABLE`
- `can_play = true` (if URL exists), all other capabilities `false`

---

## 6) Capability Derivation Function

### Signature

```python
def derive_capabilities(
    media: Media,
    *,
    media_file_exists: bool,
    external_playback_url_exists: bool,
) -> dict[str, bool]
```

### Rules

- Pure function
- No DB access
- Caller must have already verified authorization (permission predicate)
- If authorization fails, endpoint returns 404 and never calls this
- `can_read` means "content renderable now," not "authorized"

---

## 7) Response DTOs (Authoritative)

### MediaOut (for GET /media/{id})

```python
class MediaOut(BaseModel):
    id: UUID
    kind: MediaKind
    title: str
    canonical_url: str | None
    requested_url: str | None
    processing_status: ProcessingStatus
    last_error_code: str | None
    created_at: datetime
    capabilities: CapabilitiesOut

class CapabilitiesOut(BaseModel):
    can_read: bool
    can_highlight: bool
    can_quote: bool
    can_search: bool
    can_play: bool
    can_download_file: bool
```

### MediaListItemOut (for GET /media)

```python
class MediaListItemOut(BaseModel):
    id: UUID
    kind: MediaKind
    title: str
    processing_status: ProcessingStatus
    last_error_code: str | None
    created_at: datetime
    capabilities: CapabilitiesOut
```

**Explicitly excluded from list response:**
- `canonical_url` (use detail endpoint)
- `requested_url` (use detail endpoint)

---

## 8) GET /media/{id} (Refactor)

### Behavior

- Enforce `can_read_media(viewer, media_id)` → failure returns 404
- Query `media_file` existence
- Compute capabilities via `derive_capabilities`
- Return `MediaOut` nested in `data`

### Response

```json
{
  "data": {
    "id": "...",
    "kind": "pdf",
    "title": "Document.pdf",
    "canonical_url": null,
    "requested_url": null,
    "processing_status": "pending",
    "last_error_code": null,
    "created_at": "2026-01-21T00:00:00Z",
    "capabilities": {
      "can_read": true,
      "can_highlight": true,
      "can_quote": false,
      "can_search": false,
      "can_play": false,
      "can_download_file": true
    }
  }
}
```

---

## 9) GET /media (New Endpoint)

### Scope

- Returns media in viewer's default library only
- Ordered newest-first (`created_at DESC, id DESC`)

### Query Strategy

Join `library_media` on viewer's default library. Items are readable by construction (default library membership guarantees access via closure invariant).

**Do not** filter via `can_read_media_bulk`; the join already ensures readability. Redundant predicate checks mask bugs and add latency.

**Diagnostic test:** Verify in tests that all returned IDs pass `can_read_media_bulk` (assertion, not filtering).

### Pagination

Keyset pagination on `(created_at, id)`:

| Parameter | Type | Default | Max | Notes |
|-----------|------|---------|-----|-------|
| `limit` | int | 50 | 200 | Items per page |
| `cursor` | string | null | - | Opaque pagination token |

Cursor is base64-encoded JSON:

```json
{ "created_at": "2026-01-21T00:00:00Z", "id": "uuid-here" }
```

**Error handling:**
- Invalid cursor (malformed, tampered) → `400 E_INVALID_CURSOR`
- `limit` < 1 or > 200 → `400 E_INVALID_LIMIT`

### Response

```json
{
  "data": {
    "items": [
      {
        "id": "...",
        "kind": "web_article",
        "title": "Article Title",
        "processing_status": "pending",
        "last_error_code": null,
        "created_at": "2026-01-21T00:00:00Z",
        "capabilities": { ... }
      }
    ],
    "next_cursor": "eyJjcmVhdGVkX2F0Ijoi..."
  }
}
```

`next_cursor` is `null` if no more items.

---

## 10) Error Semantics

- Non-readable media → 404 (authorization failure)
- Invalid cursor → 400 `E_INVALID_CURSOR`
- Invalid limit → 400 `E_INVALID_LIMIT`
- Capabilities are never returned for unreadable items
- No partial visibility

---

## 11) Tests (Required)

### Unit Tests (derive_capabilities)

- Capability matrix:
  - all kinds × relevant statuses
  - verify exact boolean values
- PDF exception:
  - file exists + `pending` → `can_read=true`, `can_quote=false`
  - file not exists + `pending` → `can_read=false`
- Playback:
  - `external_playback_url` exists → `can_play=true` (any status)
  - `external_playback_url` null → `can_play=false`
- Playback-only mode:
  - `failed` + `E_TRANSCRIPT_UNAVAILABLE` + url exists → `can_play=true`, `can_read=false`

### API Tests

#### GET /media/{id}

- Readable → 200 + capabilities
- Non-readable → 404
- Response matches `MediaOut` schema

#### GET /media

- Only default library media returned
- Pagination works (forward traversal)
- Invalid cursor → 400 `E_INVALID_CURSOR`
- `limit=0` → 400 `E_INVALID_LIMIT`
- `limit=500` → 400 `E_INVALID_LIMIT`
- Capabilities present on all items
- **Diagnostic assertion:** all returned IDs pass `can_read_media_bulk`

---

## 12) Invariants

- UI must depend on capabilities, never raw status
- Capabilities are viewer-scoped and derived
- No extractors or state transitions in PR-03
- No schema changes in PR-03
- Authorization and capability are distinct concepts

---

## 13) Definition of Done

- All tests pass
- No N+1 permission queries
- Capability logic matches this spec exactly
- No capability rules outside `derive_capabilities`
- DTOs match spec exactly (`MediaOut`, `MediaListItemOut`)

PR-03 is complete when capability semantics are locked and boring.
