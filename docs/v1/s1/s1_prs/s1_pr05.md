# Nexus — L3 PR Spec: S1 · PR-05  
**Lifecycle + Retry + URL Media + Celery Tasks**

This PR makes the ingestion framework *real* by implementing lifecycle transitions, retry semantics, URL-based media creation, and Celery task definitions — **without enqueueing extractors**.

This PR is the final structural PR of Slice 1. After this lands, the system can safely support all future extractors without refactors.

---

## 1) Goals

- Implement the **media lifecycle state machine**
- Implement **retry semantics** (state reset, no residue)
- Add **URL-based media creation** (`web_article`, `video`)
- Define **Celery task skeletons** with safety guarantees
- Finalize the **Processing-State integration test suite**

**Non-goals:**
- No real extraction
- No fragments created
- No automatic task enqueueing
- No podcast episode creation (handled in S7 only)

---

## 2) Scope

### In Scope
- Lifecycle service functions
- Retry endpoint
- URL media creation endpoint
- URL validation + canonicalization
- YouTube URL normalization + ID extraction
- Celery task definitions (safe no-op)
- Processing-state integration tests

### Out of Scope
- Any extractor logic
- Fragment creation
- **Automatic task enqueueing** (tasks exist but are never auto-enqueued in S1)
- Podcast episode creation
- UI beyond retry + status badge

### Clarification: Tasks vs Enqueueing

| What | S1 Status |
|------|-----------|
| Celery task definitions (`ingest_media`) | **Exist** — fully implemented with safety guards |
| `maybe_enqueue_extraction()` | **Exists** — always returns `False` (no extractors) |
| Automatic task enqueueing | **Never happens** — `AVAILABLE_EXTRACTORS` is empty |
| Task invocation in tests | **Allowed** — via `ingest_media.apply()` in eager mode |

**S1 invariant:** No task is ever enqueued in production or normal operation. Tasks are exercised only in tests using Celery eager mode.

---

## 3) Lifecycle Service Functions

**Location:** `python/nexus/services/media_lifecycle.py`

All lifecycle mutations are centralized here.  
**Service functions never commit**; callers own transactions.

```python
def worker_start_attempt(session, media_id: UUID) -> bool:
    """
    pending → extracting

    Returns: True if transitioned, False if no-op

    BEHAVIOR:
    - SELECT ... FOR UPDATE
    - If status != pending: log "worker_start_attempt_noop" + return False
    - ONLY IF transitioning:
        - Increment processing_attempts
        - Set processing_started_at = now
        - Set processing_status = extracting
        - Return True

    NOTE: processing_attempts is incremented ONLY when transition happens,
    not on duplicate deliveries or retries hitting wrong state.
    """

def mark_ready_for_reading(session, media_id: UUID) -> None:
    """
    extracting → ready_for_reading

    SAFETY:
    - SELECT ... FOR UPDATE
    - If status != extracting: log "unexpected_state" + no-op (don't raise)
    - Celery retries and duplicate deliveries happen; crashes are worse than no-ops

    BEHAVIOR (if status == extracting):
    - Set processing_status = ready_for_reading
    - Set processing_completed_at = now
    """

def mark_failed(
    session,
    media_id: UUID,
    stage: FailureStage,
    error_code: str,
    error_message: str,
) -> None:
    """
    any → failed (with late-failure protection)

    SAFETY:
    - SELECT ... FOR UPDATE
    - If status in {ready, ready_for_reading}:
        - Log "late_failure_ignored" with media_id, error_code
        - No-op (do NOT clobber successful state)
    - A buggy retry marking a now-ready media as failed would corrupt data

    BEHAVIOR (if status NOT in {ready, ready_for_reading}):
    - Set processing_status = failed
    - Set failure_stage, last_error_code, last_error_message
    - Set failed_at = now
    """

def retry_media(session, media_id: UUID, actor_user_id: UUID) -> None:
    """
    API-callable reset only (no enqueue in S1)

    PRECONDITIONS:
    - processing_status MUST be 'failed'
    - If status != failed: raise ApiError(E_INVALID_STATE, 409)
    - Actor must be creator OR admin of any containing library

    BEHAVIOR:
    - SELECT ... FOR UPDATE
    - Apply reset rules per failure_stage
    - Set processing_status = pending
    - Clear:
        failure_stage
        last_error_code
        last_error_message
        failed_at
        processing_started_at
        processing_completed_at
    """

**Invariant:** No partial state survives retry.
**Invariant:** Retry only recovers from failure — it never resets pending/extracting/ready states.

---

## 4) Extractor Registry + Enqueue Guard

**Location:** `python/nexus/services/extractors.py`

```python
AVAILABLE_EXTRACTORS: dict[MediaKind, Callable] = {}

def can_extract(kind: MediaKind) -> bool:
    return kind in AVAILABLE_EXTRACTORS

def maybe_enqueue_extraction(
    media_kind: MediaKind,
    media_id: UUID,
    request_id: str | None,
) -> bool:
    """
    Enqueue extraction task only if extractor exists.
    Returns True if enqueued, False otherwise.

    NOTE: No session param — this function is pure.
    - Does NOT read from DB (caller already has media_kind)
    - Does NOT write to DB (task enqueue is external)
    - Keeps task enqueue outside request transaction scope
    """
    if not can_extract(media_kind):
        return False
    ingest_media.delay(media_id, request_id)
    return True
```

**S1 invariant:** `AVAILABLE_EXTRACTORS` is empty.
All calls deterministically return `False`.

---

## 5) Celery Task Definition (Safe No-Op)

**Location:** `python/nexus/tasks/ingest.py`

```python
@celery.task(bind=True, max_retries=3)
def ingest_media(
    self,
    media_id: UUID,
    request_id: str | None = None,
    *,
    _test_force_run: bool = False,
):
    """
    S1 SAFETY RULE:
    - If no extractor exists:
        - no-op (log + return)
        - do NOT mark failed
        - do NOT mutate state

    TEST-ONLY (_test_force_run):
    - Bypasses safety and exercises failure paths
    - HARD ENFORCEMENT:
        if _test_force_run and settings.NEXUS_ENV not in {'test', 'local'}:
            raise RuntimeError("_test_force_run forbidden in production")
      This check happens BEFORE opening any DB session.

    REQUIRED TEST:
    - test_force_run_forbidden_in_prod: mock NEXUS_ENV='prod', call with
      _test_force_run=True, assert RuntimeError raised
    """
```

**Behavior:**
- If extractor missing and `_test_force_run=False`: log + return
- If `_test_force_run=True`:
  - `worker_start_attempt`
  - `mark_failed(..., E_EXTRACTOR_NOT_IMPLEMENTED)`
- Transient errors use Celery retry
- Tasks open their own DB session

**Request ID propagation:**
Tasks must set up logging context with `request_id`:
```python
@celery.task(bind=True, max_retries=3)
def ingest_media(self, media_id, request_id=None, *, _test_force_run=False):
    with task_log_context(request_id=request_id, media_id=media_id):
        # All logs within this block include request_id and media_id
        logger.info("ingest_started")
        ...
```

**Helper location:** `python/nexus/logging.py`
```python
@contextmanager
def task_log_context(request_id: str | None, **extra):
    """Set structured logging context for Celery task execution."""
    # Uses contextvars or structlog context
```

---

## 6) URL Validation + Canonicalization

**Location:** `python/nexus/services/url.py`

### Validation Rules
- scheme ∈ {http, https}
- host required
- length ≤ 2048
- reject: ftp, file, data, javascript

### Canonicalization Rules
- lowercase scheme + host
- drop fragment
- strip tracking params: `utm_*`, `gclid`, `fbclid`
- drop default ports
- no query sorting
- no redirect resolution (future extractor concern)

---

## 7) YouTube URL Normalization (Required)

Handled in PR-05.

**Supported hosts:**
- `youtube.com`
- `www.youtube.com`
- `m.youtube.com`
- `youtu.be`
- `youtube-nocookie.com`

**Extraction patterns:**
| URL Pattern | ID Location |
|-------------|-------------|
| `youtube.com/watch?v={id}` | `v` query param |
| `youtube.com/embed/{id}` | path segment |
| `youtube.com/shorts/{id}` | path segment |
| `youtu.be/{id}` | path segment |
| `youtu.be/{id}?si=...` | path segment (ignore all query params) |

**ID validation:**
- Length: exactly 11 characters
- Charset: `[A-Za-z0-9_-]` (URL-safe base64)
- If ID doesn't match → `400 E_INVALID_URL` (not a valid YouTube video)

**Stored fields:**
- `provider = "youtube"`
- `provider_id = <video_id>` (the 11-char ID)
- `canonical_url = https://www.youtube.com/watch?v=<id>`
- `external_playback_url = same`

**Rationale:** Prevents duplicate rows for the same video across URL variants.

---

## 8) POST /media/url Endpoint

**New endpoint**

```
POST /media/url
```

**Allowed kinds:**
- `web_article`
- `video`

**Explicitly NOT allowed:**
- `podcast_episode` — Episodes are created via podcast subscription (S7), not direct URL
- `pdf` / `epub` — Use `POST /media/upload/init` for file uploads

If `kind` is not in the allowed set → `400 E_INVALID_KIND`

**Request:**
```json
{
  "kind": "web_article" | "video",
  "url": "https://..."
}
```

**Behavior:**
1. Validate + canonicalize URL
2. Normalize YouTube URLs (if `kind=video` and host matches)
3. **Transactional get-or-create:**
   ```python
   with transaction():
       media = get_or_create_media(kind, canonical_url)
       # ALWAYS ensure library_media row exists for viewer's default library
       # Even if media already existed globally and viewer wasn't a member
       ensure_library_media(viewer.default_library_id, media.id)
   ```
4. Call `maybe_enqueue_extraction(media.kind, media.id, request_id)` — **after commit** (returns false in S1)

**Critical:** Library membership must be in the same transaction as media creation/retrieval. Otherwise `GET /media/{id}` returns 404 even though media "exists".

**Response:**
```json
{
  "data": {
    "media_id": "...",
    "created": true | false,
    "enqueued": false
  }
}
```

---

## 9) POST /media/{id}/retry Endpoint

**New endpoint**

```
POST /media/{id}/retry
```

**Authorization:**
- Creator OR admin of any containing library

**Preconditions:**
- `processing_status` must be `failed`
- If not failed → `409 E_INVALID_STATE`

**Behavior:**
- Call `retry_media()` (validates status internally)
- Call `maybe_enqueue_extraction()` (no-op in S1)

**Response:**
```json
{
  "data": {
    "media_id": "...",
    "enqueued": false
  }
}
```

**UI:**
- Retry button visible only when `processing_status = failed`
- After retry: show "Queued (processor unavailable)"

---

## 10) API Error Codes (PR-05)

| Error Code | HTTP Status | When |
|------------|-------------|------|
| `E_INVALID_URL` | 400 | URL malformed, wrong scheme, too long, missing host |
| `E_INVALID_KIND` | 400 | `kind` not in allowed set for endpoint |
| `E_NOT_FOUND` | 404 | Media doesn't exist OR viewer can't read it |
| `E_FORBIDDEN` | 403 | Can read media but not authorized to retry (not creator/admin) |
| `E_INVALID_STATE` | 409 | Retry called on non-failed media |
| `E_EXTRACTOR_NOT_IMPLEMENTED` | — | Internal error code (stored in `last_error_code`, never returned to client) |

**Note:** `E_NOT_FOUND` is used for both "doesn't exist" and "can't read" to avoid existence leaks.

---

## 11) Celery Eager Mode for Tests

**Required change:**
- Celery config must read:
  - `CELERY_ALWAYS_EAGER=true` → `task_always_eager=True`
- Celery app creation must be lazy or settings-driven
- Tests rely on eager execution

---

## 12) Processing-State Integration Test Suite

**Scope:** FastAPI + DB + Redis (+ Storage when available)

**Must Cover:**
- `worker_start_attempt`:
  - `pending → extracting`
  - idempotent no-op if not pending
- `mark_failed`:
  - sets all failure fields when status is mutable
  - **ignores late failures** if status in {ready, ready_for_reading}
- `mark_ready_for_reading`:
  - `extracting → ready_for_reading`
  - **no-op** if status != extracting
- `retry_media`:
  - **requires `processing_status == failed`** → else `409 E_INVALID_STATE`
  - clears all failure + timing fields
  - resets to `pending`
- Celery task:
  - no-op without extractor
  - forced failure with `_test_force_run=True`
  - `_test_force_run` forbidden outside test/local
- URL validation failures (`E_INVALID_URL`)
- URL idempotency
- YouTube normalization:
  - `/watch?v=`, `/embed/`, `/shorts/`, `youtu.be/`
  - Query param stripping on `youtu.be`
  - ID validation (11 chars, URL-safe charset)
- Retry authorization enforcement
- Retry on non-failed media → `409 E_INVALID_STATE`

---

## 13) Invariants (Non-Negotiable)

- No extractor → no task enqueue
- No extractor → no failure pollution
- Retry never enqueues in S1
- Lifecycle state changes only via service functions
- Service functions never commit
- Tasks always open their own DB session
- Capabilities are respected (UI uses capabilities, not raw status)
- Podcast episodes are never created via URL

---

## 14) Acceptance Criteria

- All lifecycle transitions are deterministic
- Retry leaves no residue
- URL media creation is idempotent
- YouTube duplicates collapse correctly
- Celery tasks are safe even if accidentally invoked
- Processing-State test suite passes in CI

---

## End State

After PR-05, Slice 1 is structurally complete.
Future slices add extractors by registering them — not by changing lifecycle code.
