# Nexus Frontend

Next.js web application for Nexus. This is the BFF (Backend for Frontend) that proxies requests to FastAPI.

## Architecture

```
Browser → Next.js (this app) → FastAPI → Database
```

The browser **never** calls FastAPI directly. All requests go through Next.js route handlers which:
1. Extract the Supabase access token from the session
2. Generate or forward `X-Request-ID` header for tracing
3. Attach `Authorization: Bearer <token>` header
4. Attach `X-Nexus-Internal` header (BFF authentication)
5. Forward the request to FastAPI
6. Filter response headers via allowlist
7. Return the response to the browser with `X-Request-ID`

### Request Tracing

Every request has an `X-Request-ID` for debugging:
- Generated by BFF if not present in browser request
- Forwarded to FastAPI for correlation
- Included in all responses (success and error)
- Error responses include `request_id` in the body for easy copy/paste

### Response Header Security

The BFF filters FastAPI response headers via allowlist:
- **Allowed**: `X-Request-ID`, `Content-Type`, `Content-Length`
- **Blocked**: `Authorization`, `X-Nexus-Internal`, `Set-Cookie`, `X-Internal-*`

## Setup

The `.env.local` file is created automatically by `make setup`. If you need to create it manually:

```bash
# From repo root
make setup
```

Or create `apps/web/.env.local` manually with:

```bash
# Required: FastAPI backend URL
FASTAPI_BASE_URL=http://localhost:8000

# Required: Supabase local configuration (from supabase status)
NEXT_PUBLIC_SUPABASE_URL=http://127.0.0.1:54321
NEXT_PUBLIC_SUPABASE_ANON_KEY=<your-anon-key>

# Optional: Environment (default: local)
NEXUS_ENV=local

# Required in staging/prod: Internal API secret
# NEXUS_INTERNAL_SECRET=your-secret
```

To get your Supabase local credentials:
```bash
supabase status
```

## Development

```bash
# Install dependencies
npm install

# Start the development server
npm run dev

# Or from repo root
make web
```

The app runs at http://localhost:3000 by default.

**Prerequisites**:
- Supabase local must be running (`supabase start`)
- FastAPI server must be running (`make api`)

## Environment Variables

| Variable | Required | Description |
|----------|----------|-------------|
| `FASTAPI_BASE_URL` | Yes | FastAPI server URL |
| `NEXT_PUBLIC_SUPABASE_URL` | Yes | Supabase project URL (local: `http://127.0.0.1:54321`) |
| `NEXT_PUBLIC_SUPABASE_ANON_KEY` | Yes | Supabase anon key |
| `NEXUS_ENV` | No | Environment (default: `local`) |
| `NEXUS_INTERNAL_SECRET` | staging/prod | Internal API secret |

## Project Structure

```
src/
├── app/                    # Next.js app router
│   ├── api/                # BFF proxy routes (mirror FastAPI paths)
│   │   ├── me/
│   │   ├── libraries/
│   │   ├── media/
│   │   ├── fragments/      # Highlight creation endpoints (PR-09)
│   │   │   └── [fragmentId]/highlights/
│   │   └── highlights/     # Highlight CRUD endpoints (PR-09)
│   │       └── [highlightId]/
│   │           └── annotation/
│   ├── (authenticated)/    # Protected pages (require login)
│   │   ├── libraries/
│   │   └── media/
│   ├── login/              # Login page
│   └── auth/               # Auth callbacks
├── components/             # React components
│   ├── HtmlRenderer.tsx    # ONLY place with dangerouslySetInnerHTML
│   ├── SelectionPopover.tsx    # Highlight color picker (PR-09)
│   ├── HighlightEditor.tsx     # Highlight edit/delete UI (PR-09)
│   ├── AnnotationEditor.tsx    # Note editor (PR-09)
│   ├── LinkedItemsPane.tsx     # Aligned linked-items container (PR-10)
│   ├── LinkedItemRow.tsx       # Linked-item row component (PR-10)
│   ├── Navbar.tsx
│   ├── Pane.tsx
│   └── ...
├── lib/                    # Utilities
│   ├── api/
│   │   └── proxy.ts        # BFF proxy helper (proxyToFastAPI)
│   ├── highlights/         # Highlight rendering utilities
│   │   ├── index.ts            # Module exports
│   │   ├── segmenter.ts        # Overlap segmentation (PR-07)
│   │   ├── canonicalCursor.ts  # DOM-to-offset mapping (PR-08)
│   │   ├── applySegments.ts    # Highlight DOM application (PR-08)
│   │   ├── selectionToOffsets.ts   # Selection conversion (PR-09)
│   │   ├── useHighlightInteraction.ts  # Focus/cycling hook (PR-09)
│   │   ├── alignmentEngine.ts  # Vertical alignment logic (PR-10)
│   │   └── highlights.css      # Highlight styles
│   └── supabase/
│       ├── server.ts       # Server-side Supabase client
│       └── middleware.ts   # Session refresh + auth redirects
└── middleware.ts           # Auth redirect + CSP
```

## Key Constraints

### Security

- **No tokens in localStorage**: Access tokens exist only in server runtime
- **Single HtmlRenderer**: Only component allowed to use `dangerouslySetInnerHTML`
- **BFF only**: All browser → backend traffic goes through Next.js

### Route Handlers

Each route handler must:
- Be 3-10 lines of actual logic
- Delegate to `proxyToFastAPI()` for all backend communication
- NOT perform custom request shaping beyond path parameters
- NOT add business logic (that belongs in FastAPI)

Example:
```typescript
export async function GET(req: Request, { params }: { params: { id: string } }) {
  const { id } = await params;
  return proxyToFastAPI(req, `/libraries/${id}`);
}
```

## Testing

```bash
# Run tests
npm test

# Run tests in watch mode
npm run test:watch

# Run tests for CI
npm run test:ci

# Run TypeScript type checking
npm run typecheck
```

## Highlight Libraries

The highlights module (`lib/highlights/`) provides everything needed for rendering highlights on web articles.

### Module Overview

```typescript
// Import everything from the module index
import {
  // Segmenter (PR-07)
  segmentHighlights,
  HIGHLIGHT_COLORS,
  type NormalizedHighlight,
  type Segment,
  
  // Canonical cursor (PR-08)
  buildCanonicalCursor,
  validateCanonicalText,
  codepointLength,
  BLOCK_ELEMENTS,
  
  // Apply highlights (PR-08)
  applyHighlightsToHtml,
  applyHighlightsToHtmlMemoized,
  clearHighlightCache,
  type HighlightInput,
  
  // Selection conversion (PR-09)
  selectionToOffsets,
  findDuplicateHighlight,
  selectionIntersectsCodeBlock,
  MIN_HIGHLIGHT_LENGTH,
  MAX_HIGHLIGHT_LENGTH,
  
  // Highlight interaction (PR-09)
  useHighlightInteraction,
  parseHighlightElement,
  findHighlightElement,
  applyFocusClass,
  reconcileFocusAfterRefetch,
  
  // Alignment engine (PR-10)
  measureAnchorPositions,
  computeAlignedRows,
  computeScrollTarget,
  createMeasureScheduler,
  createScrollHandler,
  ROW_HEIGHT,
  ROW_GAP,
  SCROLL_TARGET_FRACTION,
  MEASURE_DEBOUNCE_MS,
  type AlignmentHighlight,
  type AlignedRow,
} from '@/lib/highlights';
```

### `segmenter.ts` - Overlap Segmentation (PR-07)

A pure, deterministic overlap segmenter for highlights. This module:

- Takes a text length (codepoints) and list of highlight ranges
- Produces disjoint segments annotated with active highlight IDs
- Determines the "topmost" highlight using `(created_at_ms DESC, id ASC)` ordering
- Has no DOM or backend dependencies (used by rendering and interaction code)

```typescript
const result = segmentHighlights(textLen, highlights);
// result.segments: Segment[] - disjoint highlighted ranges
// result.droppedIds: string[] - invalid highlights that were ignored
```

**Invariants guaranteed:**
1. Segments are strictly ordered (non-overlapping)
2. No zero-width segments
3. Each segment has at least one active highlight
4. `topmostId` is the first element of `activeIds`
5. Output is deterministic regardless of input order
6. No adjacent segments with identical active sets
7. Coverage equals union of valid highlight ranges

### `canonicalCursor.ts` - DOM-to-Offset Mapping (PR-08)

Builds a mapping from DOM text nodes to codepoint offsets in canonical text. **Must match backend canonicalization exactly** (`python/nexus/services/canonicalize.py`).

```typescript
const result = buildCanonicalCursor(rootElement);
// result.nodes: CanonicalNode[] - text nodes with start/end offsets
// result.emitted: string - reconstructed canonical text
// result.length: number - codepoint length

// Validate against backend canonical_text
const isValid = validateCanonicalText(result, fragment.canonical_text, fragmentId);
```

**Canonicalization rules (matching backend):**
- Unicode NFC normalization
- Whitespace collapse (all Unicode whitespace → single space)
- Block boundaries insert `\n`
- `<br>` inserts `\n`
- Exclude `script`, `style`, hidden elements, `aria-hidden="true"`

### `applySegments.ts` - Highlight Rendering (PR-08)

Applies highlight segments to sanitized HTML by wrapping text in `<span>` elements.

```typescript
// Simple usage
const result = applyHighlightsToHtml(
  fragment.html_sanitized,
  fragment.canonical_text,
  fragment.id,
  highlights
);
// result.html: string - transformed HTML with highlight spans
// result.failedIds: string[] - highlights that couldn't be rendered
// result.validationPassed: boolean - canonical text matched

// With memoization (recommended for React)
const result = applyHighlightsToHtmlMemoized(
  fragment.html_sanitized,
  fragment.canonical_text,
  fragment.id,
  highlights
);
```

**HTML output:**
```html
<!-- Highlight spans (PR-10: space-delimited IDs) -->
<span data-active-highlight-ids="h1 h2" data-highlight-top="h1" class="hl-yellow">
  highlighted text
</span>

<!-- Highlight anchors (for positioning linked-items) -->
<span data-highlight-anchor="h1"></span>
```

### `selectionToOffsets.ts` - Selection Conversion (PR-09)

Converts browser text selections to canonical offsets for highlight creation.

```typescript
import {
  selectionToOffsets,
  findDuplicateHighlight,
  selectionIntersectsCodeBlock,
  MIN_HIGHLIGHT_LENGTH,
  MAX_HIGHLIGHT_LENGTH,
} from '@/lib/highlights';

// Convert a browser Range to canonical offsets
const result = selectionToOffsets(range, cursor, canonicalText, mismatchDisabled);
if (result.success) {
  // result.startOffset, result.endOffset - codepoint offsets
  // result.selectedText - the trimmed selected text
}

// Check for duplicate highlight before creating
const existingId = findDuplicateHighlight(highlights, startOffset, endOffset);
```

**Features:**
- Handles backwards selections (right-to-left)
- Converts UTF-16 indices to codepoints (handles emoji)
- Trims leading/trailing whitespace
- Validates length (2-2000 codepoints)
- Rejects selections inside `<pre>`/`<code>` blocks
- Guards against mismatch state

### `useHighlightInteraction.ts` - Interaction Hook (PR-09)

React hook for managing highlight focus and overlap cycling.

```typescript
import { useHighlightInteraction, parseHighlightElement, applyFocusClass } from '@/lib/highlights';

const { focusState, focusHighlight, handleHighlightClick, startEditBounds } = useHighlightInteraction();

// On highlight span click:
const onClick = (e: React.MouseEvent) => {
  const el = findHighlightElement(e.target as Element);
  if (el) {
    const data = parseHighlightElement(el);
    if (data) handleHighlightClick(data);
  }
};

// Apply focus class to DOM (doesn't trigger re-render)
applyFocusClass(containerRef.current, focusState.focusedId);
```

**Focus model:**
- At most one highlight is focused at any time
- First click focuses the topmost highlight
- Subsequent clicks on the same segment cycle through overlapping highlights
- Clicking a different segment resets cycling

### `alignmentEngine.ts` - Vertical Alignment (PR-10)

Core logic for aligning linked-items pane rows to highlight anchors in the content pane.

```typescript
import {
  measureAnchorPositions,
  computeAlignedRows,
  computeScrollTarget,
  createMeasureScheduler,
  createScrollHandler,
  ROW_HEIGHT,
  ROW_GAP,
} from '@/lib/highlights';

// Phase 1: Measure anchor positions (expensive, call on mount/resize/image load)
const positions = measureAnchorPositions(contentElement, highlights);

// Phase 2: Compute aligned rows (cheap, call on scroll)
const { rows, missingAnchorIds } = computeAlignedRows(highlights, positions, scrollTop);

// Each row has: highlight, desiredY (from anchor), top (after collision resolution)
rows.forEach(row => {
  const el = rowRefs.get(row.highlight.id);
  if (el) el.style.transform = `translateY(${row.top}px)`;
});
```

**Two-Phase Alignment Model:**
1. **Measurement Phase** (debounced): Reads DOM to get anchor positions in document space
2. **Scroll Phase** (per-frame): Computes row positions from cached positions + scrollTop

**Collision Resolution:**
- Rows sorted by visual position + canonical tie-breakers
- Push-down stacking with minimum gap ensures rows never overlap
- Order: `(desiredY ASC, start_offset ASC, end_offset ASC, created_at_ms ASC, id ASC)`

**Constants:**
- `ROW_HEIGHT = 28px` - Fixed row height
- `ROW_GAP = 4px` - Minimum gap between rows
- `SCROLL_TARGET_FRACTION = 0.2` - Fraction from top when scrolling to highlight
- `MEASURE_DEBOUNCE_MS = 75` - Debounce interval for measurement

### `highlights.css` - Styles (PR-08/09/10)

CSS classes for highlight colors:
- `.hl-yellow` - Default yellow highlight
- `.hl-green` - Green highlight
- `.hl-blue` - Blue highlight
- `.hl-pink` - Pink highlight
- `.hl-purple` - Purple highlight
- `.hl-focused` - Focus ring for selected highlight (PR-09)
- `.hl-hover-outline` - Outline for highlight spans when linked-item row is hovered (PR-10)

Anchors are invisible zero-width spans used for positioning the linked-items pane.

### Components (PR-09/10)

- `SelectionPopover.tsx` - Color picker popover shown on text selection
- `HighlightEditor.tsx` - Edit bounds, change color, delete highlights
- `AnnotationEditor.tsx` - Add/edit/delete notes on highlights
- `LinkedItemsPane.tsx` - Vertically aligned linked-items container (PR-10)
- `LinkedItemRow.tsx` - Individual linked-item row with color swatch and text preview (PR-10)

## Linting

```bash
npm run lint
```

## Building

```bash
npm run build
npm start
```
